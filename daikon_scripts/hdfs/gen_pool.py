import os,sys,time
import re

daikon_rule_filename = 'daikon_report.txt.java'
#this is to get the type info of states
merged_input_filename = 't2c.dtraces.merged'
pool_filename_prefix = 'InvariantPool'

inv_capacity_per_class = 2000

#map var to types
var2type_dict = {}

def rchop(s, suffix):
    if suffix and s.endswith(suffix):
        return s[:-len(suffix)]
    return s

def getBoxInfo(var):
    if var not in var2type_dict:
        raise Exception(var+" not found in dict!")
    typename = var2type_dict[var]
    boxType = ''
    primFunc = ''
    if typename == 'int':
        boxType = 'Integer'
        primFunc = 'intValue'
    elif typename == 'boolean':
        boxType = 'Boolean'
        primFunc = 'booleanValue'
    elif typename == 'long':
        boxType = 'Long'
        primFunc = 'longValue'
    elif typename == 'double':
        boxType = 'Double'
        primFunc = 'doubleValue'
    elif typename == 'float':
        boxType = 'Float'
        primFunc = 'floatValue'
    elif typename == 'short':
        boxType = 'Short'
        primFunc = 'shortValue'
    elif typename == 'char':
        boxType = 'Char'
        primFunc = 'charValue'
    elif typename == 'java.lang.Object[]':
        boxType = 'arr'
        primFunc = ''
    else:
        print(var+' '+typename)
        raise Exception("not supported type!")
        

    return (boxType, primFunc)

def classi2ClassFile(classi):
    if classi == 0:
        return pool_filename_prefix
    else:
        return pool_filename_prefix + str(classi)

def construct_func(inv):
    #the main idea is replace var with our value getter
    arg_lst = re.split("([^\\w.\\$]+)", inv)
    for i in range(len(arg_lst)):
        arg = arg_lst[i]
        print(arg)
        if 'instance' in arg:
            try:
                boxType, primFunc = getBoxInfo(arg)
            except:
                return 'true'
            if boxType == 'arr':
                #map related states
                arg_lst[i] = '(Set.class.cast(InvariantChecker.getValue("'+rchop(arg, '_FOR_ENCLOSING_USE')+'")).toArray(new Object[0]))'
            else:
                #non-map related states
                arg_lst[i] = '(('+boxType+')(InvariantChecker.getValue("'+arg+'"))).'+primFunc+'()'
    return ''.join(arg_lst)

def write_class_header(f, class_file_i):
    s = 'package daikon;\n'
    s += 'import java.util.Set;\n'
    s += 'import java.util.ArrayList;\n'
    s += 'import java.util.List;\n'
    s += '//this class is automatically generated by our scripts\n'
    if class_file_i == 0:
        s += 'public class InvariantPool {\n\n'
        #only need to have one invariant list
        s += '\tpublic static List<Invariant> invariants = new ArrayList<>();\n\n'
    else:
        s += 'public class InvariantPool'+str(class_file_i)+' {\n\n'

    f.write(s)

def write_class_tail(f):
    s = '}\n'
    f.write(s)

def write_installgroupfunc(f, total_count, class_file_i):
    total_group = total_count/inv_capacity_per_class+1
    
    s = ''
    
    s += '\tpublic static void installGroup'+str(class_file_i)+'() {\n'
    for j in range(class_file_i*inv_capacity_per_class,(class_file_i+1)*inv_capacity_per_class):
        if j >= total_count:
            break
        s += classi2ClassFile(j/inv_capacity_per_class)+'.installInv'+str(j)+'();'
    s += '\t}\n'
    f.write(s)
        
def write_staticblock(f, total_count, class_file_i):
    #only need to do for the first one
    if class_file_i != 0:
        return

    total_group = total_count/inv_capacity_per_class+1
    #again, we ensure this is scalable
    s = '\tstatic {\n'
    for i in range(total_group):
        if i==0:
            s += '\t\t'+pool_filename_prefix+'.installGroup' + str(i)+'();\n'
        else:
            s += '\t\t'+pool_filename_prefix+str(i)+'.installGroup' + str(i)+'();\n'
    s += '\t}\n'


    f.write(s)

def write_invariant(f, i, inv, stmt):
    s = '\tpublic static void installInv'+str(i)+'(){\n'
    s += '\t\tInvariant inv'+str(i)+' = new Invariant('+str(i)+',"'+inv+'"){\n'
    s += '\t\t\t@SuppressWarnings("unchecked")\n'
    s += '\t\t\tpublic boolean check() {\n'
    s += "\t\t\t\treturn ("+stmt+");\n"
    s += '\t\t\t};\n'
    s += '\t\t};\n'
    s += '\t\tInvariantPool.invariants.add(inv'+str(i)+');\n'
    s += '\t}\n\n'
    f.write(s)

def readtype_phase():
    global var2type_dict

    with open(merged_input_filename, 'r') as decl_file:
        varname = ''
        typename = ''

        line = decl_file.readline()
        while line:
            line = decl_file.readline()
            if 'this_invocation_nonce' in line:
                break
            if line.startswith('variable '):
                varname = line.split()[1]
            if line.startswith('dec-type '):
                typename = line.split()[1]
                var2type_dict[varname] = typename

def parse_phase():
    print("now reading daikon output...")
    with open(daikon_rule_filename, 'r') as rule_file:
        lines = rule_file.readlines()

        count = 0
        invariant_lst = []
        func_lst = []
        
        for line in lines[5:-1]:
            line = line.rstrip()
            invariant_lst.append(line)
            func_lst.append(construct_func(line))
            count += 1

        class_file_num = len(lines)/inv_capacity_per_class+1
        for class_file_i in range(class_file_num):
            pool_filename = classi2ClassFile(class_file_i) + '.java'
            with open(pool_filename, 'w') as pool_file:
                write_class_header(pool_file, class_file_i)
                for i in range(class_file_i*inv_capacity_per_class,(class_file_i+1)*inv_capacity_per_class):
                    if i >= len(invariant_lst):
                        break
                    write_invariant(pool_file, i, invariant_lst[i],func_lst[i])
                write_installgroupfunc(pool_file, len(invariant_lst), class_file_i)
                write_staticblock(pool_file, len(invariant_lst), class_file_i)
                write_class_tail(pool_file)

        print("done, generated "+str(class_file_num)+" classes")

def main():
    readtype_phase()
    parse_phase()

if __name__ == "__main__":
    main()

