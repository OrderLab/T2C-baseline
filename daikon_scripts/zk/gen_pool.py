import glob
import os
import re

daikon_rule_filename = 'hdfs.daikon_report.txt'
#this is to get the type info of states
input_filename_list = 'hdfs.file_list.txt'
inv_list_name = 'hdfs.inv_list.txt'
SYS_PACKAGE_NAME = "hdfs"
print(os.getcwd())
pool_filename = os.getcwd()+ f'/src/main/java/daikon/{SYS_PACKAGE_NAME}/InvariantPool.java'

#map var to types
var2type_dict = {}

root_nodes = ["zksInstance","modifyTableProcedureInstance","reopenTableRegionsProcedureInstance","regionStatesInstance","HMasterInstance","DataNode.instance","NameNode.instance","blockManagerInstance","cfsInstance","resultSetInstance","fromResultListInstance","fromPagerInstance","CFMetadataInstance","StorageService.instance","Schema.instance","CommitLog.instance","QueryProcessor.instance","SizeEstimatesRecorder.instance"]

def gen_pool_filename(num=None):
    if not num:
        return os.getcwd() + f"/src/main/java/daikon/{SYS_PACKAGE_NAME}/InvariantPool.java"    
    return os.getcwd() + f"/src/main/java/daikon/{SYS_PACKAGE_NAME}/InvariantPool{num}.java"

def rchop(s, suffix):
    if suffix and s.endswith(suffix):
        return s[:-len(suffix)]
    return s

def rm_bracket(line):
    idx = line.rfind("(")
    return line[:idx].strip()

def getBoxInfo(var):
    if var not in var2type_dict:
        raise Exception(var+" not found in dict!")
    typename = var2type_dict[var]
    boxType = ''
    primFunc = ''
    if typename == 'int':
        boxType = 'Integer'
        primFunc = 'intValue'
    elif typename == 'boolean':
        boxType = 'Boolean'
        primFunc = 'booleanValue'
    elif typename == 'long':
        boxType = 'Long'
        primFunc = 'longValue'
    elif typename == 'double':
        boxType = 'Double'
        primFunc = 'doubleValue'
    elif typename == 'float':
        boxType = 'Float'
        primFunc = 'floatValue'
    elif typename == 'short':
        boxType = 'Short'
        primFunc = 'shortValue'
    elif typename == 'char':
        boxType = 'Char'
        primFunc = 'charValue'
    elif typename == 'java.lang.Object[]':
        boxType = 'arr'
        primFunc = ''
    else:
        print(var+' '+typename)
        raise Exception("not supported type!")
        

    return (boxType, primFunc)

def construct_func(inv):
    #the main idea is replace var with our value getter
    arg_lst = re.split("([^\\w.\\$]+)", inv)
    for i in range(len(arg_lst)):
        arg = arg_lst[i]
        print(arg)

        should_parse = False

        for node in root_nodes:
            if node in arg:
                should_parse = True
        
        if should_parse: 
            boxType, primFunc = getBoxInfo(arg)
            if boxType == 'arr':
                #map related states
                arg_lst[i] = '(Set.class.cast(InvariantChecker.getValue("'+rchop(arg, '_FOR_ENCLOSING_USE')+'")).toArray(new Object[0]))'
            elif boxType == 'Short' or boxType == 'Integer' or boxType == 'Long' or boxType == 'Float' or boxType == 'Double':
                #non-map related states
                arg_lst[i] = '((Number)(InvariantChecker.getValue("'+arg+'"))).'+primFunc+'()'
            else:
                arg_lst[i] = '(('+boxType+')(InvariantChecker.getValue("'+arg+'"))).'+primFunc+'()'
    return ''.join(arg_lst)

def write_class_header(f, num):
    s = f'package daikon.{SYS_PACKAGE_NAME};\n'
    s += 'import daikon.*;\n'
    s += 'import java.util.Set;\n'
    s += 'import java.util.ArrayList;\n'
    s += 'import java.util.List;\n'
    s += '//this class is automatically generated by our scripts\n'
    s += 'public class InvariantPool'+str(num)+'{\n\n'
    s += f'\tpublic static List<Invariant> invariants{num} = new ArrayList<>();\n\n'
    f.write(s)

def write_class_tail(f):
    s = '}\n'
    f.write(s)

def write_staticblock(f, idx):
    s = '\tstatic {\n'
    s += 'installInv'+str(idx)+'();'
    # for i in range(0,total_count, n_num):
    #     s += 'installInv'+str(i)+'();'
    s += '\t}\n'
    f.write(s)

def write_invariant(f, idx, start, inv, stmt):
    s = '\tpublic static void installInv'+str(idx)+'(){\n'

    for i in range(len(inv)):
        s += f"\t\tinvariants{idx}.add(new Invariant("+str(start+i)+", \""+inv[i]+"\"){\n"
        s += '\t\t\t@SuppressWarnings("unchecked")\n'
        s += '\t\t\tpublic boolean check() {\n'
        s += f'\t\t\t\treturn ({stmt[i]});\n'
        s += '\t\t\t}\n'
        s += '\t\t});\n'

    s += '\t}\n'
    f.write(s)

def write_parent(f, idx_arr):
    s = f'package daikon.{SYS_PACKAGE_NAME};\n'
    s += 'import daikon.*;\n'
    s += 'import java.util.Set;\n'
    s += 'import java.util.ArrayList;\n'
    s += 'import java.util.List;\n'
    s += '//this class is automatically generated by our scripts\n'
    s += 'public class InvariantPool{\n\n'
    s += f'\tpublic static List<Invariant> invariants = new ArrayList<>();\n\n'

    s += '\tstatic {\n'
    for idx in idx_arr:
        s += f'\t\tinvariants.addAll(InvariantPool{idx}.invariants{idx});\n'
    s += '\t}\n'

    s += '}\n'
    f.write(s)

def clear_phase():
    files = glob.glob(os.getcwd()+ f'/src/main/java/daikon/{SYS_PACKAGE_NAME}/*.java')
    for f in files:
        try:
            os.remove(f)
        except OSError as e:
            print("Error: %s : %s" % (f, e.strerror))

def readtype_phase():
    global var2type_dict

    with open(input_filename_list, 'r') as file_list:
        for filename in file_list:
            with open(filename.strip(), 'r') as decl_file:
                varname = ''
                typename = ''

                line = decl_file.readline()
                while line:
                    line = decl_file.readline()
                    if 'this_invocation_nonce' in line:
                        break
                    if line.startswith('variable '):
                        varname = line.split()[1]
                    if line.startswith('dec-type '):
                        typename = line.split()[1]
                        var2type_dict[varname] = typename

def parse_phase():
    print("now reading daikon output...")
    with open(daikon_rule_filename, 'r') as rule_file:
        lines = rule_file.readlines()

        invariant_lst = []
        func_lst = []

        n_num = 1000

        for line in lines:
            line = line.strip()

            if line.startswith("==========") or line.startswith("org.apache.zookeeper") or line.startswith("org.apache.cassandra") or line.startswith("org.apache.hadoop") or line.startswith("Variables") or (line.strip() == "") or "oneOf.java.jpp: SEQUENCE unimplemented" in line:
                continue

            # print(line)
            # line = rm_bracket(line)

            if line not in invariant_lst:
                invariant_lst.append(line)
                func_lst.append(construct_func(line))
        
        invariant_lst = list(invariant_lst)
        func_lst = list(func_lst)

        idx_arr = []

        for i in range(0,len(invariant_lst), n_num):
            if i<len(invariant_lst)-n_num:
                idx = i+n_num-1
                idx_arr.append(idx)
                with open(gen_pool_filename(idx), 'w') as pool_file:
                    write_class_header(pool_file, idx)
                    write_invariant(pool_file, idx, i, invariant_lst[i:i+n_num],func_lst[i:i+n_num])
                    write_staticblock(pool_file, idx)
                    write_class_tail(pool_file)

                    print(f"done {idx}")
            else:
                idx = len(invariant_lst)-1
                idx_arr.append(idx)
                with open(gen_pool_filename(idx), 'w') as pool_file:
                    write_class_header(pool_file, idx)
                    write_invariant(pool_file, idx, i, invariant_lst[i:],func_lst[i:])
                    write_staticblock(pool_file, idx)
                    write_class_tail(pool_file)

                    print(f"done {idx}")
        
        with open(gen_pool_filename(), 'w') as parent_file:
            write_parent(parent_file, idx_arr)

        print(len(invariant_lst))

        with open(os.getcwd()+f"/{inv_list_name}", 'w') as inv_list_file:
            for inv in invariant_lst:
                inv_list_file.write(inv+"\n")

def compile_phase():
    os.system("mvn clean package -DskipTests")

def main():
    clear_phase()
    readtype_phase()
    # print(var2type_dict)
    parse_phase()
    compile_phase()

if __name__ == "__main__":
    main()

