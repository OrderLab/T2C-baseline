DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT == daikon.Quant.size(DataNode.instance.directoryScanner.diffs_FOR_ENCLOSING_USE)-1
DataNode.instance.NUM_CORES == NameNode.instance.namesystem.dir.inodeXAttrsLimit
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs == NameNode.instance.namesystem.cacheManager.scanIntervalMs
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs == blockManagerInstance.datanodeManager.staleInterval
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.connectToDnViaHostname
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.data.blockPinningEnabled
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.directoryScanner.retainDiffs
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.dnConf.allowNonLocalLazyPersist
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.fileIoProvider.profilingEventHook.isEnabled
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.heartbeatsDisabledForTests
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.ibrDisabledForTests
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.id.exportedKeys.isBlockTokenEnabled
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.isBlockTokenEnabled
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.pipelineSupportECN
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.shortCircuitRegistry.enabled
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.shutdownForUpgrade
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.shutdownInProgress
DataNode.instance.cacheReportsDisabledForTests == blockManagerInstance.bmSafeMode.haEnabled
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION == blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION == daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == DataNode.instance.directoryScanner.diffs.serialVersionUID
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == DataNode.instance.id.nsInfo.capabilities
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == blockManagerInstance.bmSafeMode.safeReplication
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == DataNode.instance.httpServer.HTTP_MAX_THREADS
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS == DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.data.cacheManager.numBlocksCached
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.directoryScanner.timeRunningMs
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.directoryScanner.timeWaitingMs
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.diskBalancer.currentResult.result
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.dnConf.ibrInterval
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.fileIoProvider.profilingEventHook.sampleRangeMax
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.id.exportedKeys.keyUpdateInterval
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.id.exportedKeys.tokenLifetime
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.id.infoSecurePort
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.infoSecurePort
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.xmitsInProgress
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.blockIdManager.legacyGenerationStampLimit
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME == DataNode.instance.data.asyncLazyPersistService.MAXIMUM_THREADS_PER_VOLUME
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME == DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME == DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME == blockManagerInstance.bmSafeMode.safeReplication
DataNode.instance.data.blockPinningEnabled == DataNode.instance.data.isNativeIOAvailable
DataNode.instance.data.blockPinningEnabled == DataNode.instance.dnConf.allowNonLocalLazyPersist
DataNode.instance.data.blockPinningEnabled == blockManagerInstance.bmSafeMode.haEnabled
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.data.cacheManager.numBlocksFailedToCache
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.data.volFailuresTolerated
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.dnConf.ibrInterval
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.blockIdManager.legacyGenerationStampLimit
DataNode.instance.data.cacheManager.revocationMs == DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks
DataNode.instance.data.cacheManager.revocationPollingMs == DataNode.instance.xserver.balanceThrottler.period
DataNode.instance.data.cacheManager.revocationPollingMs == blockManagerInstance.maxCorruptFilesReturned
DataNode.instance.data.fsRunning == DataNode.instance.directoryScanner.shouldRun
DataNode.instance.data.fsRunning == DataNode.instance.dnConf.pmemCacheRecoveryEnabled
DataNode.instance.data.fsRunning == blockManagerInstance.checkNSRunning
DataNode.instance.data.fsRunning == blockManagerInstance.datanodeManager.shouldSendCachingCommands
DataNode.instance.data.maxDataLength == DataNode.instance.dnConf.maxDataLength
DataNode.instance.data.smallBufferSize == NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN
DataNode.instance.data.volsConfigured == DataNode.instance.dnConf.volsConfigured
DataNode.instance.data.volsConfigured == blockManagerInstance.blocksReplWorkMultiplier
DataNode.instance.data.volsConfigured == daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
DataNode.instance.directoryScanner.MILLIS_PER_SECOND == DataNode.instance.directoryScanner.RECONCILE_BLOCKS_BATCH_SIZE
DataNode.instance.directoryScanner.MILLIS_PER_SECOND == DataNode.instance.directoryScanner.throttleLimitMsPerSec
DataNode.instance.directoryScanner.MILLIS_PER_SECOND == DataNode.instance.maxNumberOfBlocksToLog
DataNode.instance.directoryScanner.MILLIS_PER_SECOND == NameNode.instance.namesystem.blockDeletionIncrement
DataNode.instance.directoryScanner.MILLIS_PER_SECOND == blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP
DataNode.instance.directoryScanner.diffs_FOR_ENCLOSING_USE == NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE
DataNode.instance.directoryScanner.diffs_FOR_ENCLOSING_USE == NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE
DataNode.instance.directoryScanner.diffs_FOR_ENCLOSING_USE == NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE
DataNode.instance.directoryScanner.diffs_FOR_ENCLOSING_USE == NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE
DataNode.instance.directoryScanner.scanPeriodMsecs == DataNode.instance.dnConf.blockReportInterval
DataNode.instance.directoryScanner.shouldRun == DataNode.instance.diskBalancer.isDiskBalancerEnabled
DataNode.instance.directoryScanner.shouldRun == DataNode.instance.dnConf.pmemCacheRecoveryEnabled
DataNode.instance.directoryScanner.shouldRun == DataNode.instance.hasAnyBlockPoolRegistered
DataNode.instance.directoryScanner.shouldRun == DataNode.instance.isPermissionEnabled
DataNode.instance.directoryScanner.shouldRun == DataNode.instance.shouldRun
DataNode.instance.directoryScanner.shouldRun == blockManagerInstance.checkNSRunning
DataNode.instance.directoryScanner.shouldRun == blockManagerInstance.datanodeManager.shouldSendCachingCommands
DataNode.instance.diskBalancer.bandwidth == NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE
DataNode.instance.diskBalancer.bandwidth == blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE
DataNode.instance.dnConf.allowNonLocalLazyPersist == DataNode.instance.dnConf.connectToDnViaHostname
DataNode.instance.dnConf.allowNonLocalLazyPersist == DataNode.instance.dnConf.diskStatsEnabled
DataNode.instance.dnConf.allowNonLocalLazyPersist == DataNode.instance.dnConf.dropCacheBehindReads
DataNode.instance.dnConf.allowNonLocalLazyPersist == DataNode.instance.dnConf.dropCacheBehindWrites
DataNode.instance.dnConf.allowNonLocalLazyPersist == DataNode.instance.dnConf.encryptDataTransfer
DataNode.instance.dnConf.allowNonLocalLazyPersist == DataNode.instance.dnConf.ignoreSecurePortsForTesting
DataNode.instance.dnConf.allowNonLocalLazyPersist == DataNode.instance.dnConf.overwriteDownstreamDerivedQOP
DataNode.instance.dnConf.allowNonLocalLazyPersist == DataNode.instance.dnConf.peerStatsEnabled
DataNode.instance.dnConf.allowNonLocalLazyPersist == DataNode.instance.dnConf.syncBehindWrites
DataNode.instance.dnConf.allowNonLocalLazyPersist == DataNode.instance.dnConf.syncBehindWritesInBackground
DataNode.instance.dnConf.allowNonLocalLazyPersist == DataNode.instance.dnConf.syncOnClose
DataNode.instance.dnConf.allowNonLocalLazyPersist == DataNode.instance.fileIoProvider.faultInjectorEventHook.isEnabled
DataNode.instance.dnConf.allowNonLocalLazyPersist == DataNode.instance.xserver.closed
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.STANDBY_STATE.isObserver
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.allowStaleStandbyReads
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.haEnabled
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.alwaysUseDelegationTokensForTests
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.datanodeStatistics.enableLogStaleNodes
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.dir.isPermissionContentSummarySubAccess
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.dir.posixAclInheritanceEnabled
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.dir.skipQuotaCheck
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.dtpReplaceDatanodeOnFailure.bestEffort
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.fsImage.exitAfterSave
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.fsLock.metricsEnabled
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.haEnabled
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.isDefaultAuditLogger
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.manualSafeMode
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.needRollbackFsImage
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.resourceLowSafeMode
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.snapshotManager.allowNestedSnapshots
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.snapshotManager.captureOpenFiles
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.snapshotManager.skipCaptureAccessTimeOnlyChange
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.startingActiveService
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.stopRequested
DataNode.instance.dnConf.allowNonLocalLazyPersist == blockManagerInstance.bmSafeMode.haEnabled
DataNode.instance.dnConf.cacheReportInterval == NameNode.instance.namesystem.fsLock.lockSuppressWarningIntervalMs
DataNode.instance.dnConf.cacheReportInterval == NameNode.instance.namesystem.maxBlocksPerFile
DataNode.instance.dnConf.cacheReportInterval == blockManagerInstance.blocksPerPostpondedRescan
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs == NameNode.instance.namesystem.lazyPersistFileScrubIntervalSec
DataNode.instance.dnConf.heartBeatInterval == NameNode.instance.namesystem.edekCacheLoaderDelay
DataNode.instance.dnConf.heartBeatInterval == blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
DataNode.instance.dnConf.ibrInterval == DataNode.instance.dnConf.initialBlockReportDelayMs
DataNode.instance.dnConf.ibrInterval == DataNode.instance.dnConf.maxLockedMemory
DataNode.instance.dnConf.ibrInterval == DataNode.instance.dnConf.transferSocketRecvBufferSize
DataNode.instance.dnConf.ibrInterval == DataNode.instance.dnConf.transferSocketSendBufferSize
DataNode.instance.dnConf.ibrInterval == DataNode.instance.dnConf.volFailuresTolerated
DataNode.instance.dnConf.ibrInterval == DataNode.instance.storage.cTime
DataNode.instance.dnConf.ibrInterval == DataNode.instance.storageLocationChecker.delegateChecker.diskCheckTimeout
DataNode.instance.dnConf.ibrInterval == DataNode.instance.volumeChecker.maxVolumeFailuresTolerated
DataNode.instance.dnConf.ibrInterval == DataNode.instance.volumeChecker.numAsyncDatasetChecks
DataNode.instance.dnConf.ibrInterval == DataNode.instance.volumeChecker.numSkippedChecks
DataNode.instance.dnConf.ibrInterval == DataNode.instance.volumeChecker.numVolumeChecks
DataNode.instance.dnConf.ibrInterval == DataNode.instance.xserver.balanceThrottler.bytesAlreadyUsed
DataNode.instance.dnConf.ibrInterval == DataNode.instance.xserver.balanceThrottler.numThreads
DataNode.instance.dnConf.ibrInterval == NameNode.instance.ACTIVE_STATE.lastHATransitionTime
DataNode.instance.dnConf.ibrInterval == NameNode.instance.OBSERVER_STATE.lastHATransitionTime
DataNode.instance.dnConf.ibrInterval == NameNode.instance.STANDBY_STATE.lastHATransitionTime
DataNode.instance.dnConf.ibrInterval == NameNode.instance.namesystem.dir.yieldCount
DataNode.instance.dnConf.ibrInterval == NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.dnConf.ibrInterval == NameNode.instance.namesystem.fsLock.longestReadLockHeldIntervalMs
DataNode.instance.dnConf.ibrInterval == NameNode.instance.namesystem.fsLock.numReadLockWarningsSuppressed
DataNode.instance.dnConf.ibrInterval == NameNode.instance.namesystem.fsLock.timeStampOfLastReadLockReportMs
DataNode.instance.dnConf.ibrInterval == NameNode.instance.namesystem.maxFsObjects
DataNode.instance.dnConf.ibrInterval == NameNode.instance.namesystem.minBlockSize
DataNode.instance.dnConf.ibrInterval == NameNode.instance.namesystem.numCommittedAllowed
DataNode.instance.dnConf.ibrInterval == NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.dnConf.ibrInterval == NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.dnConf.ibrInterval == NameNode.instance.state.lastHATransitionTime
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.blockIdManager.legacyGenerationStampLimit
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == DataNode.instance.dnConf.tcpNoDelay
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == DataNode.instance.dnConf.transferToAllowed
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.OBSERVER_STATE.isObserver
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.namesystem.cacheManager.enabled
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.namesystem.dir.CHECK_RESERVED_FILE_NAMES
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.namesystem.dir.aclsEnabled
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.namesystem.dir.isPermissionEnabled
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.namesystem.dir.quotaByStorageTypeEnabled
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.namesystem.dir.storagePolicyEnabled
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.namesystem.dir.xattrsEnabled
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.namesystem.fsImage.isUpgradeFinalized
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.namesystem.fsRunning
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.namesystem.hasResourcesAvailable
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.namesystem.imageLoaded
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.namesystem.isPermissionEnabled
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.namesystem.leaseManager.shouldRunMonitor
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.namesystem.snapshotManager.snapshotDiffAllowSnapRootDescendant
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.namesystem.standbyShouldCheckpoint
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.namesystem.topConf.isEnabled
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.namesystem.topMetrics.isMetricsSourceEnabled
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.rpcServer.serviceAuthEnabled
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.started
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == blockManagerInstance.checkNSRunning
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == blockManagerInstance.datanodeManager.shouldSendCachingCommands
DataNode.instance.dnConf.socketTimeout == DataNode.instance.dnConf.xceiverStopTimeout
DataNode.instance.dnConf.socketTimeout == NameNode.instance.namesystem.leaseManager.softLimit
DataNode.instance.dnConf.volsConfigured == blockManagerInstance.blocksReplWorkMultiplier
DataNode.instance.dnConf.volsConfigured == daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS == DataNode.instance.httpServer.HTTP_SELECTOR_THREADS
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS == NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.sequenceNumber
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS == NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS == NameNode.instance.namesystem.nnResourceChecker.minimumRedundantVolumes
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS == blockManagerInstance.bmSafeMode.safeReplication
DataNode.instance.httpServer.HTTP_MAX_THREADS == NameNode.instance.namesystem.dir.quotaInitThreads
DataNode.instance.httpServer.HTTP_MAX_THREADS == NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_COUNT_MAX
DataNode.instance.httpServer.HTTP_MAX_THREADS == blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS
DataNode.instance.id.infoPort == DataNode.instance.infoPort
DataNode.instance.id.nsInfo.namespaceID == DataNode.instance.storage.namespaceID
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks == DataNode.instance.volumeChecker.delegateChecker.minMsBetweenChecks
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks == DataNode.instance.volumeChecker.minDiskCheckGapMs
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout == DataNode.instance.volumeChecker.diskCheckTimeout
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout == DataNode.instance.volumeChecker.maxAllowedTimeForCheckMs
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout == blockManagerInstance.storageInfoDefragmentInterval
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod == DataNode.instance.xserver.balanceThrottler.curReserve
DataNode.instance.xserver.balanceThrottler.period == NameNode.instance.namesystem.dir.contentSleepMicroSec
DataNode.instance.xserver.balanceThrottler.period == blockManagerInstance.maxCorruptFilesReturned
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS == NameNode.instance.namesystem.dir.contentCountLimit
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS == NameNode.instance.namesystem.fsImage.LOAD_EDIT_LOG_INTERVAL_MS
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS == NameNode.instance.namesystem.fsLock.readLockReportingThresholdMs
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS == NameNode.instance.namesystem.fsLock.writeLockReportingThresholdMs
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS == NameNode.instance.namesystem.resourceRecheckInterval
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL == NameNode.instance.namesystem.dir.accessTimePrecision
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size == blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size
NameNode.instance.namesystem.blockDeletionIncrement == NameNode.instance.namesystem.dir.lsLimit
NameNode.instance.namesystem.blockDeletionIncrement == NameNode.instance.namesystem.edekCacheLoaderInterval
NameNode.instance.namesystem.blockDeletionIncrement == NameNode.instance.namesystem.maxListOpenFilesResponses
NameNode.instance.namesystem.blockDeletionIncrement == NameNode.instance.namesystem.snapshotDiffReportLimit
NameNode.instance.namesystem.blockDeletionIncrement == blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP
daikon.Quant.pairwiseEqual(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE, NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses == NameNode.instance.namesystem.cacheManager.maxListCachePoolsResponses
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses == NameNode.instance.namesystem.maxCorruptFileBlocksReturn
NameNode.instance.namesystem.cacheManager.scanIntervalMs == blockManagerInstance.datanodeManager.staleInterval
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE == NameNode.instance.namesystem.fsImage.SHUTDOWN_HOOK_PRIORITY
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE == blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval == NameNode.instance.namesystem.editLogRollerInterval
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval == blockManagerInstance.blockReportLeaseManager.leaseExpiryMs
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID == blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MAXIMUM_CAPACITY
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP == blockManagerInstance.blockIdManager.impendingGenerationStamp.LAST_RESERVED_STAMP
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP == blockManagerInstance.blockIdManager.legacyGenerationStamp.LAST_RESERVED_STAMP
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP == blockManagerInstance.datanodeManager.blockInvalidateLimit
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP == blockManagerInstance.invalidateBlocks.blockInvalidateLimit
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP == blockManagerInstance.maxNumBlocksToLog
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.blockReportLeaseManager.deferredHead.leaseId
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.blockReportLeaseManager.deferredHead.leaseTimeMs
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.blockReportLeaseManager.numPending
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.blockReportLeaseManager.pendingHead.leaseId
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.blockReportLeaseManager.pendingHead.leaseTimeMs
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.blockReportThread.lastFull
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.bmSafeMode.blockReplQueueThreshold
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.bmSafeMode.blockSafe
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.bmSafeMode.blockThreshold
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.bmSafeMode.blockTotal
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.bmSafeMode.datanodeThreshold
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.bmSafeMode.extension
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.bmSafeMode.lastStatusReport
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.bmSafeMode.reachedTime
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.corruptReplicaBlocksCount
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.datanodeManager.numStaleNodes
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.datanodeManager.numStaleStorages
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.excessRedundancyMap.size
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.heartbeatManager.stats.cacheCapacity
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.heartbeatManager.stats.cacheUsed
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.heartbeatManager.stats.expiredHeartbeats
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.invalidateBlocks.blockIdManager.legacyGenerationStampLimit
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.invalidateBlocks.pendingPeriodInMs
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.neededReconstruction.QUEUE_HIGHEST_PRIORITY
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.pendingDNMessages.count
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.pendingReconstruction.timedOutCount
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.pendingReconstructionBlocksCount
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.modification
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.size
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.providedStorageMap.capacity
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.providedStorageMap.defaultReplication
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.scheduledReplicationBlocksCount
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.startupDelayBlockDeletionInMs
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == daikon.Quant.size(DataNode.instance.directoryScanner.diffs_FOR_ENCLOSING_USE)
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs == blockManagerInstance.datanodeManager.heartbeatManager.heartbeatRecheckInterval
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs == blockManagerInstance.datanodeManager.heartbeatRecheckInterval
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs == blockManagerInstance.heartbeatManager.heartbeatRecheckInterval
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs == blockManagerInstance.pendingReconstruction.DEFAULT_RECHECK_INTERVAL
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs == blockManagerInstance.pendingReconstruction.timeout
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS == blockManagerInstance.neededReconstruction.QUEUE_WITH_CORRUPT_BLOCKS
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS == blockManagerInstance.placementPolicies.ecPolicy.tolerateHeartbeatMultiplier
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS == blockManagerInstance.placementPolicies.replicationPolicy.tolerateHeartbeatMultiplier
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS == blockManagerInstance.replicationStreamsHardLimit
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS == blockManagerInstance.storageInfoDefragmentTimeout
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS == blockManagerInstance.storagePolicySuite.ID_BIT_LENGTH
blockManagerInstance.blocksPerPostpondedRescan == blockManagerInstance.datanodeManager.blocksPerPostponedMisreplicatedBlocksRescan
blockManagerInstance.blocksPerPostpondedRescan == blockManagerInstance.numBlocksPerIteration
blockManagerInstance.blocksReplWorkMultiplier == blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.sequenceNumber
blockManagerInstance.blocksReplWorkMultiplier == blockManagerInstance.maxReplicationStreams
blockManagerInstance.blocksReplWorkMultiplier == blockManagerInstance.neededReconstruction.QUEUE_LOW_REDUNDANCY
blockManagerInstance.blocksReplWorkMultiplier == blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandMultiplier
blockManagerInstance.bmSafeMode.haEnabled == blockManagerInstance.bmSafeMode.inRollBack
blockManagerInstance.bmSafeMode.haEnabled == blockManagerInstance.datanodeManager.avoidStaleDataNodesForRead
blockManagerInstance.bmSafeMode.haEnabled == blockManagerInstance.datanodeManager.avoidStaleDataNodesForWrite
blockManagerInstance.bmSafeMode.haEnabled == blockManagerInstance.datanodeManager.dataNodeDiskStatsEnabled
blockManagerInstance.bmSafeMode.haEnabled == blockManagerInstance.datanodeManager.dataNodePeerStatsEnabled
blockManagerInstance.bmSafeMode.haEnabled == blockManagerInstance.datanodeManager.hasClusterEverBeenMultiRack
blockManagerInstance.bmSafeMode.haEnabled == blockManagerInstance.datanodeManager.heartbeatManager.enableLogStaleNodes
blockManagerInstance.bmSafeMode.haEnabled == blockManagerInstance.datanodeManager.rejectUnresolvedTopologyDN
blockManagerInstance.bmSafeMode.haEnabled == blockManagerInstance.encryptDataTransfer
blockManagerInstance.bmSafeMode.haEnabled == blockManagerInstance.hasNonEcBlockUsingStripedID
blockManagerInstance.bmSafeMode.haEnabled == blockManagerInstance.heartbeatManager.enableLogStaleNodes
blockManagerInstance.bmSafeMode.haEnabled == blockManagerInstance.providedStorageMap.providedEnabled
blockManagerInstance.bmSafeMode.haEnabled == blockManagerInstance.shouldPostponeBlocksFromFuture
daikon.Quant.fuzzy.eq(blockManagerInstance.bmSafeMode.replQueueThreshold, blockManagerInstance.bmSafeMode.threshold)
blockManagerInstance.bmSafeMode.safeReplication == blockManagerInstance.defaultReplication
blockManagerInstance.bmSafeMode.safeReplication == blockManagerInstance.neededReconstruction.QUEUE_VERY_LOW_REDUNDANCY
blockManagerInstance.checkNSRunning == blockManagerInstance.datanodeManager.checkIpHostnameInRegistration
blockManagerInstance.checkNSRunning == blockManagerInstance.datanodeManager.useDfsNetworkTopology
blockManagerInstance.checkNSRunning == blockManagerInstance.pendingReconstruction.fsRunning
blockManagerInstance.checkNSRunning == blockManagerInstance.placementPolicies.ecPolicy.considerLoad
blockManagerInstance.checkNSRunning == blockManagerInstance.placementPolicies.ecPolicy.preferLocalNode
blockManagerInstance.checkNSRunning == blockManagerInstance.placementPolicies.replicationPolicy.considerLoad
blockManagerInstance.checkNSRunning == blockManagerInstance.placementPolicies.replicationPolicy.preferLocalNode
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds == blockManagerInstance.neededReconstruction.QUEUE_REPLICAS_BADLY_DISTRIBUTED
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds == blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.shrinkThreshold
blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE == blockManagerInstance.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE
blockManagerInstance.datanodeManager.shouldSendCachingCommands == blockManagerInstance.initializedReplQueues
blockManagerInstance.datanodeManager.staleInterval == blockManagerInstance.datanodeManager.timeBetweenResendingCachingDirectivesMs
blockManagerInstance.datanodeManager.staleInterval == blockManagerInstance.placementPolicies.ecPolicy.staleInterval
blockManagerInstance.datanodeManager.staleInterval == blockManagerInstance.placementPolicies.replicationPolicy.staleInterval
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.heartbeatManager.stats.nodesInService == blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.heartbeatManager.stats.nodesInService == blockManagerInstance.heartbeatManager.stats.xceiverCount
blockManagerInstance.minReplication == blockManagerInstance.minReplicationToBeInMaintenance
daikon.Quant.fuzzy.eq(blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.DEFAULT_MAX_LOAD_FACTOR, blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.maxLoadFactor)
daikon.Quant.fuzzy.eq(blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.DEFAULT_MAX_LOAD_FACTOR, blockManagerInstance.storageInfoDefragmentRatio)
daikon.Quant.fuzzy.eq(blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.DEFAUT_MIN_LOAD_FACTOR, blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.minLoadFactor)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY == blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.capacity
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY == blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.initialCapacity
daikon.Quant.fuzzy.eq(blockManagerInstance.placementPolicies.ecPolicy.considerLoadFactor, blockManagerInstance.placementPolicies.replicationPolicy.considerLoadFactor)
blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval == blockManagerInstance.placementPolicies.replicationPolicy.heartbeatInterval
blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval == blockManagerInstance.redundancyRecheckIntervalMs
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION-1) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.volsConfigured)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.directoryScanner.diffs.serialVersionUID)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.id.nsInfo.capabilities)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.volumeChecker.numSyncDatasetChecks)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME-1) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.directoryScanner.diffs.serialVersionUID-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.directoryScanner.timeRunningMs)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.directoryScanner.timeWaitingMs)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.diskBalancer.currentResult.result)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.fileIoProvider.profilingEventHook.sampleRangeMax)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.id.exportedKeys.keyUpdateInterval)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.id.exportedKeys.tokenLifetime)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.id.infoSecurePort)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.id.nsInfo.capabilities-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.infoSecurePort)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.xmitsInProgress)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncLazyPersistService.MAXIMUM_THREADS_PER_VOLUME)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.volsConfigured-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.volumeChecker.numSyncDatasetChecks)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME-1) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncLazyPersistService.MAXIMUM_THREADS_PER_VOLUME-1) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksFailedToCache)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksFailedToUncache)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.volFailuresTolerated)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.volsConfigured) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.volsConfigured)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.initialBlockReportDelayMs)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.maxLockedMemory)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.transferSocketRecvBufferSize)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.transferSocketSendBufferSize)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.volFailuresTolerated)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_SELECTOR_THREADS-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.storage.cTime)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.storageLocationChecker.delegateChecker.diskCheckTimeout)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.volumeChecker.maxVolumeFailuresTolerated)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.volumeChecker.numAsyncDatasetChecks)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.volumeChecker.numSkippedChecks)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.volumeChecker.numVolumeChecks)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.xserver.balanceThrottler.bytesAlreadyUsed)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.xserver.balanceThrottler.numThreads)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.ACTIVE_STATE.lastHATransitionTime)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.OBSERVER_STATE.lastHATransitionTime)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.STANDBY_STATE.lastHATransitionTime)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.sequenceNumber-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.cacheManager.nextDirectiveId-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.dir.yieldCount)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.fsImage.lastAppliedTxId)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.fsLock.longestReadLockHeldIntervalMs)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.fsLock.numReadLockWarningsSuppressed)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.fsLock.timeStampOfLastReadLockReportMs)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.maxFsObjects)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.minBlockSize)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.nnResourceChecker.minimumRedundantVolumes-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.numCommittedAllowed)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.snapshotManager.numSnapshots)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.snapshotManager.snapshotCounter)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.state.lastHATransitionTime)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.volsConfigured-1) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_SELECTOR_THREADS)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.sequenceNumber)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.cacheManager.nextDirectiveId)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.nnResourceChecker.minimumRedundantVolumes)
daikon.Quant.fuzzy.eq(DataNode.instance.CONGESTION_RATIO, 1.5)
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT == -1
DataNode.instance.NUM_CORES == 32
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs == 30000
DataNode.instance.cacheReportsDisabledForTests == false
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION == 3
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == 1
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == 4
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS == 64
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS == 60
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 0
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME == 1
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS == 60
DataNode.instance.data.blockPinningEnabled == false
DataNode.instance.data.cacheManager.numBlocksCached == 0
DataNode.instance.data.cacheManager.revocationMs == 900000
DataNode.instance.data.cacheManager.revocationPollingMs == 500
DataNode.instance.data.fsRunning == true
DataNode.instance.data.maxDataLength == 67108864
DataNode.instance.data.smallBufferSize == 512
DataNode.instance.data.volsConfigured == 2
DataNode.instance.directoryScanner.MILLIS_PER_SECOND == 1000
DataNode.instance.directoryScanner.diffs_FOR_ENCLOSING_USE != null
daikon.Quant.pairwiseEqual(DataNode.instance.directoryScanner.diffs_FOR_ENCLOSING_USE, new String[] {  })
DataNode.instance.directoryScanner.scanPeriodMsecs == 21600000
DataNode.instance.directoryScanner.shouldRun == true
DataNode.instance.diskBalancer.bandwidth == 10
DataNode.instance.diskBalancer.planValidityInterval == 86400000
DataNode.instance.dnConf.allowNonLocalLazyPersist == false
DataNode.instance.dnConf.blockReportInterval == 21600000
DataNode.instance.dnConf.blockReportSplitThreshold == 1000000
DataNode.instance.dnConf.bpReadyTimeout == 20
DataNode.instance.dnConf.cacheReportInterval == 10000
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs == 300
DataNode.instance.dnConf.heartBeatInterval == 3000
DataNode.instance.dnConf.ibrInterval == 0
DataNode.instance.dnConf.lifelineIntervalMs == 9000
DataNode.instance.dnConf.maxDataLength == 67108864
DataNode.instance.dnConf.outliersReportIntervalMs == 1800000
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == true
DataNode.instance.dnConf.readaheadLength == 4194304
DataNode.instance.dnConf.restartReplicaExpiry == 50000
DataNode.instance.dnConf.socketKeepaliveTimeout == 4000
DataNode.instance.dnConf.socketTimeout == 60000
DataNode.instance.dnConf.socketWriteTimeout == 480000
DataNode.instance.dnConf.volsConfigured == 2
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS == 1
DataNode.instance.httpServer.HTTP_MAX_THREADS == 4
DataNode.instance.id.infoPort == 37785
DataNode.instance.id.ipcPort == 43731
DataNode.instance.id.nsInfo.cTime == 1731381653952L
DataNode.instance.id.nsInfo.layoutVersion == -65
DataNode.instance.id.nsInfo.namespaceID == 1620332546
DataNode.instance.id.xferPort == 41255
DataNode.instance.lastDiskErrorCheck == 117762496
DataNode.instance.shortCircuitRegistry.SHM_LENGTH == 8192
DataNode.instance.storage.layoutVersion == -57
DataNode.instance.storage.namespaceID == 1620332546
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks == 900000
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout == 600000
DataNode.instance.volumeChecker.lastAllVolumesCheck == 116861143 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 117762491
DataNode.instance.volumeChecker.numSyncDatasetChecks == 0 || DataNode.instance.volumeChecker.numSyncDatasetChecks == 1
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod == 5242880
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 117761156
DataNode.instance.xserver.balanceThrottler.maxThreads == 50
DataNode.instance.xserver.balanceThrottler.period == 500
DataNode.instance.xserver.balanceThrottler.periodExtension == 1500
DataNode.instance.xserver.estimateBlockSize == 134217728
DataNode.instance.xserver.maxXceiverCount == 4096
NameNode.instance.DEFAULT_PORT == 8020
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS == 5000
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL == 3600000
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 14
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size == -9223372036854775808L
NameNode.instance.namesystem.blockDeletionIncrement == 1000
daikon.Quant.fuzzy.eq(NameNode.instance.namesystem.cacheManager.MIN_CACHED_BLOCKS_PERCENT, 0.001)
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses == 100
NameNode.instance.namesystem.cacheManager.scanIntervalMs == 30000
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE == 10
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval == 300000
NameNode.instance.namesystem.dir.inodeXAttrsLimit == 32
NameNode.instance.namesystem.dir.maxComponentLength == 255
NameNode.instance.namesystem.dir.maxDirItems == 1048576
NameNode.instance.namesystem.dir.xattrMaxSize == 16384
NameNode.instance.namesystem.editLogRollerThreshold == 500000
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 117761078
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN == 512
NameNode.instance.namesystem.leaseManager.hardLimit == 1200000
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 117760335
daikon.Quant.eltsNotEqual(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE, null)
NameNode.instance.namesystem.leaseRecheckIntervalMs == 2000
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs == 25
NameNode.instance.namesystem.nnResourceChecker.duReserved == 104857600
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH == 24
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit == 65536
NameNode.instance.namesystem.startTime == 1731381655427L
daikon.Quant.eltsNotEqual(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, null)
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER == 30
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID == 1073741824
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP == 1000
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs == 300000
blockManagerInstance.blockReportLeaseManager.maxPending == 6
blockManagerInstance.blockReportLeaseManager.nextId == 1579508632195327125L || blockManagerInstance.blockReportLeaseManager.nextId == 1579508632195327126L
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS == 4
daikon.Quant.fuzzy.eq(blockManagerInstance.blocksInvalidateWorkPct, 0.32)
blockManagerInstance.blocksMap.capacity == 33554432
blockManagerInstance.blocksPerPostpondedRescan == 10000
blockManagerInstance.blocksReplWorkMultiplier == 2
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 10 || blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 14
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size == -9223372036854775808L
blockManagerInstance.bmSafeMode.haEnabled == false
daikon.Quant.fuzzy.eq(blockManagerInstance.bmSafeMode.replQueueThreshold, 0.9990000128746033)
blockManagerInstance.bmSafeMode.safeReplication == 1
blockManagerInstance.bmSafeMode.startTime == 0 || blockManagerInstance.bmSafeMode.startTime == 117761039
blockManagerInstance.checkNSRunning == true
blockManagerInstance.datanodeManager.defaultInfoPort == 9864
blockManagerInstance.datanodeManager.defaultInfoSecurePort == 9865
blockManagerInstance.datanodeManager.defaultIpcPort == 9867
blockManagerInstance.datanodeManager.defaultXferPort == 9866
blockManagerInstance.datanodeManager.heartbeatExpireInterval == 630000
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds == 3
blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE == 10
daikon.Quant.fuzzy.eq(blockManagerInstance.datanodeManager.ratioUseStaleDataNodesForWrite, 0.5)
blockManagerInstance.datanodeManager.staleInterval == 30000
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 0 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 49152
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 0 || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 96515973120L
blockManagerInstance.heartbeatManager.stats.capacityTotal == 0 || blockManagerInstance.heartbeatManager.stats.capacityTotal == 134100180992L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 0 || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 30712217600L
blockManagerInstance.heartbeatManager.stats.nodesInService == 0 || blockManagerInstance.heartbeatManager.stats.nodesInService == 1
blockManagerInstance.invalidateBlocks.startupTime == 117760337
blockManagerInstance.lastRedundancyCycleTS == -1 || blockManagerInstance.lastRedundancyCycleTS == 117764038 || blockManagerInstance.lastRedundancyCycleTS == 117767039
blockManagerInstance.lastRedundancyCycleTS != 0
blockManagerInstance.maxCorruptFilesReturned == 500
blockManagerInstance.maxReplication == 512
blockManagerInstance.minReplication == 1
blockManagerInstance.neededReconstruction.LEVEL == 5
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval == 90000
daikon.Quant.fuzzy.eq(blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.DEFAULT_MAX_LOAD_FACTOR, 0.75)
daikon.Quant.fuzzy.eq(blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.DEFAUT_MIN_LOAD_FACTOR, 0.2)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY == 16
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold == 12
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask == 15
daikon.Quant.fuzzy.eq(blockManagerInstance.placementPolicies.ecPolicy.considerLoadFactor, 2.0)
blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval == 3000
daikon.Quant.fuzzy.eq(blockManagerInstance.reconstructionQueuesInitProgress, 0.0) || daikon.Quant.fuzzy.eq(blockManagerInstance.reconstructionQueuesInitProgress, Double.NaN)
blockManagerInstance.replQueueCallsSinceReset == 0 || blockManagerInstance.replQueueCallsSinceReset == 1 || blockManagerInstance.replQueueCallsSinceReset == 2
blockManagerInstance.replQueueResetToHeadThreshold == 2400
blockManagerInstance.storageInfoDefragmentInterval == 600000
blockManagerInstance.storagePolicySuite.defaultPolicyID == 7
daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) == 0 || daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) == 1
daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE) == 0 || daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE) == 3
daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1 != 0
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) != null
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) != null
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME) != null
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) != null
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.volsConfigured) != null
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) != null
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.volsConfigured) != null
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS) != null
daikon.Quant.fuzzy.ne(DataNode.instance.CONGESTION_RATIO, blockManagerInstance.reconstructionQueuesInitProgress)
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT <= blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT <= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
DataNode.instance.NUM_CORES < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.NUM_CORES > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.NUM_CORES < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.NUM_CORES < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.NUM_CORES > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.NUM_CORES < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.NUM_CORES < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.NUM_CORES < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.NUM_CORES < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.NUM_CORES < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.NUM_CORES > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.NUM_CORES != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.NUM_CORES > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.NUM_CORES > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.NUM_CORES > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.asyncDiskService.numDeletedBlocks != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.asyncDiskService.numDeletedBlocks <= blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.asyncDiskService.numDeletedBlocks <= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.numDeletedBlocks >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
DataNode.instance.data.asyncDiskService.numDeletedBlocks < daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME >= blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME < daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.data.cacheManager.numBlocksCached < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.data.cacheManager.numBlocksCached < DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.data.cacheManager.numBlocksCached < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.data.cacheManager.numBlocksCached < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.cacheManager.numBlocksCached < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.cacheManager.numBlocksCached < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.cacheManager.numBlocksCached <= blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.cacheManager.numBlocksCached <= blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.cacheManager.numBlocksCached <= blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.cacheManager.numBlocksCached <= blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.cacheManager.numBlocksCached <= blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.cacheManager.numBlocksCached != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.cacheManager.numBlocksCached <= blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.cacheManager.numBlocksCached <= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.cacheManager.numBlocksCached >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
DataNode.instance.data.cacheManager.numBlocksCached < daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
DataNode.instance.data.cacheManager.revocationMs < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.data.cacheManager.revocationMs > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.data.cacheManager.revocationMs < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.data.cacheManager.revocationMs < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.cacheManager.revocationMs > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.cacheManager.revocationMs < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.cacheManager.revocationMs > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.cacheManager.revocationMs != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.cacheManager.revocationMs != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.cacheManager.revocationMs != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.cacheManager.revocationMs > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.cacheManager.revocationMs != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.cacheManager.revocationMs > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.cacheManager.revocationMs > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.cacheManager.revocationMs > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.data.cacheManager.revocationPollingMs < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.data.cacheManager.revocationPollingMs > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.data.cacheManager.revocationPollingMs < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.data.cacheManager.revocationPollingMs < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.cacheManager.revocationPollingMs > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.cacheManager.revocationPollingMs < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.cacheManager.revocationPollingMs != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.cacheManager.revocationPollingMs != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.cacheManager.revocationPollingMs != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.cacheManager.revocationPollingMs != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.cacheManager.revocationPollingMs > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.cacheManager.revocationPollingMs != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.cacheManager.revocationPollingMs > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.cacheManager.revocationPollingMs > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.cacheManager.revocationPollingMs > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.data.maxDataLength < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.data.maxDataLength > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.data.maxDataLength < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.data.maxDataLength < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.maxDataLength > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.maxDataLength < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.maxDataLength > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.maxDataLength != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.maxDataLength != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.maxDataLength != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.maxDataLength > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.maxDataLength != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.maxDataLength > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.maxDataLength > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.maxDataLength > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.data.smallBufferSize < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.data.smallBufferSize > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.data.smallBufferSize < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.data.smallBufferSize < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.smallBufferSize > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.smallBufferSize < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.smallBufferSize != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.smallBufferSize != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.smallBufferSize != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.smallBufferSize != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.smallBufferSize > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.smallBufferSize != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.smallBufferSize > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.smallBufferSize > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.smallBufferSize > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.data.volsConfigured < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.data.volsConfigured > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.data.volsConfigured < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.data.volsConfigured < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.volsConfigured < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.volsConfigured < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.volsConfigured != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.volsConfigured != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.volsConfigured != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.volsConfigured != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.volsConfigured > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.volsConfigured != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.volsConfigured >= blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.volsConfigured > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.directoryScanner.MILLIS_PER_SECOND < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.directoryScanner.MILLIS_PER_SECOND > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.directoryScanner.MILLIS_PER_SECOND < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.directoryScanner.MILLIS_PER_SECOND < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.directoryScanner.MILLIS_PER_SECOND > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.directoryScanner.MILLIS_PER_SECOND < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.directoryScanner.MILLIS_PER_SECOND < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.directoryScanner.MILLIS_PER_SECOND < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.directoryScanner.MILLIS_PER_SECOND < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.directoryScanner.MILLIS_PER_SECOND < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.directoryScanner.MILLIS_PER_SECOND > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.directoryScanner.MILLIS_PER_SECOND != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.directoryScanner.MILLIS_PER_SECOND > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.directoryScanner.MILLIS_PER_SECOND > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.directoryScanner.MILLIS_PER_SECOND > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.directoryScanner.scanPeriodMsecs < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.directoryScanner.scanPeriodMsecs > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.directoryScanner.scanPeriodMsecs < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.directoryScanner.scanPeriodMsecs < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.directoryScanner.scanPeriodMsecs > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.directoryScanner.scanPeriodMsecs < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.directoryScanner.scanPeriodMsecs > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.directoryScanner.scanPeriodMsecs < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.directoryScanner.scanPeriodMsecs < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.directoryScanner.scanPeriodMsecs < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.directoryScanner.scanPeriodMsecs > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.directoryScanner.scanPeriodMsecs != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.directoryScanner.scanPeriodMsecs > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.directoryScanner.scanPeriodMsecs > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.directoryScanner.scanPeriodMsecs > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.diskBalancer.bandwidth < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.diskBalancer.bandwidth > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.diskBalancer.bandwidth < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.diskBalancer.bandwidth < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.diskBalancer.bandwidth < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.diskBalancer.bandwidth < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.diskBalancer.bandwidth < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.diskBalancer.bandwidth < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.diskBalancer.bandwidth < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.diskBalancer.bandwidth < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.diskBalancer.bandwidth > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.diskBalancer.bandwidth != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.diskBalancer.bandwidth > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.diskBalancer.bandwidth > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.diskBalancer.bandwidth > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.diskBalancer.planValidityInterval < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.diskBalancer.planValidityInterval > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.diskBalancer.planValidityInterval < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.diskBalancer.planValidityInterval < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.diskBalancer.planValidityInterval > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.diskBalancer.planValidityInterval < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.diskBalancer.planValidityInterval > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.diskBalancer.planValidityInterval < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.diskBalancer.planValidityInterval < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.diskBalancer.planValidityInterval < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.diskBalancer.planValidityInterval > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.diskBalancer.planValidityInterval != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.diskBalancer.planValidityInterval > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.diskBalancer.planValidityInterval > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.diskBalancer.planValidityInterval > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.blockReportInterval < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.dnConf.blockReportInterval > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.dnConf.blockReportInterval < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.dnConf.blockReportInterval < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.blockReportInterval > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.blockReportInterval < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.blockReportInterval > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.blockReportInterval != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.blockReportInterval != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.dnConf.blockReportInterval != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.blockReportInterval > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.dnConf.blockReportInterval != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.blockReportInterval > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.dnConf.blockReportInterval > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.blockReportInterval > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.blockReportSplitThreshold < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.dnConf.blockReportSplitThreshold > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.dnConf.blockReportSplitThreshold < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.dnConf.blockReportSplitThreshold < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.blockReportSplitThreshold > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.blockReportSplitThreshold < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.blockReportSplitThreshold > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.blockReportSplitThreshold != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.blockReportSplitThreshold != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.dnConf.blockReportSplitThreshold != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.blockReportSplitThreshold > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.dnConf.blockReportSplitThreshold != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.blockReportSplitThreshold > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.dnConf.blockReportSplitThreshold > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.blockReportSplitThreshold > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.bpReadyTimeout < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.dnConf.bpReadyTimeout > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.dnConf.bpReadyTimeout < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.dnConf.bpReadyTimeout < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.bpReadyTimeout > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.bpReadyTimeout < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.bpReadyTimeout != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.bpReadyTimeout != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.bpReadyTimeout != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.dnConf.bpReadyTimeout != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.bpReadyTimeout > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.dnConf.bpReadyTimeout != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.bpReadyTimeout > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.dnConf.bpReadyTimeout > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.bpReadyTimeout > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.cacheReportInterval < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.dnConf.cacheReportInterval > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.dnConf.cacheReportInterval < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.dnConf.cacheReportInterval < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.cacheReportInterval > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.cacheReportInterval < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.cacheReportInterval != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.cacheReportInterval != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.cacheReportInterval != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.dnConf.cacheReportInterval != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.cacheReportInterval > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.dnConf.cacheReportInterval != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.cacheReportInterval > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.dnConf.cacheReportInterval > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.cacheReportInterval > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.heartBeatInterval < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.dnConf.heartBeatInterval > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.dnConf.heartBeatInterval < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.dnConf.heartBeatInterval < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.heartBeatInterval > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.heartBeatInterval < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.heartBeatInterval != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.heartBeatInterval != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.heartBeatInterval != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.dnConf.heartBeatInterval != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.heartBeatInterval > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.dnConf.heartBeatInterval != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.heartBeatInterval > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.dnConf.heartBeatInterval > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.heartBeatInterval > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.ibrInterval < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.dnConf.ibrInterval <= DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.dnConf.ibrInterval < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.dnConf.ibrInterval < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.ibrInterval < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.ibrInterval < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.ibrInterval <= blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.ibrInterval <= blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.ibrInterval <= blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.dnConf.ibrInterval <= blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.ibrInterval <= blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.dnConf.ibrInterval != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.ibrInterval <= blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.dnConf.ibrInterval <= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.ibrInterval >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
DataNode.instance.dnConf.ibrInterval < daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
DataNode.instance.dnConf.lifelineIntervalMs < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.dnConf.lifelineIntervalMs > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.dnConf.lifelineIntervalMs < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.dnConf.lifelineIntervalMs < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.lifelineIntervalMs > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.lifelineIntervalMs < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.lifelineIntervalMs != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.lifelineIntervalMs != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.lifelineIntervalMs != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.dnConf.lifelineIntervalMs != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.lifelineIntervalMs > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.dnConf.lifelineIntervalMs != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.lifelineIntervalMs > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.dnConf.lifelineIntervalMs > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.lifelineIntervalMs > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.maxDataLength < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.dnConf.maxDataLength > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.dnConf.maxDataLength < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.dnConf.maxDataLength < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.maxDataLength > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.maxDataLength < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.maxDataLength > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.maxDataLength != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.maxDataLength != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.dnConf.maxDataLength != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.maxDataLength > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.dnConf.maxDataLength != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.maxDataLength > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.dnConf.maxDataLength > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.maxDataLength > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.outliersReportIntervalMs < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.dnConf.outliersReportIntervalMs > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.dnConf.outliersReportIntervalMs < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.dnConf.outliersReportIntervalMs < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.outliersReportIntervalMs > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.outliersReportIntervalMs < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.outliersReportIntervalMs > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.outliersReportIntervalMs != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.outliersReportIntervalMs != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.dnConf.outliersReportIntervalMs != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.outliersReportIntervalMs > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.dnConf.outliersReportIntervalMs != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.outliersReportIntervalMs > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.dnConf.outliersReportIntervalMs > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.outliersReportIntervalMs > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.readaheadLength < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.dnConf.readaheadLength > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.dnConf.readaheadLength < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.dnConf.readaheadLength < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.readaheadLength > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.readaheadLength < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.readaheadLength > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.readaheadLength != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.readaheadLength != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.dnConf.readaheadLength != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.readaheadLength > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.dnConf.readaheadLength != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.readaheadLength > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.dnConf.readaheadLength > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.readaheadLength > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.restartReplicaExpiry < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.dnConf.restartReplicaExpiry > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.dnConf.restartReplicaExpiry < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.dnConf.restartReplicaExpiry < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.restartReplicaExpiry > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.restartReplicaExpiry < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.restartReplicaExpiry > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.restartReplicaExpiry != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.restartReplicaExpiry != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.dnConf.restartReplicaExpiry != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.restartReplicaExpiry > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.dnConf.restartReplicaExpiry != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.restartReplicaExpiry > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.dnConf.restartReplicaExpiry > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.restartReplicaExpiry > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.socketKeepaliveTimeout < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.dnConf.socketKeepaliveTimeout > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.dnConf.socketKeepaliveTimeout < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.dnConf.socketKeepaliveTimeout < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.socketKeepaliveTimeout > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.socketKeepaliveTimeout < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.socketKeepaliveTimeout != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.socketKeepaliveTimeout != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.socketKeepaliveTimeout != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.dnConf.socketKeepaliveTimeout != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.socketKeepaliveTimeout > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.dnConf.socketKeepaliveTimeout != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.socketKeepaliveTimeout > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.dnConf.socketKeepaliveTimeout > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.socketKeepaliveTimeout > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.socketTimeout < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.dnConf.socketTimeout > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.dnConf.socketTimeout < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.dnConf.socketTimeout < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.socketTimeout > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.socketTimeout < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.socketTimeout > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.socketTimeout != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.socketTimeout != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.dnConf.socketTimeout != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.socketTimeout > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.dnConf.socketTimeout != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.socketTimeout > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.dnConf.socketTimeout > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.socketTimeout > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.socketWriteTimeout < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.dnConf.socketWriteTimeout > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.dnConf.socketWriteTimeout < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.dnConf.socketWriteTimeout < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.socketWriteTimeout > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.socketWriteTimeout < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.socketWriteTimeout > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.socketWriteTimeout != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.socketWriteTimeout != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.dnConf.socketWriteTimeout != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.socketWriteTimeout > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.dnConf.socketWriteTimeout != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.socketWriteTimeout > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.dnConf.socketWriteTimeout > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.socketWriteTimeout > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.volsConfigured < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.dnConf.volsConfigured > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.dnConf.volsConfigured < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.dnConf.volsConfigured < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.volsConfigured < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.volsConfigured < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.volsConfigured != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.volsConfigured != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.volsConfigured != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.dnConf.volsConfigured != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.volsConfigured > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.dnConf.volsConfigured != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.volsConfigured >= blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.dnConf.volsConfigured > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS >= DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS >= blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS < daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
DataNode.instance.httpServer.HTTP_MAX_THREADS < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.httpServer.HTTP_MAX_THREADS > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.httpServer.HTTP_MAX_THREADS < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.httpServer.HTTP_MAX_THREADS < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.httpServer.HTTP_MAX_THREADS < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.httpServer.HTTP_MAX_THREADS < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.httpServer.HTTP_MAX_THREADS != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.httpServer.HTTP_MAX_THREADS != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.httpServer.HTTP_MAX_THREADS != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.httpServer.HTTP_MAX_THREADS != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.httpServer.HTTP_MAX_THREADS > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.httpServer.HTTP_MAX_THREADS != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.httpServer.HTTP_MAX_THREADS > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.httpServer.HTTP_MAX_THREADS > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.httpServer.HTTP_MAX_THREADS > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.id.infoPort < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.id.infoPort > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.id.infoPort < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.id.infoPort < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.id.infoPort > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.id.infoPort < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.id.infoPort < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.id.infoPort < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.id.infoPort < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.id.infoPort < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.id.infoPort > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.id.infoPort != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.id.infoPort > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.id.infoPort > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.id.infoPort > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.id.ipcPort < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.id.ipcPort > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.id.ipcPort < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.id.ipcPort < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.id.ipcPort > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.id.ipcPort < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.id.ipcPort < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.id.ipcPort < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.id.ipcPort < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.id.ipcPort < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.id.ipcPort > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.id.ipcPort != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.id.ipcPort > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.id.ipcPort > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.id.ipcPort > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.id.nsInfo.cTime > DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.id.nsInfo.cTime > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.id.nsInfo.cTime < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.id.nsInfo.cTime < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.bmSafeMode.startTime
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.id.nsInfo.cTime > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.id.nsInfo.cTime > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.id.nsInfo.layoutVersion < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.id.nsInfo.layoutVersion < DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.id.nsInfo.layoutVersion < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.id.nsInfo.layoutVersion < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.id.nsInfo.layoutVersion < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.id.nsInfo.layoutVersion < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.id.nsInfo.layoutVersion < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.id.nsInfo.layoutVersion < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.id.nsInfo.layoutVersion < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.id.nsInfo.layoutVersion < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.id.nsInfo.layoutVersion < blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.id.nsInfo.layoutVersion < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.id.nsInfo.layoutVersion < blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.id.nsInfo.layoutVersion < daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
DataNode.instance.id.nsInfo.layoutVersion < daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
DataNode.instance.id.nsInfo.namespaceID > DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.id.nsInfo.namespaceID > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.id.nsInfo.namespaceID < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.id.nsInfo.namespaceID < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.bmSafeMode.startTime
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.id.nsInfo.namespaceID < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.id.nsInfo.namespaceID < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.id.nsInfo.namespaceID < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.id.nsInfo.namespaceID > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.id.nsInfo.namespaceID > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.id.xferPort < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.id.xferPort > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.id.xferPort < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.id.xferPort < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.id.xferPort > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.id.xferPort < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.id.xferPort < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.id.xferPort < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.id.xferPort < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.id.xferPort < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.id.xferPort > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.id.xferPort != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.id.xferPort > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.id.xferPort > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.id.xferPort > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.lastDiskErrorCheck > DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.lastDiskErrorCheck > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.lastDiskErrorCheck < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.lastDiskErrorCheck < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.lastDiskErrorCheck > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.lastDiskErrorCheck > blockManagerInstance.bmSafeMode.startTime
DataNode.instance.lastDiskErrorCheck > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.lastDiskErrorCheck < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.lastDiskErrorCheck < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.lastDiskErrorCheck < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.lastDiskErrorCheck > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.lastDiskErrorCheck != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.lastDiskErrorCheck > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.lastDiskErrorCheck > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.lastDiskErrorCheck > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.shortCircuitRegistry.SHM_LENGTH < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.shortCircuitRegistry.SHM_LENGTH > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.shortCircuitRegistry.SHM_LENGTH < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.shortCircuitRegistry.SHM_LENGTH < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.shortCircuitRegistry.SHM_LENGTH > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.shortCircuitRegistry.SHM_LENGTH < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.shortCircuitRegistry.SHM_LENGTH < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.shortCircuitRegistry.SHM_LENGTH < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.shortCircuitRegistry.SHM_LENGTH < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.shortCircuitRegistry.SHM_LENGTH < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.shortCircuitRegistry.SHM_LENGTH > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.shortCircuitRegistry.SHM_LENGTH != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.shortCircuitRegistry.SHM_LENGTH > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.shortCircuitRegistry.SHM_LENGTH > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.shortCircuitRegistry.SHM_LENGTH > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.storage.layoutVersion < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.storage.layoutVersion < DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.storage.layoutVersion < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.storage.layoutVersion < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.storage.layoutVersion < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.storage.layoutVersion < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.storage.layoutVersion < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.storage.layoutVersion < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.storage.layoutVersion < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.storage.layoutVersion < blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.storage.layoutVersion < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.storage.layoutVersion < blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.storage.layoutVersion < daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
DataNode.instance.storage.layoutVersion < daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
DataNode.instance.storage.namespaceID > DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.storage.namespaceID > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.storage.namespaceID < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.storage.namespaceID < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.storage.namespaceID > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.storage.namespaceID > blockManagerInstance.bmSafeMode.startTime
DataNode.instance.storage.namespaceID > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.storage.namespaceID != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.storage.namespaceID != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.storage.namespaceID != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.storage.namespaceID > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.storage.namespaceID > blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.storage.namespaceID > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.storage.namespaceID > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.storage.namespaceID > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.volumeChecker.lastAllVolumesCheck > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.volumeChecker.lastAllVolumesCheck > DataNode.instance.xserver.balanceThrottler.bytesPerPeriod
DataNode.instance.volumeChecker.lastAllVolumesCheck != DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.volumeChecker.lastAllVolumesCheck > DataNode.instance.xserver.balanceThrottler.maxThreads
DataNode.instance.volumeChecker.lastAllVolumesCheck > DataNode.instance.xserver.balanceThrottler.period
DataNode.instance.volumeChecker.lastAllVolumesCheck > DataNode.instance.xserver.balanceThrottler.periodExtension
DataNode.instance.volumeChecker.lastAllVolumesCheck < DataNode.instance.xserver.estimateBlockSize
DataNode.instance.volumeChecker.lastAllVolumesCheck > DataNode.instance.xserver.maxXceiverCount
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.DEFAULT_PORT
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.blockDeletionIncrement
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.cacheManager.scanIntervalMs
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.dir.inodeXAttrsLimit
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.dir.maxComponentLength
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.dir.maxDirItems
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.dir.xattrMaxSize
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.editLogRollerThreshold
DataNode.instance.volumeChecker.lastAllVolumesCheck < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.volumeChecker.lastAllVolumesCheck != NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.leaseManager.hardLimit
DataNode.instance.volumeChecker.lastAllVolumesCheck != NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.leaseRecheckIntervalMs
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.nnResourceChecker.duReserved
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit
DataNode.instance.volumeChecker.lastAllVolumesCheck < NameNode.instance.namesystem.startTime
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
DataNode.instance.volumeChecker.lastAllVolumesCheck < blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.blockIdManager.legacyGenerationStampLimit
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.blockReportLeaseManager.leaseExpiryMs
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.blockReportLeaseManager.maxPending
DataNode.instance.volumeChecker.lastAllVolumesCheck < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.blocksMap.capacity
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.blocksPerPostpondedRescan
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.blocksReplWorkMultiplier
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.bmSafeMode.safeReplication
DataNode.instance.volumeChecker.lastAllVolumesCheck != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.datanodeManager.defaultInfoPort
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.datanodeManager.defaultInfoSecurePort
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.datanodeManager.defaultIpcPort
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.datanodeManager.defaultXferPort
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.datanodeManager.heartbeatExpireInterval
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.datanodeManager.staleInterval
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.volumeChecker.lastAllVolumesCheck != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.volumeChecker.lastAllVolumesCheck != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.volumeChecker.lastAllVolumesCheck != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.volumeChecker.lastAllVolumesCheck != blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.volumeChecker.lastAllVolumesCheck != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.maxCorruptFilesReturned
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.neededReconstruction.LEVEL
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.replQueueResetToHeadThreshold
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.storageInfoDefragmentInterval
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.storagePolicySuite.defaultPolicyID
DataNode.instance.volumeChecker.lastAllVolumesCheck > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.volumeChecker.lastAllVolumesCheck > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.volumeChecker.numSyncDatasetChecks < DataNode.instance.xserver.balanceThrottler.bytesPerPeriod
DataNode.instance.volumeChecker.numSyncDatasetChecks < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.volumeChecker.numSyncDatasetChecks < DataNode.instance.xserver.balanceThrottler.maxThreads
DataNode.instance.volumeChecker.numSyncDatasetChecks < DataNode.instance.xserver.balanceThrottler.period
DataNode.instance.volumeChecker.numSyncDatasetChecks < DataNode.instance.xserver.balanceThrottler.periodExtension
DataNode.instance.volumeChecker.numSyncDatasetChecks < DataNode.instance.xserver.estimateBlockSize
DataNode.instance.volumeChecker.numSyncDatasetChecks < DataNode.instance.xserver.maxXceiverCount
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.DEFAULT_PORT
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.volumeChecker.numSyncDatasetChecks > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.blockDeletionIncrement
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.cacheManager.scanIntervalMs
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.dir.inodeXAttrsLimit
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.dir.maxComponentLength
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.dir.maxDirItems
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.dir.xattrMaxSize
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.editLogRollerThreshold
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.leaseManager.hardLimit
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.leaseRecheckIntervalMs
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.nnResourceChecker.duReserved
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.startTime
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP
DataNode.instance.volumeChecker.numSyncDatasetChecks >= blockManagerInstance.blockIdManager.legacyGenerationStampLimit
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.blockReportLeaseManager.leaseExpiryMs
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.blockReportLeaseManager.maxPending
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.blocksMap.capacity
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.blocksPerPostpondedRescan
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.blocksReplWorkMultiplier
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.volumeChecker.numSyncDatasetChecks > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size
DataNode.instance.volumeChecker.numSyncDatasetChecks <= blockManagerInstance.bmSafeMode.safeReplication
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.datanodeManager.defaultInfoPort
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.datanodeManager.defaultInfoSecurePort
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.datanodeManager.defaultIpcPort
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.datanodeManager.defaultXferPort
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.datanodeManager.heartbeatExpireInterval
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.datanodeManager.staleInterval
DataNode.instance.volumeChecker.numSyncDatasetChecks >= blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.volumeChecker.numSyncDatasetChecks != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.maxCorruptFilesReturned
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.neededReconstruction.LEVEL
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.replQueueResetToHeadThreshold
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.storageInfoDefragmentInterval
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.storagePolicySuite.defaultPolicyID
DataNode.instance.volumeChecker.numSyncDatasetChecks >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.volumeChecker.numSyncDatasetChecks < daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.curPeriodStart < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.xserver.balanceThrottler.curPeriodStart < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.bmSafeMode.startTime
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.xserver.balanceThrottler.curPeriodStart != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.xserver.balanceThrottler.curPeriodStart != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.xserver.balanceThrottler.curPeriodStart != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.xserver.balanceThrottler.curPeriodStart != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.xserver.balanceThrottler.curPeriodStart > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.curPeriodStart > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.maxThreads < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.xserver.balanceThrottler.maxThreads < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.balanceThrottler.maxThreads > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.xserver.balanceThrottler.maxThreads < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.xserver.balanceThrottler.maxThreads != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.xserver.balanceThrottler.maxThreads != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.xserver.balanceThrottler.maxThreads != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.xserver.balanceThrottler.maxThreads != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.xserver.balanceThrottler.maxThreads > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.xserver.balanceThrottler.maxThreads != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.xserver.balanceThrottler.maxThreads > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.xserver.balanceThrottler.maxThreads > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.maxThreads > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.period < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.xserver.balanceThrottler.period < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.balanceThrottler.period > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.xserver.balanceThrottler.period < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.xserver.balanceThrottler.period != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.xserver.balanceThrottler.period != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.xserver.balanceThrottler.period != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.xserver.balanceThrottler.period != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.xserver.balanceThrottler.period > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.xserver.balanceThrottler.period != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.xserver.balanceThrottler.period > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.xserver.balanceThrottler.period > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.period > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.periodExtension < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.xserver.balanceThrottler.periodExtension < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.balanceThrottler.periodExtension > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.xserver.balanceThrottler.periodExtension < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.xserver.balanceThrottler.periodExtension != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.xserver.balanceThrottler.periodExtension != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.xserver.balanceThrottler.periodExtension != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.xserver.balanceThrottler.periodExtension != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.xserver.balanceThrottler.periodExtension > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.xserver.balanceThrottler.periodExtension != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.xserver.balanceThrottler.periodExtension > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.xserver.balanceThrottler.periodExtension > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.periodExtension > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.xserver.estimateBlockSize < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.xserver.estimateBlockSize < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.estimateBlockSize > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.xserver.estimateBlockSize > blockManagerInstance.bmSafeMode.startTime
DataNode.instance.xserver.estimateBlockSize > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.xserver.estimateBlockSize != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.xserver.estimateBlockSize != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.xserver.estimateBlockSize != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.xserver.estimateBlockSize > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.xserver.estimateBlockSize > blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.xserver.estimateBlockSize > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.xserver.estimateBlockSize > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.xserver.estimateBlockSize > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.xserver.maxXceiverCount < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.xserver.maxXceiverCount < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.maxXceiverCount > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.xserver.maxXceiverCount < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.xserver.maxXceiverCount != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.xserver.maxXceiverCount != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.xserver.maxXceiverCount != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.xserver.maxXceiverCount != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.xserver.maxXceiverCount > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.xserver.maxXceiverCount != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.xserver.maxXceiverCount > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.xserver.maxXceiverCount > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.xserver.maxXceiverCount > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.DEFAULT_PORT < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.DEFAULT_PORT < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.DEFAULT_PORT > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.DEFAULT_PORT < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.DEFAULT_PORT != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.DEFAULT_PORT != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.DEFAULT_PORT != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.DEFAULT_PORT != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.DEFAULT_PORT > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.DEFAULT_PORT != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.DEFAULT_PORT > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.DEFAULT_PORT > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.DEFAULT_PORT > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
NameNode.instance.namesystem.blockDeletionIncrement < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.namesystem.blockDeletionIncrement < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.blockDeletionIncrement > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.blockDeletionIncrement < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.blockDeletionIncrement != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.blockDeletionIncrement != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.blockDeletionIncrement != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.blockDeletionIncrement != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.blockDeletionIncrement > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.blockDeletionIncrement != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.blockDeletionIncrement > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.blockDeletionIncrement > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.blockDeletionIncrement > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
daikon.Quant.fuzzy.ne(NameNode.instance.namesystem.cacheManager.MIN_CACHED_BLOCKS_PERCENT, blockManagerInstance.reconstructionQueuesInitProgress)
daikon.Quant.subsetOf(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE, NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
daikon.Quant.subsetOf(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE, NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.cacheManager.scanIntervalMs < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.namesystem.cacheManager.scanIntervalMs < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.cacheManager.scanIntervalMs > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.cacheManager.scanIntervalMs < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.cacheManager.scanIntervalMs != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.cacheManager.scanIntervalMs != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.cacheManager.scanIntervalMs != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.cacheManager.scanIntervalMs != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.cacheManager.scanIntervalMs > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.cacheManager.scanIntervalMs != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.cacheManager.scanIntervalMs > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.cacheManager.scanIntervalMs > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.cacheManager.scanIntervalMs > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.dir.inodeXAttrsLimit < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.namesystem.dir.inodeXAttrsLimit < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.dir.inodeXAttrsLimit > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.dir.inodeXAttrsLimit < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.dir.inodeXAttrsLimit != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.dir.inodeXAttrsLimit != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.dir.inodeXAttrsLimit != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.dir.inodeXAttrsLimit != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.dir.inodeXAttrsLimit > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.dir.inodeXAttrsLimit != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.dir.inodeXAttrsLimit > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.dir.inodeXAttrsLimit > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.dir.inodeXAttrsLimit > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.dir.maxComponentLength < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.namesystem.dir.maxComponentLength < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.dir.maxComponentLength > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.dir.maxComponentLength < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.dir.maxComponentLength != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.dir.maxComponentLength != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.dir.maxComponentLength != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.dir.maxComponentLength != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.dir.maxComponentLength > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.dir.maxComponentLength != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.dir.maxComponentLength > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.dir.maxComponentLength > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.dir.maxComponentLength > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.dir.maxDirItems < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.namesystem.dir.maxDirItems < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.dir.maxDirItems > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.dir.maxDirItems < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.dir.maxDirItems > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.dir.maxDirItems != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.dir.maxDirItems != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.dir.maxDirItems != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.dir.maxDirItems > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.dir.maxDirItems != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.dir.maxDirItems > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.dir.maxDirItems > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.dir.maxDirItems > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.dir.xattrMaxSize < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.namesystem.dir.xattrMaxSize < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.dir.xattrMaxSize > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.dir.xattrMaxSize < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.dir.xattrMaxSize != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.dir.xattrMaxSize != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.dir.xattrMaxSize != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.dir.xattrMaxSize != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.dir.xattrMaxSize > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.dir.xattrMaxSize != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.dir.xattrMaxSize > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.dir.xattrMaxSize > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.dir.xattrMaxSize > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.editLogRollerThreshold < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.namesystem.editLogRollerThreshold < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.editLogRollerThreshold > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.editLogRollerThreshold < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.editLogRollerThreshold > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.editLogRollerThreshold != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.editLogRollerThreshold != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.editLogRollerThreshold != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.editLogRollerThreshold > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.editLogRollerThreshold != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.editLogRollerThreshold > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.editLogRollerThreshold > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.editLogRollerThreshold > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > NameNode.instance.namesystem.lazyPersistFileScrubberTS
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > NameNode.instance.namesystem.leaseManager.hardLimit
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > NameNode.instance.namesystem.leaseRecheckIntervalMs
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > NameNode.instance.namesystem.nnResourceChecker.duReserved
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.blockIdManager.legacyGenerationStampLimit
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.blockReportLeaseManager.leaseExpiryMs
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.blockReportLeaseManager.maxPending
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.blocksMap.capacity
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.blocksPerPostpondedRescan
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.blocksReplWorkMultiplier
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.bmSafeMode.safeReplication
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.datanodeManager.defaultInfoPort
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.datanodeManager.defaultInfoSecurePort
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.datanodeManager.defaultIpcPort
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.datanodeManager.defaultXferPort
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.datanodeManager.heartbeatExpireInterval
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.datanodeManager.staleInterval
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.maxCorruptFilesReturned
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.neededReconstruction.LEVEL
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.replQueueResetToHeadThreshold
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.storageInfoDefragmentInterval
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.storagePolicySuite.defaultPolicyID
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.lazyPersistFileScrubberTS < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.lazyPersistFileScrubberTS != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.lazyPersistFileScrubberTS != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.lazyPersistFileScrubberTS != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.lazyPersistFileScrubberTS != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.lazyPersistFileScrubberTS > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.lazyPersistFileScrubberTS > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.leaseManager.hardLimit < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.leaseManager.hardLimit > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.leaseManager.hardLimit < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.leaseManager.hardLimit > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.leaseManager.hardLimit != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.leaseManager.hardLimit != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.leaseManager.hardLimit != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.leaseManager.hardLimit > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.leaseManager.hardLimit != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.leaseManager.hardLimit > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.leaseManager.hardLimit > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.leaseManager.hardLimit > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.leaseRecheckIntervalMs < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.leaseRecheckIntervalMs > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.leaseRecheckIntervalMs < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.leaseRecheckIntervalMs != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.leaseRecheckIntervalMs != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.leaseRecheckIntervalMs != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.leaseRecheckIntervalMs != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.leaseRecheckIntervalMs > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.leaseRecheckIntervalMs != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.leaseRecheckIntervalMs > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.leaseRecheckIntervalMs > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.leaseRecheckIntervalMs > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.nnResourceChecker.duReserved < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.nnResourceChecker.duReserved > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.nnResourceChecker.duReserved < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.nnResourceChecker.duReserved > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.nnResourceChecker.duReserved != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.nnResourceChecker.duReserved != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.nnResourceChecker.duReserved != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.nnResourceChecker.duReserved > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.nnResourceChecker.duReserved != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.nnResourceChecker.duReserved > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.nnResourceChecker.duReserved > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.nnResourceChecker.duReserved > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.startTime < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.startTime > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.startTime > blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.startTime > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.startTime > blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.startTime > blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.startTime > blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.startTime > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.startTime > blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.startTime > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.startTime > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.startTime > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER < blockManagerInstance.blockReportLeaseManager.nextId
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER != blockManagerInstance.bmSafeMode.startTime
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID < blockManagerInstance.blockReportLeaseManager.nextId
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID > blockManagerInstance.bmSafeMode.startTime
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID > blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP < blockManagerInstance.blockReportLeaseManager.nextId
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP != blockManagerInstance.bmSafeMode.startTime
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.blockIdManager.legacyGenerationStampLimit < blockManagerInstance.blockReportLeaseManager.nextId
blockManagerInstance.blockIdManager.legacyGenerationStampLimit < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
blockManagerInstance.blockIdManager.legacyGenerationStampLimit <= blockManagerInstance.bmSafeMode.startTime
blockManagerInstance.blockIdManager.legacyGenerationStampLimit <= blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.blockIdManager.legacyGenerationStampLimit <= blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.blockIdManager.legacyGenerationStampLimit <= blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.blockIdManager.legacyGenerationStampLimit <= blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.blockIdManager.legacyGenerationStampLimit <= blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.blockIdManager.legacyGenerationStampLimit != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.blockIdManager.legacyGenerationStampLimit <= blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.blockIdManager.legacyGenerationStampLimit <= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.blockIdManager.legacyGenerationStampLimit >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
blockManagerInstance.blockIdManager.legacyGenerationStampLimit <= daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.blockIdManager.legacyGenerationStampLimit != daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs < blockManagerInstance.blockReportLeaseManager.nextId
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs != blockManagerInstance.bmSafeMode.startTime
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.blockReportLeaseManager.maxPending < blockManagerInstance.blockReportLeaseManager.nextId
blockManagerInstance.blockReportLeaseManager.maxPending < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
blockManagerInstance.blockReportLeaseManager.maxPending != blockManagerInstance.bmSafeMode.startTime
blockManagerInstance.blockReportLeaseManager.maxPending != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.blockReportLeaseManager.maxPending != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.blockReportLeaseManager.maxPending != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.blockReportLeaseManager.maxPending != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.blockReportLeaseManager.maxPending > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.blockReportLeaseManager.maxPending != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.blockReportLeaseManager.maxPending > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.blockReportLeaseManager.maxPending > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.blockReportLeaseManager.maxPending > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.blocksMap.capacity
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.blocksPerPostpondedRescan
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.blocksReplWorkMultiplier
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.bmSafeMode.safeReplication
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.bmSafeMode.startTime
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.datanodeManager.defaultInfoPort
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.datanodeManager.defaultInfoSecurePort
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.datanodeManager.defaultIpcPort
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.datanodeManager.defaultXferPort
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.datanodeManager.heartbeatExpireInterval
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.datanodeManager.staleInterval
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.maxCorruptFilesReturned
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
2 * blockManagerInstance.blockReportLeaseManager.nextId - blockManagerInstance.replQueueCallsSinceReset - -2147483648 == 0
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.storageInfoDefragmentInterval
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.blockReportLeaseManager.nextId > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.blockReportLeaseManager.nextId > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS != blockManagerInstance.bmSafeMode.startTime
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
daikon.Quant.fuzzy.ne(blockManagerInstance.blocksInvalidateWorkPct, blockManagerInstance.reconstructionQueuesInitProgress)
blockManagerInstance.blocksMap.capacity > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
blockManagerInstance.blocksMap.capacity != blockManagerInstance.bmSafeMode.startTime
blockManagerInstance.blocksMap.capacity > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.blocksMap.capacity != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.blocksMap.capacity != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.blocksMap.capacity != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.blocksMap.capacity > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.blocksMap.capacity != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.blocksMap.capacity > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.blocksMap.capacity > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.blocksMap.capacity > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.blocksPerPostpondedRescan > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
blockManagerInstance.blocksPerPostpondedRescan != blockManagerInstance.bmSafeMode.startTime
blockManagerInstance.blocksPerPostpondedRescan != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.blocksPerPostpondedRescan != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.blocksPerPostpondedRescan != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.blocksPerPostpondedRescan != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.blocksPerPostpondedRescan > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.blocksPerPostpondedRescan != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.blocksPerPostpondedRescan > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.blocksPerPostpondedRescan > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.blocksPerPostpondedRescan > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.blocksReplWorkMultiplier < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
blockManagerInstance.blocksReplWorkMultiplier != blockManagerInstance.bmSafeMode.startTime
blockManagerInstance.blocksReplWorkMultiplier != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.blocksReplWorkMultiplier != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.blocksReplWorkMultiplier != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.blocksReplWorkMultiplier != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.blocksReplWorkMultiplier > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.blocksReplWorkMultiplier != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.blocksReplWorkMultiplier >= blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.blocksReplWorkMultiplier > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.blocksReplWorkMultiplier != daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.blocksReplWorkMultiplier >= daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.bmSafeMode.safeReplication
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE != blockManagerInstance.bmSafeMode.startTime
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.datanodeManager.defaultInfoPort
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.datanodeManager.defaultInfoSecurePort
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.datanodeManager.defaultIpcPort
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.datanodeManager.defaultXferPort
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.datanodeManager.heartbeatExpireInterval
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE >= blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.datanodeManager.staleInterval
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.maxCorruptFilesReturned
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.storageInfoDefragmentInterval
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.bmSafeMode.startTime
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size < daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size < daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
daikon.Quant.fuzzy.ne(blockManagerInstance.bmSafeMode.replQueueThreshold, blockManagerInstance.reconstructionQueuesInitProgress)
blockManagerInstance.bmSafeMode.safeReplication != blockManagerInstance.bmSafeMode.startTime
blockManagerInstance.bmSafeMode.safeReplication != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.bmSafeMode.safeReplication != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.bmSafeMode.safeReplication != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.bmSafeMode.safeReplication != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.bmSafeMode.safeReplication >= blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.bmSafeMode.safeReplication != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.bmSafeMode.safeReplication >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.bmSafeMode.safeReplication != daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.bmSafeMode.safeReplication != daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
blockManagerInstance.bmSafeMode.startTime != blockManagerInstance.datanodeManager.defaultInfoPort
blockManagerInstance.bmSafeMode.startTime != blockManagerInstance.datanodeManager.defaultInfoSecurePort
blockManagerInstance.bmSafeMode.startTime != blockManagerInstance.datanodeManager.defaultIpcPort
blockManagerInstance.bmSafeMode.startTime != blockManagerInstance.datanodeManager.defaultXferPort
blockManagerInstance.bmSafeMode.startTime != blockManagerInstance.datanodeManager.heartbeatExpireInterval
blockManagerInstance.bmSafeMode.startTime != blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
blockManagerInstance.bmSafeMode.startTime != blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE
blockManagerInstance.bmSafeMode.startTime != blockManagerInstance.datanodeManager.staleInterval
blockManagerInstance.bmSafeMode.startTime >= blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.bmSafeMode.startTime >= blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.bmSafeMode.startTime != blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.bmSafeMode.startTime != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.bmSafeMode.startTime != blockManagerInstance.maxCorruptFilesReturned
blockManagerInstance.bmSafeMode.startTime != blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.bmSafeMode.startTime != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.bmSafeMode.startTime != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.bmSafeMode.startTime != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.bmSafeMode.startTime != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.bmSafeMode.startTime != blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
blockManagerInstance.bmSafeMode.startTime >= blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.bmSafeMode.startTime != blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.bmSafeMode.startTime != blockManagerInstance.storageInfoDefragmentInterval
blockManagerInstance.bmSafeMode.startTime != blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.bmSafeMode.startTime >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.bmSafeMode.startTime >= daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.defaultInfoPort != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.datanodeManager.defaultInfoPort != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.datanodeManager.defaultInfoPort != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.datanodeManager.defaultInfoPort != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.datanodeManager.defaultInfoPort > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.datanodeManager.defaultInfoPort != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.datanodeManager.defaultInfoPort > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.datanodeManager.defaultInfoPort > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.defaultInfoPort > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.defaultInfoSecurePort != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.datanodeManager.defaultInfoSecurePort != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.datanodeManager.defaultInfoSecurePort != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.datanodeManager.defaultInfoSecurePort != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.datanodeManager.defaultInfoSecurePort > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.datanodeManager.defaultInfoSecurePort != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.datanodeManager.defaultInfoSecurePort > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.datanodeManager.defaultInfoSecurePort > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.defaultInfoSecurePort > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.defaultIpcPort != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.datanodeManager.defaultIpcPort != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.datanodeManager.defaultIpcPort != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.datanodeManager.defaultIpcPort != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.datanodeManager.defaultIpcPort > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.datanodeManager.defaultIpcPort != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.datanodeManager.defaultIpcPort > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.datanodeManager.defaultIpcPort > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.defaultIpcPort > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.defaultXferPort != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.datanodeManager.defaultXferPort != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.datanodeManager.defaultXferPort != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.datanodeManager.defaultXferPort != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.datanodeManager.defaultXferPort > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.datanodeManager.defaultXferPort != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.datanodeManager.defaultXferPort > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.datanodeManager.defaultXferPort > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.defaultXferPort > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.heartbeatExpireInterval > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.datanodeManager.heartbeatExpireInterval != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.datanodeManager.heartbeatExpireInterval != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.datanodeManager.heartbeatExpireInterval != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.datanodeManager.heartbeatExpireInterval > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.datanodeManager.heartbeatExpireInterval != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.datanodeManager.heartbeatExpireInterval > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.datanodeManager.heartbeatExpireInterval > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.heartbeatExpireInterval > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds >= daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
daikon.Quant.fuzzy.ne(blockManagerInstance.datanodeManager.ratioUseStaleDataNodesForWrite, blockManagerInstance.reconstructionQueuesInitProgress)
blockManagerInstance.datanodeManager.staleInterval != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.datanodeManager.staleInterval != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.datanodeManager.staleInterval != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.datanodeManager.staleInterval != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.datanodeManager.staleInterval > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.datanodeManager.staleInterval != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.datanodeManager.staleInterval > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.datanodeManager.staleInterval > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.staleInterval > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.blockPoolUsed <= blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.heartbeatManager.stats.blockPoolUsed <= blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.heartbeatManager.stats.blockPoolUsed <= blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.heartbeatManager.stats.blockPoolUsed >= blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.heartbeatManager.stats.blockPoolUsed < blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.heartbeatManager.stats.blockPoolUsed != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.heartbeatManager.stats.blockPoolUsed != blockManagerInstance.maxCorruptFilesReturned
blockManagerInstance.heartbeatManager.stats.blockPoolUsed != blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.heartbeatManager.stats.blockPoolUsed < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.heartbeatManager.stats.blockPoolUsed != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.heartbeatManager.stats.blockPoolUsed != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.heartbeatManager.stats.blockPoolUsed != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.heartbeatManager.stats.blockPoolUsed != blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
blockManagerInstance.heartbeatManager.stats.blockPoolUsed >= blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.heartbeatManager.stats.blockPoolUsed != blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.heartbeatManager.stats.blockPoolUsed < blockManagerInstance.storageInfoDefragmentInterval
blockManagerInstance.heartbeatManager.stats.blockPoolUsed != blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.heartbeatManager.stats.blockPoolUsed >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.blockPoolUsed != daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
blockManagerInstance.heartbeatManager.stats.capacityRemaining <= blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.heartbeatManager.stats.capacityRemaining >= blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.heartbeatManager.stats.capacityRemaining >= blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.heartbeatManager.stats.capacityRemaining != blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.heartbeatManager.stats.capacityRemaining > blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.heartbeatManager.stats.capacityRemaining != blockManagerInstance.maxCorruptFilesReturned
blockManagerInstance.heartbeatManager.stats.capacityRemaining != blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.heartbeatManager.stats.capacityRemaining != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.heartbeatManager.stats.capacityRemaining != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.heartbeatManager.stats.capacityRemaining != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.heartbeatManager.stats.capacityRemaining != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.heartbeatManager.stats.capacityRemaining != blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
blockManagerInstance.heartbeatManager.stats.capacityRemaining >= blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.heartbeatManager.stats.capacityRemaining != blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.heartbeatManager.stats.capacityRemaining != blockManagerInstance.storageInfoDefragmentInterval
blockManagerInstance.heartbeatManager.stats.capacityRemaining != blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.heartbeatManager.stats.capacityRemaining >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.capacityRemaining != daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
blockManagerInstance.heartbeatManager.stats.capacityTotal >= blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.heartbeatManager.stats.capacityTotal >= blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.heartbeatManager.stats.capacityTotal != blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.heartbeatManager.stats.capacityTotal > blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.heartbeatManager.stats.capacityTotal != blockManagerInstance.maxCorruptFilesReturned
blockManagerInstance.heartbeatManager.stats.capacityTotal != blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.heartbeatManager.stats.capacityTotal != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.heartbeatManager.stats.capacityTotal != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.heartbeatManager.stats.capacityTotal != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.heartbeatManager.stats.capacityTotal != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.heartbeatManager.stats.capacityTotal != blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
blockManagerInstance.heartbeatManager.stats.capacityTotal >= blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.heartbeatManager.stats.capacityTotal != blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.heartbeatManager.stats.capacityTotal != blockManagerInstance.storageInfoDefragmentInterval
blockManagerInstance.heartbeatManager.stats.capacityTotal != blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.heartbeatManager.stats.capacityTotal >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.capacityTotal != daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs >= blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs != blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs > blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs != blockManagerInstance.maxCorruptFilesReturned
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs != blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs != blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs >= blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs != blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs != blockManagerInstance.storageInfoDefragmentInterval
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs != blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs != daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
blockManagerInstance.heartbeatManager.stats.nodesInService < blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.heartbeatManager.stats.nodesInService != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.heartbeatManager.stats.nodesInService < blockManagerInstance.maxCorruptFilesReturned
blockManagerInstance.heartbeatManager.stats.nodesInService < blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.heartbeatManager.stats.nodesInService < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.heartbeatManager.stats.nodesInService < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.heartbeatManager.stats.nodesInService < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.heartbeatManager.stats.nodesInService < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.heartbeatManager.stats.nodesInService < blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
blockManagerInstance.heartbeatManager.stats.nodesInService < blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.heartbeatManager.stats.nodesInService < blockManagerInstance.storageInfoDefragmentInterval
blockManagerInstance.heartbeatManager.stats.nodesInService < blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.heartbeatManager.stats.nodesInService >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.nodesInService <= daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.nodesInService != daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
blockManagerInstance.invalidateBlocks.startupTime != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.invalidateBlocks.startupTime > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.invalidateBlocks.startupTime > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.invalidateBlocks.startupTime > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.lastRedundancyCycleTS != blockManagerInstance.maxCorruptFilesReturned
blockManagerInstance.lastRedundancyCycleTS != blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.lastRedundancyCycleTS != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.lastRedundancyCycleTS != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.lastRedundancyCycleTS != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.lastRedundancyCycleTS != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.lastRedundancyCycleTS != blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
blockManagerInstance.lastRedundancyCycleTS != blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.lastRedundancyCycleTS != blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.lastRedundancyCycleTS != blockManagerInstance.storageInfoDefragmentInterval
blockManagerInstance.lastRedundancyCycleTS != blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.lastRedundancyCycleTS >= daikon.Quant.size(DataNode.instance.directoryScanner.diffs_FOR_ENCLOSING_USE)-1
blockManagerInstance.lastRedundancyCycleTS != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.lastRedundancyCycleTS != daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.maxCorruptFilesReturned > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.maxCorruptFilesReturned > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.maxCorruptFilesReturned > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.neededReconstruction.LEVEL > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.neededReconstruction.LEVEL > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.neededReconstruction.LEVEL > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
daikon.Quant.fuzzy.ne(blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.DEFAULT_MAX_LOAD_FACTOR, blockManagerInstance.reconstructionQueuesInitProgress)
daikon.Quant.fuzzy.ne(blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.DEFAUT_MIN_LOAD_FACTOR, blockManagerInstance.reconstructionQueuesInitProgress)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
daikon.Quant.fuzzy.ne(blockManagerInstance.placementPolicies.ecPolicy.considerLoadFactor, blockManagerInstance.reconstructionQueuesInitProgress)
blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.replQueueCallsSinceReset < blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.replQueueCallsSinceReset < blockManagerInstance.storageInfoDefragmentInterval
blockManagerInstance.replQueueCallsSinceReset < blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.replQueueCallsSinceReset >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
blockManagerInstance.replQueueCallsSinceReset <= daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.replQueueResetToHeadThreshold > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.replQueueResetToHeadThreshold > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.storageInfoDefragmentInterval > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.storageInfoDefragmentInterval > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.storagePolicySuite.defaultPolicyID > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.storagePolicySuite.defaultPolicyID > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
daikon.Quant.size(DataNode.instance.directoryScanner.diffs_FOR_ENCLOSING_USE)-1 <= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
daikon.Quant.size(DataNode.instance.directoryScanner.diffs_FOR_ENCLOSING_USE)-1 <= daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) <= daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) != daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 <= daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
blockManagerInstance.blockReportLeaseManager.nextId - blockManagerInstance.replQueueCallsSinceReset - daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) - 1.57950863219532723E18 == 0
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME == DataNode.instance.directoryScanner.diffs.serialVersionUID
DataNode.instance.directoryScanner.diffs.serialVersionUID == DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS
DataNode.instance.directoryScanner.diffs.serialVersionUID == DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.directoryScanner.diffs.serialVersionUID == blockManagerInstance.bmSafeMode.safeReplication
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.dir.aclsEnabled
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.namesystem.dir.posixAclInheritanceEnabled
daikon.Quant.pairwiseEqual(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE, NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == blockManagerInstance.heartbeatManager.stats.xceiverCount
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.directoryScanner.diffs.serialVersionUID)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.directoryScanner.diffs.serialVersionUID-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.directoryScanner.diffs.serialVersionUID) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.directoryScanner.diffs.serialVersionUID) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.volumeChecker.numSyncDatasetChecks)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.directoryScanner.diffs.serialVersionUID-1) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval)
DataNode.instance.directoryScanner.diffs.serialVersionUID == 1
DataNode.instance.id.infoPort == 46107
DataNode.instance.id.ipcPort == 37535
DataNode.instance.id.nsInfo.cTime == 1731381896309L
DataNode.instance.id.nsInfo.namespaceID == 1347617927
DataNode.instance.id.xferPort == 35937
DataNode.instance.lastDiskErrorCheck == 118007316
DataNode.instance.storage.namespaceID == 1347617927
DataNode.instance.volumeChecker.lastAllVolumesCheck == 117106598 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 118007309
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118006600
daikon.Quant.eltsNotEqual(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE, null)
NameNode.instance.namesystem.cacheManager.nextDirectiveId >= 1
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118005250
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118004482
NameNode.instance.namesystem.startTime == 1731381899574L
blockManagerInstance.blockReportLeaseManager.nextId == 2124344933885414680L || blockManagerInstance.blockReportLeaseManager.nextId == 2124344933885414683L
blockManagerInstance.bmSafeMode.startTime == 0 || blockManagerInstance.bmSafeMode.startTime == 118005187
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 0 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 147456
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 0 || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 280640102400L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 280640299008L
blockManagerInstance.heartbeatManager.stats.capacityTotal == 0 || blockManagerInstance.heartbeatManager.stats.capacityTotal == 402300542976L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 0 || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 101044273152L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 101044469760L
blockManagerInstance.heartbeatManager.stats.nodesInService == 0 || blockManagerInstance.heartbeatManager.stats.nodesInService == 3
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 0 || blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 3
blockManagerInstance.invalidateBlocks.startupTime == 118004485
blockManagerInstance.lastRedundancyCycleTS == -1 || blockManagerInstance.lastRedundancyCycleTS == 118008188
blockManagerInstance.replQueueCallsSinceReset == 0 || blockManagerInstance.replQueueCallsSinceReset == 1
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.directoryScanner.diffs.serialVersionUID) != null
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.directoryScanner.diffs.serialVersionUID-1) != null
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT <= daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)-1
DataNode.instance.NUM_CORES > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.NUM_CORES > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION >= blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION >= blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME <= NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME >= blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME >= daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)-1
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.asyncDiskService.numDeletedBlocks <= daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME <= NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME != blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME != blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME >= blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.data.cacheManager.numBlocksCached < NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.data.cacheManager.numBlocksCached <= blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.cacheManager.numBlocksCached <= daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.data.cacheManager.revocationMs > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.data.cacheManager.revocationMs > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.cacheManager.revocationMs > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.data.cacheManager.revocationPollingMs > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.data.cacheManager.revocationPollingMs > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.cacheManager.revocationPollingMs > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.data.maxDataLength > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.data.maxDataLength > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.maxDataLength > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.data.smallBufferSize > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.data.smallBufferSize > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.smallBufferSize > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.data.volsConfigured != blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.volsConfigured != blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.volsConfigured > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.directoryScanner.MILLIS_PER_SECOND > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.directoryScanner.MILLIS_PER_SECOND > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.directoryScanner.MILLIS_PER_SECOND > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.directoryScanner.diffs.serialVersionUID < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.directoryScanner.diffs.serialVersionUID <= NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.directoryScanner.diffs.serialVersionUID < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.directoryScanner.diffs.serialVersionUID < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.directoryScanner.diffs.serialVersionUID < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.directoryScanner.diffs.serialVersionUID < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.directoryScanner.diffs.serialVersionUID != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.directoryScanner.diffs.serialVersionUID != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.directoryScanner.diffs.serialVersionUID != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.directoryScanner.diffs.serialVersionUID != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.directoryScanner.diffs.serialVersionUID < blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.directoryScanner.diffs.serialVersionUID != blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.directoryScanner.diffs.serialVersionUID != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.directoryScanner.diffs.serialVersionUID >= blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.directoryScanner.diffs.serialVersionUID < daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
DataNode.instance.directoryScanner.scanPeriodMsecs > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.directoryScanner.scanPeriodMsecs > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.directoryScanner.scanPeriodMsecs > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.diskBalancer.bandwidth > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.diskBalancer.bandwidth > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.diskBalancer.planValidityInterval > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.diskBalancer.planValidityInterval > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.diskBalancer.planValidityInterval > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.blockReportInterval > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.dnConf.blockReportInterval > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.dnConf.blockReportInterval > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.blockReportSplitThreshold > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.dnConf.blockReportSplitThreshold > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.dnConf.blockReportSplitThreshold > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.bpReadyTimeout > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.dnConf.bpReadyTimeout > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.cacheReportInterval > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.dnConf.cacheReportInterval > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.dnConf.cacheReportInterval > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.heartBeatInterval > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.dnConf.heartBeatInterval > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.dnConf.heartBeatInterval > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.ibrInterval < NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.dnConf.ibrInterval <= blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.dnConf.ibrInterval <= daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.lifelineIntervalMs > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.dnConf.lifelineIntervalMs > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.dnConf.lifelineIntervalMs > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.maxDataLength > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.dnConf.maxDataLength > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.dnConf.maxDataLength > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.outliersReportIntervalMs > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.dnConf.outliersReportIntervalMs > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.dnConf.outliersReportIntervalMs > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.readaheadLength > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.dnConf.readaheadLength > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.dnConf.readaheadLength > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.restartReplicaExpiry > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.dnConf.restartReplicaExpiry != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.restartReplicaExpiry > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.dnConf.restartReplicaExpiry > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.socketKeepaliveTimeout > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.dnConf.socketKeepaliveTimeout > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.dnConf.socketKeepaliveTimeout > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.socketTimeout > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.dnConf.socketTimeout != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.socketTimeout > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.dnConf.socketTimeout > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.socketWriteTimeout > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.dnConf.socketWriteTimeout > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.dnConf.socketWriteTimeout > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.volsConfigured != blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.dnConf.volsConfigured != blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.dnConf.volsConfigured > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS <= NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS != blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS != blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS >= blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.httpServer.HTTP_MAX_THREADS > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.httpServer.HTTP_MAX_THREADS >= daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)-1
DataNode.instance.id.infoPort > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.id.infoPort > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.id.infoPort > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.id.ipcPort > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.id.ipcPort > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.id.ipcPort > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.id.nsInfo.cTime > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.id.nsInfo.layoutVersion < NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.id.nsInfo.layoutVersion < blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.id.nsInfo.layoutVersion < daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)-1
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.id.nsInfo.namespaceID > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.id.xferPort > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.id.xferPort > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.id.xferPort > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.lastDiskErrorCheck > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.lastDiskErrorCheck > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.lastDiskErrorCheck > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.shortCircuitRegistry.SHM_LENGTH > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.shortCircuitRegistry.SHM_LENGTH > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.shortCircuitRegistry.SHM_LENGTH > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.storage.layoutVersion < blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.storage.layoutVersion < daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)-1
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.storage.namespaceID > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.storage.namespaceID > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.volumeChecker.lastAllVolumesCheck > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.volumeChecker.numSyncDatasetChecks <= NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.volumeChecker.numSyncDatasetChecks >= blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.xserver.balanceThrottler.curPeriodStart > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.maxThreads > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.xserver.balanceThrottler.maxThreads > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.xserver.balanceThrottler.maxThreads > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.period > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.xserver.balanceThrottler.period > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.xserver.balanceThrottler.period > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.periodExtension > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.xserver.balanceThrottler.periodExtension > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.xserver.balanceThrottler.periodExtension > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.xserver.estimateBlockSize > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.xserver.estimateBlockSize > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.xserver.estimateBlockSize > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.xserver.maxXceiverCount > NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.xserver.maxXceiverCount > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.xserver.maxXceiverCount > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.DEFAULT_PORT > NameNode.instance.namesystem.cacheManager.nextDirectiveId
NameNode.instance.DEFAULT_PORT > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.DEFAULT_PORT > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS > NameNode.instance.namesystem.cacheManager.nextDirectiveId
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL > NameNode.instance.namesystem.cacheManager.nextDirectiveId
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < NameNode.instance.namesystem.cacheManager.nextDirectiveId
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)-1
NameNode.instance.namesystem.blockDeletionIncrement > NameNode.instance.namesystem.cacheManager.nextDirectiveId
NameNode.instance.namesystem.blockDeletionIncrement > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.blockDeletionIncrement > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
daikon.Quant.subsetOf(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE, NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses > NameNode.instance.namesystem.cacheManager.nextDirectiveId
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.cacheManager.nextDirectiveId < NameNode.instance.namesystem.cacheManager.scanIntervalMs
NameNode.instance.namesystem.cacheManager.nextDirectiveId < NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval
NameNode.instance.namesystem.cacheManager.nextDirectiveId < NameNode.instance.namesystem.dir.maxComponentLength
NameNode.instance.namesystem.cacheManager.nextDirectiveId < NameNode.instance.namesystem.dir.maxDirItems
NameNode.instance.namesystem.cacheManager.nextDirectiveId < NameNode.instance.namesystem.dir.xattrMaxSize
NameNode.instance.namesystem.cacheManager.nextDirectiveId < NameNode.instance.namesystem.editLogRollerThreshold
NameNode.instance.namesystem.cacheManager.nextDirectiveId < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.namesystem.cacheManager.nextDirectiveId < NameNode.instance.namesystem.lazyPersistFileScrubberTS
NameNode.instance.namesystem.cacheManager.nextDirectiveId < NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN
NameNode.instance.namesystem.cacheManager.nextDirectiveId < NameNode.instance.namesystem.leaseManager.hardLimit
NameNode.instance.namesystem.cacheManager.nextDirectiveId < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.cacheManager.nextDirectiveId < NameNode.instance.namesystem.leaseRecheckIntervalMs
NameNode.instance.namesystem.cacheManager.nextDirectiveId < NameNode.instance.namesystem.nnResourceChecker.duReserved
NameNode.instance.namesystem.cacheManager.nextDirectiveId < NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit
NameNode.instance.namesystem.cacheManager.nextDirectiveId < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.cacheManager.nextDirectiveId < blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
NameNode.instance.namesystem.cacheManager.nextDirectiveId < blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP
NameNode.instance.namesystem.cacheManager.nextDirectiveId > blockManagerInstance.blockIdManager.legacyGenerationStampLimit
NameNode.instance.namesystem.cacheManager.nextDirectiveId < blockManagerInstance.blockReportLeaseManager.leaseExpiryMs
3 * NameNode.instance.namesystem.cacheManager.nextDirectiveId - 2 * blockManagerInstance.blockReportLeaseManager.nextId + 2147483647 == 0
NameNode.instance.namesystem.cacheManager.nextDirectiveId < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.cacheManager.nextDirectiveId < blockManagerInstance.blocksMap.capacity
NameNode.instance.namesystem.cacheManager.nextDirectiveId < blockManagerInstance.blocksPerPostpondedRescan
NameNode.instance.namesystem.cacheManager.nextDirectiveId > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size
NameNode.instance.namesystem.cacheManager.nextDirectiveId >= blockManagerInstance.bmSafeMode.safeReplication
NameNode.instance.namesystem.cacheManager.nextDirectiveId < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.cacheManager.nextDirectiveId < blockManagerInstance.datanodeManager.defaultInfoPort
NameNode.instance.namesystem.cacheManager.nextDirectiveId < blockManagerInstance.datanodeManager.defaultInfoSecurePort
NameNode.instance.namesystem.cacheManager.nextDirectiveId < blockManagerInstance.datanodeManager.defaultIpcPort
NameNode.instance.namesystem.cacheManager.nextDirectiveId < blockManagerInstance.datanodeManager.defaultXferPort
NameNode.instance.namesystem.cacheManager.nextDirectiveId < blockManagerInstance.datanodeManager.heartbeatExpireInterval
NameNode.instance.namesystem.cacheManager.nextDirectiveId < blockManagerInstance.datanodeManager.staleInterval
NameNode.instance.namesystem.cacheManager.nextDirectiveId != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.cacheManager.nextDirectiveId != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.cacheManager.nextDirectiveId != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.cacheManager.nextDirectiveId != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.cacheManager.nextDirectiveId < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.cacheManager.nextDirectiveId != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.cacheManager.nextDirectiveId < blockManagerInstance.maxCorruptFilesReturned
NameNode.instance.namesystem.cacheManager.nextDirectiveId < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
NameNode.instance.namesystem.cacheManager.nextDirectiveId < blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
NameNode.instance.namesystem.cacheManager.nextDirectiveId > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.cacheManager.nextDirectiveId < blockManagerInstance.replQueueResetToHeadThreshold
NameNode.instance.namesystem.cacheManager.nextDirectiveId < blockManagerInstance.storageInfoDefragmentInterval
NameNode.instance.namesystem.cacheManager.nextDirectiveId > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.cacheManager.scanIntervalMs > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.cacheManager.scanIntervalMs > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.dir.inodeXAttrsLimit > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.dir.inodeXAttrsLimit > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.dir.maxComponentLength > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.dir.maxComponentLength > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.dir.maxDirItems > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.dir.maxDirItems > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.dir.xattrMaxSize > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.dir.xattrMaxSize > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.editLogRollerThreshold > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.editLogRollerThreshold > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.lazyPersistFileScrubberTS > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.leaseManager.hardLimit > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.leaseManager.hardLimit > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
daikon.Quant.subsetOf(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE, NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.leaseRecheckIntervalMs > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.leaseRecheckIntervalMs > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.nnResourceChecker.duReserved > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.nnResourceChecker.duReserved > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.startTime > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.startTime > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.blockIdManager.legacyGenerationStampLimit <= blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.blockIdManager.legacyGenerationStampLimit <= daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.blockReportLeaseManager.maxPending > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.blockReportLeaseManager.maxPending > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
2 * blockManagerInstance.blockReportLeaseManager.nextId - 3 * daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE) - -2147483648 == 0
blockManagerInstance.blockReportLeaseManager.nextId > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS >= daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)-1
blockManagerInstance.blocksMap.capacity > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.blocksMap.capacity > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.blocksPerPostpondedRescan > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.blocksPerPostpondedRescan > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.blocksReplWorkMultiplier != blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.blocksReplWorkMultiplier != blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.blocksReplWorkMultiplier > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size < daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)-1
blockManagerInstance.bmSafeMode.safeReplication != blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.bmSafeMode.safeReplication != blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.bmSafeMode.safeReplication >= blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.bmSafeMode.startTime >= blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.bmSafeMode.startTime >= daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.defaultInfoPort > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.datanodeManager.defaultInfoPort > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.defaultInfoSecurePort > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.datanodeManager.defaultInfoSecurePort > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.defaultIpcPort > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.datanodeManager.defaultIpcPort > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.defaultXferPort > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.datanodeManager.defaultXferPort > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.heartbeatExpireInterval > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.datanodeManager.heartbeatExpireInterval > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds >= blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds >= blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.staleInterval > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.datanodeManager.staleInterval > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.blockPoolUsed >= blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.heartbeatManager.stats.blockPoolUsed != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.heartbeatManager.stats.blockPoolUsed >= daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.capacityRemaining >= blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.heartbeatManager.stats.capacityRemaining >= daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.capacityRemaining % daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1 == 0
blockManagerInstance.heartbeatManager.stats.capacityTotal >= blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.heartbeatManager.stats.capacityTotal >= daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs >= blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs >= daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs % daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1 == 0
blockManagerInstance.heartbeatManager.stats.nodesInService >= blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.heartbeatManager.stats.nodesInService >= blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount < blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount < blockManagerInstance.maxCorruptFilesReturned
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount < blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount < blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount >= blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount < blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount < blockManagerInstance.storageInfoDefragmentInterval
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount < blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount <= daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount != daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
blockManagerInstance.invalidateBlocks.startupTime > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.lastRedundancyCycleTS != daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.maxCorruptFilesReturned > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.neededReconstruction.LEVEL >= daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.replQueueCallsSinceReset != daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
blockManagerInstance.replQueueResetToHeadThreshold > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.storageInfoDefragmentInterval > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
blockManagerInstance.storagePolicySuite.defaultPolicyID > daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
daikon.Quant.size(DataNode.instance.directoryScanner.diffs_FOR_ENCLOSING_USE)-1 <= daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)-1
5.999802972E9 * DataNode.instance.volumeChecker.numSyncDatasetChecks - 3 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 335751653 * blockManagerInstance.heartbeatManager.stats.nodesInService + 3.54015750689739E14 == 0
5.999802972E9 * DataNode.instance.volumeChecker.numSyncDatasetChecks - 3 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 335751653 * blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount + 3.54015750689739E14 == 0
DataNode.instance.id.infoPort == 45215
DataNode.instance.id.ipcPort == 38063
DataNode.instance.id.nsInfo.cTime == 1731381618617L
DataNode.instance.id.nsInfo.namespaceID == 2130110033
DataNode.instance.id.xferPort == 39073
DataNode.instance.lastDiskErrorCheck == 117728583
DataNode.instance.storage.layoutVersion == -57 || DataNode.instance.storage.layoutVersion == 0
DataNode.instance.storage.namespaceID == 0 || DataNode.instance.storage.namespaceID == 2130110033
DataNode.instance.volumeChecker.lastAllVolumesCheck == 116827492 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 117728578
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 117727498
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 117727461
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 117725227
NameNode.instance.namesystem.snapshotManager.numSnapshots == 0 || NameNode.instance.namesystem.snapshotManager.numSnapshots == 1
NameNode.instance.namesystem.snapshotManager.snapshotCounter == 0 || NameNode.instance.namesystem.snapshotManager.snapshotCounter == 1 || NameNode.instance.namesystem.snapshotManager.snapshotCounter == 2
daikon.Quant.eltsNotEqual(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE, null)
NameNode.instance.namesystem.startTime == 1731381620319L
blockManagerInstance.blockReportLeaseManager.nextId == 2204254071460023363L || blockManagerInstance.blockReportLeaseManager.nextId == 2204254071460023364L
blockManagerInstance.bmSafeMode.startTime == 0 || blockManagerInstance.bmSafeMode.startTime == 117726205
blockManagerInstance.heartbeatManager.stats.capacityRemaining >= 0
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs >= 0
blockManagerInstance.invalidateBlocks.startupTime == 117725231
blockManagerInstance.lastRedundancyCycleTS >= -1
blockManagerInstance.replQueueCallsSinceReset >= 0
daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE) == 0 || daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE) == 1
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT > DataNode.instance.storage.layoutVersion
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < DataNode.instance.storage.namespaceID
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT <= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)-1
DataNode.instance.NUM_CORES > DataNode.instance.storage.layoutVersion
DataNode.instance.NUM_CORES < DataNode.instance.storage.namespaceID
DataNode.instance.NUM_CORES > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.NUM_CORES > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.NUM_CORES > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs > DataNode.instance.storage.layoutVersion
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs < DataNode.instance.storage.namespaceID
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION > DataNode.instance.storage.layoutVersion
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < DataNode.instance.storage.namespaceID
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME > DataNode.instance.storage.layoutVersion
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < DataNode.instance.storage.namespaceID
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME >= NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME > DataNode.instance.storage.layoutVersion
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < DataNode.instance.storage.namespaceID
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS > DataNode.instance.storage.layoutVersion
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS < DataNode.instance.storage.namespaceID
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS > DataNode.instance.storage.layoutVersion
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS < DataNode.instance.storage.namespaceID
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.numDeletedBlocks > DataNode.instance.storage.layoutVersion
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.storage.namespaceID
DataNode.instance.data.asyncDiskService.numDeletedBlocks <= NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.data.asyncDiskService.numDeletedBlocks <= NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.data.asyncDiskService.numDeletedBlocks <= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.numDeletedBlocks >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)-1
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME > DataNode.instance.storage.layoutVersion
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME < DataNode.instance.storage.namespaceID
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME >= NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS > DataNode.instance.storage.layoutVersion
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS < DataNode.instance.storage.namespaceID
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.data.cacheManager.numBlocksCached > DataNode.instance.storage.layoutVersion
DataNode.instance.data.cacheManager.numBlocksCached < DataNode.instance.storage.namespaceID
DataNode.instance.data.cacheManager.numBlocksCached <= NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.data.cacheManager.numBlocksCached <= NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.data.cacheManager.numBlocksCached <= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.data.cacheManager.numBlocksCached >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)-1
DataNode.instance.data.cacheManager.revocationMs > DataNode.instance.storage.layoutVersion
DataNode.instance.data.cacheManager.revocationMs < DataNode.instance.storage.namespaceID
DataNode.instance.data.cacheManager.revocationMs > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.data.cacheManager.revocationMs > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.data.cacheManager.revocationMs > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.data.cacheManager.revocationPollingMs > DataNode.instance.storage.layoutVersion
DataNode.instance.data.cacheManager.revocationPollingMs < DataNode.instance.storage.namespaceID
DataNode.instance.data.cacheManager.revocationPollingMs > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.data.cacheManager.revocationPollingMs > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.data.cacheManager.revocationPollingMs > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.data.maxDataLength > DataNode.instance.storage.layoutVersion
DataNode.instance.data.maxDataLength < DataNode.instance.storage.namespaceID
DataNode.instance.data.maxDataLength > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.data.maxDataLength > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.data.maxDataLength > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.data.smallBufferSize > DataNode.instance.storage.layoutVersion
DataNode.instance.data.smallBufferSize < DataNode.instance.storage.namespaceID
DataNode.instance.data.smallBufferSize > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.data.smallBufferSize > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.data.smallBufferSize > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.data.volsConfigured > DataNode.instance.storage.layoutVersion
DataNode.instance.data.volsConfigured < DataNode.instance.storage.namespaceID
DataNode.instance.data.volsConfigured > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.data.volsConfigured >= NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.data.volsConfigured > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.directoryScanner.MILLIS_PER_SECOND > DataNode.instance.storage.layoutVersion
DataNode.instance.directoryScanner.MILLIS_PER_SECOND < DataNode.instance.storage.namespaceID
DataNode.instance.directoryScanner.MILLIS_PER_SECOND > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.directoryScanner.MILLIS_PER_SECOND > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.directoryScanner.MILLIS_PER_SECOND > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.directoryScanner.scanPeriodMsecs > DataNode.instance.storage.layoutVersion
DataNode.instance.directoryScanner.scanPeriodMsecs < DataNode.instance.storage.namespaceID
DataNode.instance.directoryScanner.scanPeriodMsecs > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.directoryScanner.scanPeriodMsecs > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.directoryScanner.scanPeriodMsecs > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.diskBalancer.bandwidth > DataNode.instance.storage.layoutVersion
DataNode.instance.diskBalancer.bandwidth < DataNode.instance.storage.namespaceID
DataNode.instance.diskBalancer.bandwidth > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.diskBalancer.bandwidth > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.diskBalancer.bandwidth > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.diskBalancer.planValidityInterval > DataNode.instance.storage.layoutVersion
DataNode.instance.diskBalancer.planValidityInterval < DataNode.instance.storage.namespaceID
DataNode.instance.diskBalancer.planValidityInterval > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.diskBalancer.planValidityInterval > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.diskBalancer.planValidityInterval > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.blockReportInterval > DataNode.instance.storage.layoutVersion
DataNode.instance.dnConf.blockReportInterval != DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.blockReportInterval > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.dnConf.blockReportInterval > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.dnConf.blockReportInterval > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.blockReportSplitThreshold > DataNode.instance.storage.layoutVersion
DataNode.instance.dnConf.blockReportSplitThreshold != DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.blockReportSplitThreshold > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.dnConf.blockReportSplitThreshold > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.dnConf.blockReportSplitThreshold > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.bpReadyTimeout > DataNode.instance.storage.layoutVersion
DataNode.instance.dnConf.bpReadyTimeout != DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.bpReadyTimeout > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.dnConf.bpReadyTimeout > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.dnConf.bpReadyTimeout > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.cacheReportInterval > DataNode.instance.storage.layoutVersion
DataNode.instance.dnConf.cacheReportInterval != DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.cacheReportInterval > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.dnConf.cacheReportInterval > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.dnConf.cacheReportInterval > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs > DataNode.instance.storage.layoutVersion
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs != DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.heartBeatInterval > DataNode.instance.storage.layoutVersion
DataNode.instance.dnConf.heartBeatInterval != DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.heartBeatInterval > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.dnConf.heartBeatInterval > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.dnConf.heartBeatInterval > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.ibrInterval >= DataNode.instance.storage.layoutVersion
DataNode.instance.dnConf.ibrInterval <= DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.ibrInterval <= NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.dnConf.ibrInterval <= NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.dnConf.ibrInterval <= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.ibrInterval >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)-1
DataNode.instance.dnConf.lifelineIntervalMs > DataNode.instance.storage.layoutVersion
DataNode.instance.dnConf.lifelineIntervalMs != DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.lifelineIntervalMs > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.dnConf.lifelineIntervalMs > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.dnConf.lifelineIntervalMs > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.maxDataLength > DataNode.instance.storage.layoutVersion
DataNode.instance.dnConf.maxDataLength != DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.maxDataLength > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.dnConf.maxDataLength > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.dnConf.maxDataLength > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.outliersReportIntervalMs > DataNode.instance.storage.layoutVersion
DataNode.instance.dnConf.outliersReportIntervalMs != DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.outliersReportIntervalMs > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.dnConf.outliersReportIntervalMs > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.dnConf.outliersReportIntervalMs > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.readaheadLength > DataNode.instance.storage.layoutVersion
DataNode.instance.dnConf.readaheadLength != DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.readaheadLength > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.dnConf.readaheadLength > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.dnConf.readaheadLength > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.restartReplicaExpiry > DataNode.instance.storage.layoutVersion
DataNode.instance.dnConf.restartReplicaExpiry != DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.restartReplicaExpiry > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.dnConf.restartReplicaExpiry > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.dnConf.restartReplicaExpiry > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.socketKeepaliveTimeout > DataNode.instance.storage.layoutVersion
DataNode.instance.dnConf.socketKeepaliveTimeout != DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.socketKeepaliveTimeout > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.dnConf.socketKeepaliveTimeout > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.dnConf.socketKeepaliveTimeout > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.socketTimeout > DataNode.instance.storage.layoutVersion
DataNode.instance.dnConf.socketTimeout != DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.socketTimeout > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.dnConf.socketTimeout > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.dnConf.socketTimeout > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.socketWriteTimeout > DataNode.instance.storage.layoutVersion
DataNode.instance.dnConf.socketWriteTimeout != DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.socketWriteTimeout > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.dnConf.socketWriteTimeout > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.dnConf.socketWriteTimeout > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.volsConfigured > DataNode.instance.storage.layoutVersion
DataNode.instance.dnConf.volsConfigured != DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.volsConfigured > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.dnConf.volsConfigured >= NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.dnConf.volsConfigured > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS > DataNode.instance.storage.layoutVersion
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS != DataNode.instance.storage.namespaceID
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS >= NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.httpServer.HTTP_MAX_THREADS > DataNode.instance.storage.layoutVersion
DataNode.instance.httpServer.HTTP_MAX_THREADS != DataNode.instance.storage.namespaceID
DataNode.instance.httpServer.HTTP_MAX_THREADS > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.httpServer.HTTP_MAX_THREADS > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.httpServer.HTTP_MAX_THREADS > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.id.infoPort > DataNode.instance.storage.layoutVersion
DataNode.instance.id.infoPort < DataNode.instance.storage.namespaceID
DataNode.instance.id.infoPort > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.id.infoPort > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.id.infoPort > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.id.ipcPort > DataNode.instance.storage.layoutVersion
DataNode.instance.id.ipcPort < DataNode.instance.storage.namespaceID
DataNode.instance.id.ipcPort > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.id.ipcPort > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.id.ipcPort > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.id.nsInfo.cTime > DataNode.instance.storage.layoutVersion
DataNode.instance.id.nsInfo.cTime > DataNode.instance.storage.namespaceID
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.id.nsInfo.cTime > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.id.nsInfo.layoutVersion < DataNode.instance.storage.layoutVersion
DataNode.instance.id.nsInfo.layoutVersion < DataNode.instance.storage.namespaceID
DataNode.instance.id.nsInfo.layoutVersion < NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.id.nsInfo.layoutVersion < NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.id.nsInfo.layoutVersion < daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)-1
DataNode.instance.id.nsInfo.namespaceID > DataNode.instance.storage.layoutVersion
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.id.nsInfo.namespaceID > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.id.xferPort > DataNode.instance.storage.layoutVersion
DataNode.instance.id.xferPort < DataNode.instance.storage.namespaceID
DataNode.instance.id.xferPort > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.id.xferPort > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.id.xferPort > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.lastDiskErrorCheck > DataNode.instance.storage.layoutVersion
DataNode.instance.lastDiskErrorCheck < DataNode.instance.storage.namespaceID
DataNode.instance.lastDiskErrorCheck > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.lastDiskErrorCheck > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.lastDiskErrorCheck > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.shortCircuitRegistry.SHM_LENGTH > DataNode.instance.storage.layoutVersion
DataNode.instance.shortCircuitRegistry.SHM_LENGTH < DataNode.instance.storage.namespaceID
DataNode.instance.shortCircuitRegistry.SHM_LENGTH > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.shortCircuitRegistry.SHM_LENGTH > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.shortCircuitRegistry.SHM_LENGTH > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.storage.layoutVersion <= DataNode.instance.storage.namespaceID
DataNode.instance.storage.layoutVersion < DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks
DataNode.instance.storage.layoutVersion < DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout
DataNode.instance.storage.layoutVersion <= DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.storage.layoutVersion < DataNode.instance.xserver.balanceThrottler.bytesPerPeriod
DataNode.instance.storage.layoutVersion < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.storage.layoutVersion < DataNode.instance.xserver.balanceThrottler.maxThreads
DataNode.instance.storage.layoutVersion < DataNode.instance.xserver.balanceThrottler.period
DataNode.instance.storage.layoutVersion < DataNode.instance.xserver.balanceThrottler.periodExtension
DataNode.instance.storage.layoutVersion < DataNode.instance.xserver.estimateBlockSize
DataNode.instance.storage.layoutVersion < DataNode.instance.xserver.maxXceiverCount
DataNode.instance.storage.layoutVersion < NameNode.instance.DEFAULT_PORT
DataNode.instance.storage.layoutVersion < NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.storage.layoutVersion > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.blockDeletionIncrement
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.cacheManager.scanIntervalMs
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.dir.inodeXAttrsLimit
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.dir.maxComponentLength
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.dir.maxDirItems
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.dir.xattrMaxSize
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.editLogRollerThreshold
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.leaseManager.hardLimit
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.leaseRecheckIntervalMs
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.nnResourceChecker.duReserved
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit
DataNode.instance.storage.layoutVersion <= NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.storage.layoutVersion <= NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.startTime
DataNode.instance.storage.layoutVersion < blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
DataNode.instance.storage.layoutVersion < blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
DataNode.instance.storage.layoutVersion < blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP
DataNode.instance.storage.layoutVersion <= blockManagerInstance.blockIdManager.legacyGenerationStampLimit
DataNode.instance.storage.layoutVersion < blockManagerInstance.blockReportLeaseManager.leaseExpiryMs
DataNode.instance.storage.layoutVersion < blockManagerInstance.blockReportLeaseManager.maxPending
DataNode.instance.storage.layoutVersion < blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS
DataNode.instance.storage.layoutVersion < blockManagerInstance.blocksMap.capacity
DataNode.instance.storage.layoutVersion < blockManagerInstance.blocksPerPostpondedRescan
DataNode.instance.storage.layoutVersion < blockManagerInstance.blocksReplWorkMultiplier
DataNode.instance.storage.layoutVersion > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size
DataNode.instance.storage.layoutVersion < blockManagerInstance.bmSafeMode.safeReplication
DataNode.instance.storage.layoutVersion < blockManagerInstance.datanodeManager.defaultInfoPort
DataNode.instance.storage.layoutVersion < blockManagerInstance.datanodeManager.defaultInfoSecurePort
DataNode.instance.storage.layoutVersion < blockManagerInstance.datanodeManager.defaultIpcPort
DataNode.instance.storage.layoutVersion < blockManagerInstance.datanodeManager.defaultXferPort
DataNode.instance.storage.layoutVersion < blockManagerInstance.datanodeManager.heartbeatExpireInterval
DataNode.instance.storage.layoutVersion < blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
DataNode.instance.storage.layoutVersion < blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE
DataNode.instance.storage.layoutVersion < blockManagerInstance.datanodeManager.staleInterval
DataNode.instance.storage.layoutVersion <= blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.storage.layoutVersion <= blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.storage.layoutVersion <= blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.storage.layoutVersion <= blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.storage.layoutVersion <= blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.storage.layoutVersion < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.storage.layoutVersion != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.storage.layoutVersion < blockManagerInstance.maxCorruptFilesReturned
DataNode.instance.storage.layoutVersion < blockManagerInstance.neededReconstruction.LEVEL
DataNode.instance.storage.layoutVersion < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
DataNode.instance.storage.layoutVersion < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
DataNode.instance.storage.layoutVersion < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
DataNode.instance.storage.layoutVersion < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
DataNode.instance.storage.layoutVersion < blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
DataNode.instance.storage.layoutVersion <= blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.storage.layoutVersion < blockManagerInstance.replQueueResetToHeadThreshold
DataNode.instance.storage.layoutVersion < blockManagerInstance.storageInfoDefragmentInterval
DataNode.instance.storage.layoutVersion < blockManagerInstance.storagePolicySuite.defaultPolicyID
DataNode.instance.storage.layoutVersion != daikon.Quant.size(DataNode.instance.directoryScanner.diffs_FOR_ENCLOSING_USE)-1
DataNode.instance.storage.layoutVersion <= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.storage.layoutVersion != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
DataNode.instance.storage.layoutVersion <= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.storage.layoutVersion != daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)-1
DataNode.instance.storage.namespaceID != DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks
DataNode.instance.storage.namespaceID != DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout
DataNode.instance.storage.namespaceID != DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.storage.namespaceID >= DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.storage.namespaceID != DataNode.instance.xserver.balanceThrottler.bytesPerPeriod
DataNode.instance.storage.namespaceID != DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.storage.namespaceID != DataNode.instance.xserver.balanceThrottler.maxThreads
DataNode.instance.storage.namespaceID != DataNode.instance.xserver.balanceThrottler.period
DataNode.instance.storage.namespaceID != DataNode.instance.xserver.balanceThrottler.periodExtension
DataNode.instance.storage.namespaceID != DataNode.instance.xserver.estimateBlockSize
DataNode.instance.storage.namespaceID != DataNode.instance.xserver.maxXceiverCount
DataNode.instance.storage.namespaceID != NameNode.instance.DEFAULT_PORT
DataNode.instance.storage.namespaceID != NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.blockDeletionIncrement
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.cacheManager.scanIntervalMs
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.dir.inodeXAttrsLimit
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.dir.maxComponentLength
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.dir.maxDirItems
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.dir.xattrMaxSize
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.editLogRollerThreshold
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.leaseManager.hardLimit
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.leaseRecheckIntervalMs
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.nnResourceChecker.duReserved
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit
DataNode.instance.storage.namespaceID >= NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.storage.namespaceID >= NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.storage.namespaceID < NameNode.instance.namesystem.startTime
DataNode.instance.storage.namespaceID != blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
DataNode.instance.storage.namespaceID != blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
DataNode.instance.storage.namespaceID != blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP
DataNode.instance.storage.namespaceID >= blockManagerInstance.blockIdManager.legacyGenerationStampLimit
DataNode.instance.storage.namespaceID != blockManagerInstance.blockReportLeaseManager.leaseExpiryMs
DataNode.instance.storage.namespaceID != blockManagerInstance.blockReportLeaseManager.maxPending
DataNode.instance.storage.namespaceID != blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS
DataNode.instance.storage.namespaceID != blockManagerInstance.blocksMap.capacity
DataNode.instance.storage.namespaceID != blockManagerInstance.blocksPerPostpondedRescan
DataNode.instance.storage.namespaceID != blockManagerInstance.blocksReplWorkMultiplier
DataNode.instance.storage.namespaceID != blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.storage.namespaceID > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size
DataNode.instance.storage.namespaceID != blockManagerInstance.bmSafeMode.safeReplication
DataNode.instance.storage.namespaceID != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.storage.namespaceID != blockManagerInstance.datanodeManager.defaultInfoPort
DataNode.instance.storage.namespaceID != blockManagerInstance.datanodeManager.defaultInfoSecurePort
DataNode.instance.storage.namespaceID != blockManagerInstance.datanodeManager.defaultIpcPort
DataNode.instance.storage.namespaceID != blockManagerInstance.datanodeManager.defaultXferPort
DataNode.instance.storage.namespaceID != blockManagerInstance.datanodeManager.heartbeatExpireInterval
DataNode.instance.storage.namespaceID != blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
DataNode.instance.storage.namespaceID != blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE
DataNode.instance.storage.namespaceID != blockManagerInstance.datanodeManager.staleInterval
DataNode.instance.storage.namespaceID >= blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.storage.namespaceID >= blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.storage.namespaceID != blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.storage.namespaceID != blockManagerInstance.maxCorruptFilesReturned
DataNode.instance.storage.namespaceID != blockManagerInstance.neededReconstruction.LEVEL
DataNode.instance.storage.namespaceID != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
DataNode.instance.storage.namespaceID != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
DataNode.instance.storage.namespaceID != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
DataNode.instance.storage.namespaceID != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
DataNode.instance.storage.namespaceID != blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
DataNode.instance.storage.namespaceID >= blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.storage.namespaceID != blockManagerInstance.replQueueResetToHeadThreshold
DataNode.instance.storage.namespaceID != blockManagerInstance.storageInfoDefragmentInterval
DataNode.instance.storage.namespaceID != blockManagerInstance.storagePolicySuite.defaultPolicyID
DataNode.instance.storage.namespaceID >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.storage.namespaceID >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.storage.namespaceID != daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
DataNode.instance.storage.namespaceID != daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.volumeChecker.lastAllVolumesCheck > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.volumeChecker.numSyncDatasetChecks >= NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.volumeChecker.numSyncDatasetChecks >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.xserver.balanceThrottler.curPeriodStart > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.maxThreads > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.xserver.balanceThrottler.maxThreads > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.xserver.balanceThrottler.maxThreads > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.period > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.xserver.balanceThrottler.period > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.xserver.balanceThrottler.period > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.periodExtension > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.xserver.balanceThrottler.periodExtension > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.xserver.balanceThrottler.periodExtension > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.xserver.estimateBlockSize > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.xserver.estimateBlockSize > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.xserver.estimateBlockSize > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.xserver.maxXceiverCount > NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.xserver.maxXceiverCount > NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.xserver.maxXceiverCount > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.DEFAULT_PORT > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.DEFAULT_PORT > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.DEFAULT_PORT > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)-1
NameNode.instance.namesystem.blockDeletionIncrement > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.blockDeletionIncrement > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.blockDeletionIncrement > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
daikon.Quant.subsetOf(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE, NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.cacheManager.scanIntervalMs > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.cacheManager.scanIntervalMs > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.cacheManager.scanIntervalMs > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.dir.inodeXAttrsLimit > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.dir.inodeXAttrsLimit > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.dir.inodeXAttrsLimit > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.dir.maxComponentLength > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.dir.maxComponentLength > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.dir.maxComponentLength > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.dir.maxDirItems > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.dir.maxDirItems > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.dir.maxDirItems > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.dir.xattrMaxSize > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.dir.xattrMaxSize > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.dir.xattrMaxSize > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.editLogRollerThreshold > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.editLogRollerThreshold > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.editLogRollerThreshold > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.lazyPersistFileScrubberTS > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.lazyPersistFileScrubberTS > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.lazyPersistFileScrubberTS > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.leaseManager.hardLimit > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.leaseManager.hardLimit > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.leaseManager.hardLimit > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.leaseRecheckIntervalMs > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.leaseRecheckIntervalMs > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.leaseRecheckIntervalMs > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.nnResourceChecker.duReserved > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.nnResourceChecker.duReserved > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.nnResourceChecker.duReserved > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit > NameNode.instance.namesystem.snapshotManager.numSnapshots
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit > NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.snapshotManager.numSnapshots <= NameNode.instance.namesystem.snapshotManager.snapshotCounter
NameNode.instance.namesystem.snapshotManager.numSnapshots < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP
NameNode.instance.namesystem.snapshotManager.numSnapshots >= blockManagerInstance.blockIdManager.legacyGenerationStampLimit
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.blockReportLeaseManager.leaseExpiryMs
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.blockReportLeaseManager.maxPending
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.blocksMap.capacity
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.blocksPerPostpondedRescan
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.blocksReplWorkMultiplier
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.snapshotManager.numSnapshots > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size
NameNode.instance.namesystem.snapshotManager.numSnapshots <= blockManagerInstance.bmSafeMode.safeReplication
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.datanodeManager.defaultInfoPort
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.datanodeManager.defaultInfoSecurePort
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.datanodeManager.defaultIpcPort
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.datanodeManager.defaultXferPort
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.datanodeManager.heartbeatExpireInterval
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.datanodeManager.staleInterval
NameNode.instance.namesystem.snapshotManager.numSnapshots <= blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.snapshotManager.numSnapshots <= blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.snapshotManager.numSnapshots <= blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.snapshotManager.numSnapshots <= blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.snapshotManager.numSnapshots <= blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.snapshotManager.numSnapshots != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.maxCorruptFilesReturned
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.neededReconstruction.LEVEL
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
NameNode.instance.namesystem.snapshotManager.numSnapshots <= blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.replQueueResetToHeadThreshold
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.storageInfoDefragmentInterval
NameNode.instance.namesystem.snapshotManager.numSnapshots < blockManagerInstance.storagePolicySuite.defaultPolicyID
NameNode.instance.namesystem.snapshotManager.numSnapshots >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
NameNode.instance.namesystem.snapshotManager.numSnapshots <= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.snapshotManager.numSnapshots >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)-1
NameNode.instance.namesystem.snapshotManager.numSnapshots < daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
NameNode.instance.namesystem.snapshotManager.snapshotCounter < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP
NameNode.instance.namesystem.snapshotManager.snapshotCounter >= blockManagerInstance.blockIdManager.legacyGenerationStampLimit
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.blockReportLeaseManager.leaseExpiryMs
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.blockReportLeaseManager.maxPending
NameNode.instance.namesystem.snapshotManager.snapshotCounter - 2 * blockManagerInstance.blockReportLeaseManager.nextId + 2147483647 == 0
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.blocksMap.capacity
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.blocksPerPostpondedRescan
NameNode.instance.namesystem.snapshotManager.snapshotCounter <= blockManagerInstance.blocksReplWorkMultiplier
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.snapshotManager.snapshotCounter > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.datanodeManager.defaultInfoPort
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.datanodeManager.defaultInfoSecurePort
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.datanodeManager.defaultIpcPort
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.datanodeManager.defaultXferPort
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.datanodeManager.heartbeatExpireInterval
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.datanodeManager.staleInterval
NameNode.instance.namesystem.snapshotManager.snapshotCounter <= blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.snapshotManager.snapshotCounter <= blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.snapshotManager.snapshotCounter <= blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.snapshotManager.snapshotCounter <= blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.snapshotManager.snapshotCounter != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.maxCorruptFilesReturned
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.neededReconstruction.LEVEL
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
NameNode.instance.namesystem.snapshotManager.snapshotCounter <= blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.replQueueResetToHeadThreshold
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.storageInfoDefragmentInterval
NameNode.instance.namesystem.snapshotManager.snapshotCounter < blockManagerInstance.storagePolicySuite.defaultPolicyID
NameNode.instance.namesystem.snapshotManager.snapshotCounter >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
NameNode.instance.namesystem.snapshotManager.snapshotCounter >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)-1
NameNode.instance.namesystem.snapshotManager.snapshotCounter <= daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
NameNode.instance.namesystem.startTime > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.blockIdManager.legacyGenerationStampLimit <= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.blockIdManager.legacyGenerationStampLimit >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)-1
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.blockReportLeaseManager.maxPending > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.blockReportLeaseManager.nextId > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.blocksMap.capacity > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.blocksPerPostpondedRescan > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.blocksReplWorkMultiplier > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size < daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)-1
blockManagerInstance.bmSafeMode.safeReplication >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.bmSafeMode.startTime >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.defaultInfoPort > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.defaultInfoSecurePort > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.defaultIpcPort > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.defaultXferPort > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.heartbeatExpireInterval > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.staleInterval > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.blockPoolUsed >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.capacityRemaining >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.capacityTotal >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.nodesInService >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.invalidateBlocks.startupTime > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.lastRedundancyCycleTS >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
blockManagerInstance.lastRedundancyCycleTS != daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.lastRedundancyCycleTS >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)-1
blockManagerInstance.maxCorruptFilesReturned > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.neededReconstruction.LEVEL >= blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.neededReconstruction.LEVEL > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.replQueueCallsSinceReset >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.replQueueCallsSinceReset >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.replQueueResetToHeadThreshold > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.storageInfoDefragmentInterval > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
blockManagerInstance.storagePolicySuite.defaultPolicyID > daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
daikon.Quant.size(DataNode.instance.directoryScanner.diffs_FOR_ENCLOSING_USE)-1 <= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)-1
daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) >= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)-1
daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 <= daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE) <= daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE) != daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)-1 <= daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
24576 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 622803899 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 2.1928618647552E13 * blockManagerInstance.replQueueCallsSinceReset - 2.8932700864539771E18 == 0
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 1245607798 * blockManagerInstance.heartbeatManager.stats.nodesInService - 892277777 * blockManagerInstance.replQueueCallsSinceReset - 1.17727461200113E14 == 0
NameNode.instance.namesystem.snapshotManager.snapshotCounter - 2 * blockManagerInstance.blockReportLeaseManager.nextId + 2 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) + 4.4085081429200466E18 == 0
NameNode.instance.namesystem.snapshotManager.snapshotCounter - 2 * blockManagerInstance.blockReportLeaseManager.nextId + 2 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 + 4.4085081429200466E18 == 0
NameNode.instance.namesystem.snapshotManager.snapshotCounter - blockManagerInstance.blockReportLeaseManager.nextId + daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE) + 2.2042540714600233E18 == 0
NameNode.instance.namesystem.snapshotManager.snapshotCounter - blockManagerInstance.blockReportLeaseManager.nextId + daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)-1 + 2.2042540714600233E18 == 0
2 * blockManagerInstance.blockReportLeaseManager.nextId - blockManagerInstance.replQueueCallsSinceReset - daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) - 4.4085081429200466E18 == 0
2 * blockManagerInstance.blockReportLeaseManager.nextId - blockManagerInstance.replQueueCallsSinceReset - daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 - 4.4085081429200466E18 == 0
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds == blockManagerInstance.defaultReplication
DataNode.instance.id.infoPort == 43101
DataNode.instance.id.ipcPort == 34749
DataNode.instance.id.nsInfo.cTime == 1731381922825L
DataNode.instance.id.nsInfo.namespaceID == 105713751
DataNode.instance.id.xferPort == 38711
DataNode.instance.lastDiskErrorCheck == 118032054
DataNode.instance.storage.namespaceID == 105713751
DataNode.instance.volumeChecker.lastAllVolumesCheck == 117131421 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 118032046
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118031422
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118030042
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118029376
NameNode.instance.namesystem.startTime == 1731381924468L
blockManagerInstance.blockReportLeaseManager.nextId == -6357840607064050409L || blockManagerInstance.blockReportLeaseManager.nextId == -6357840607064050406L
blockManagerInstance.bmSafeMode.startTime == 0 || blockManagerInstance.bmSafeMode.startTime == 118030005
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 0 || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 280558460928L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 0 || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 101126111232L
blockManagerInstance.invalidateBlocks.startupTime == 118029378
blockManagerInstance.lastRedundancyCycleTS == -1 || blockManagerInstance.lastRedundancyCycleTS == 118033008 || blockManagerInstance.lastRedundancyCycleTS == 118036008
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.NUM_CORES > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.asyncDiskService.numDeletedBlocks > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.cacheManager.numBlocksCached > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.cacheManager.revocationMs > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.cacheManager.revocationPollingMs > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.maxDataLength > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.smallBufferSize > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.volsConfigured > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.directoryScanner.MILLIS_PER_SECOND > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.directoryScanner.diffs.serialVersionUID > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.directoryScanner.diffs.serialVersionUID != blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.directoryScanner.diffs.serialVersionUID >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.directoryScanner.scanPeriodMsecs > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.diskBalancer.bandwidth > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.diskBalancer.planValidityInterval > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.blockReportInterval > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.blockReportSplitThreshold > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.bpReadyTimeout > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.cacheReportInterval > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.heartBeatInterval > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.ibrInterval > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.lifelineIntervalMs > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.maxDataLength > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.outliersReportIntervalMs > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.readaheadLength > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.restartReplicaExpiry > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.socketKeepaliveTimeout > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.socketTimeout > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.socketWriteTimeout > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.volsConfigured > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.httpServer.HTTP_MAX_THREADS > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.id.infoPort > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.id.ipcPort > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.id.nsInfo.layoutVersion > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.id.nsInfo.namespaceID < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.id.nsInfo.namespaceID < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.id.nsInfo.namespaceID != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.id.xferPort > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.lastDiskErrorCheck > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.shortCircuitRegistry.SHM_LENGTH > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.storage.layoutVersion > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.storage.namespaceID < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.storage.namespaceID > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.storage.namespaceID < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.storage.namespaceID != blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.volumeChecker.numSyncDatasetChecks > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.balanceThrottler.maxThreads > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.balanceThrottler.period > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.balanceThrottler.periodExtension > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.estimateBlockSize > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.maxXceiverCount > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.DEFAULT_PORT > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.blockDeletionIncrement > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.cacheManager.scanIntervalMs > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.dir.inodeXAttrsLimit > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.dir.maxComponentLength > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.dir.maxDirItems > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.dir.xattrMaxSize > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.editLogRollerThreshold > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.leaseManager.hardLimit > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.leaseRecheckIntervalMs > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.nnResourceChecker.duReserved > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.startTime > blockManagerInstance.blockReportLeaseManager.nextId
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER > blockManagerInstance.blockReportLeaseManager.nextId
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID > blockManagerInstance.blockReportLeaseManager.nextId
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP > blockManagerInstance.blockReportLeaseManager.nextId
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs > blockManagerInstance.blockReportLeaseManager.nextId
blockManagerInstance.blockReportLeaseManager.maxPending > blockManagerInstance.blockReportLeaseManager.nextId
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.blocksMap.capacity
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.blocksPerPostpondedRescan
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.blocksReplWorkMultiplier
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.bmSafeMode.safeReplication
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.bmSafeMode.startTime
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.datanodeManager.defaultInfoPort
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.datanodeManager.defaultInfoSecurePort
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.datanodeManager.defaultIpcPort
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.datanodeManager.defaultXferPort
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.datanodeManager.heartbeatExpireInterval
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.datanodeManager.staleInterval
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.maxCorruptFilesReturned
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.storageInfoDefragmentInterval
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.blockReportLeaseManager.nextId < daikon.Quant.size(DataNode.instance.directoryScanner.diffs_FOR_ENCLOSING_USE)-1
blockManagerInstance.blockReportLeaseManager.nextId < daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
blockManagerInstance.blockReportLeaseManager.nextId < daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
2000600956 * DataNode.instance.volumeChecker.numSyncDatasetChecks - NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 75362502 * blockManagerInstance.heartbeatManager.stats.nodesInService + 1.1803004233723E14 == 0
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT == blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT == daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)-1
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT == daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT == daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)-1
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs == NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs == NameNode.instance.namesystem.dir.contentCountLimit
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs == NameNode.instance.namesystem.fsImage.LOAD_EDIT_LOG_INTERVAL_MS
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs == NameNode.instance.namesystem.fsLock.readLockReportingThresholdMs
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs == NameNode.instance.namesystem.fsLock.writeLockReportingThresholdMs
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs == NameNode.instance.namesystem.resourceRecheckInterval
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.data.isNativeIOAvailable
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.dnConf.connectToDnViaHostname
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.dnConf.diskStatsEnabled
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.dnConf.dropCacheBehindReads
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.dnConf.dropCacheBehindWrites
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.dnConf.encryptDataTransfer
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.dnConf.ignoreSecurePortsForTesting
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.dnConf.overwriteDownstreamDerivedQOP
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.dnConf.peerStatsEnabled
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.dnConf.syncBehindWrites
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.dnConf.syncBehindWritesInBackground
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.dnConf.syncOnClose
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.fileIoProvider.faultInjectorEventHook.isEnabled
DataNode.instance.cacheReportsDisabledForTests == DataNode.instance.xserver.closed
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.STANDBY_STATE.isObserver
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.allowStaleStandbyReads
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.haEnabled
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.namesystem.alwaysUseDelegationTokensForTests
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.namesystem.datanodeStatistics.enableLogStaleNodes
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.namesystem.dir.aclsEnabled
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.namesystem.dir.isPermissionContentSummarySubAccess
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.namesystem.dir.skipQuotaCheck
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.namesystem.dtpReplaceDatanodeOnFailure.bestEffort
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.namesystem.fsImage.exitAfterSave
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.namesystem.fsLock.metricsEnabled
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.namesystem.haEnabled
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.namesystem.isDefaultAuditLogger
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.namesystem.manualSafeMode
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.namesystem.needRollbackFsImage
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.namesystem.resourceLowSafeMode
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.namesystem.snapshotManager.allowNestedSnapshots
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.namesystem.snapshotManager.captureOpenFiles
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.namesystem.snapshotManager.skipCaptureAccessTimeOnlyChange
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.namesystem.startingActiveService
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.rpcServer.serviceAuthEnabled
DataNode.instance.cacheReportsDisabledForTests == NameNode.instance.stopRequested
DataNode.instance.cacheReportsDisabledForTests == blockManagerInstance.bmSafeMode.inRollBack
DataNode.instance.cacheReportsDisabledForTests == blockManagerInstance.datanodeManager.avoidStaleDataNodesForRead
DataNode.instance.cacheReportsDisabledForTests == blockManagerInstance.datanodeManager.avoidStaleDataNodesForWrite
DataNode.instance.cacheReportsDisabledForTests == blockManagerInstance.datanodeManager.dataNodeDiskStatsEnabled
DataNode.instance.cacheReportsDisabledForTests == blockManagerInstance.datanodeManager.dataNodePeerStatsEnabled
DataNode.instance.cacheReportsDisabledForTests == blockManagerInstance.datanodeManager.hasClusterEverBeenMultiRack
DataNode.instance.cacheReportsDisabledForTests == blockManagerInstance.datanodeManager.heartbeatManager.enableLogStaleNodes
DataNode.instance.cacheReportsDisabledForTests == blockManagerInstance.datanodeManager.rejectUnresolvedTopologyDN
DataNode.instance.cacheReportsDisabledForTests == blockManagerInstance.encryptDataTransfer
DataNode.instance.cacheReportsDisabledForTests == blockManagerInstance.hasNonEcBlockUsingStripedID
DataNode.instance.cacheReportsDisabledForTests == blockManagerInstance.heartbeatManager.enableLogStaleNodes
DataNode.instance.cacheReportsDisabledForTests == blockManagerInstance.providedStorageMap.providedEnabled
DataNode.instance.cacheReportsDisabledForTests == blockManagerInstance.shouldPostponeBlocksFromFuture
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION == blockManagerInstance.neededReconstruction.QUEUE_REPLICAS_BADLY_DISTRIBUTED
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION == blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.shrinkThreshold
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == DataNode.instance.data.asyncLazyPersistService.MAXIMUM_THREADS_PER_VOLUME
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == DataNode.instance.httpServer.HTTP_SELECTOR_THREADS
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.sequenceNumber
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == NameNode.instance.namesystem.cacheManager.nextDirectiveId
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == NameNode.instance.namesystem.nnResourceChecker.minimumRedundantVolumes
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == blockManagerInstance.neededReconstruction.QUEUE_VERY_LOW_REDUNDANCY
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == NameNode.instance.namesystem.dir.quotaInitThreads
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_COUNT_MAX
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == blockManagerInstance.neededReconstruction.QUEUE_WITH_CORRUPT_BLOCKS
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == blockManagerInstance.placementPolicies.ecPolicy.tolerateHeartbeatMultiplier
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == blockManagerInstance.placementPolicies.replicationPolicy.tolerateHeartbeatMultiplier
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == blockManagerInstance.replicationStreamsHardLimit
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == blockManagerInstance.storageInfoDefragmentTimeout
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == blockManagerInstance.storagePolicySuite.ID_BIT_LENGTH
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.data.cacheManager.numBlocksFailedToCache
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.data.volFailuresTolerated
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.dnConf.initialBlockReportDelayMs
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.dnConf.maxLockedMemory
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.dnConf.transferSocketRecvBufferSize
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.dnConf.transferSocketSendBufferSize
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.dnConf.volFailuresTolerated
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.storage.cTime
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.storageLocationChecker.delegateChecker.diskCheckTimeout
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.volumeChecker.maxVolumeFailuresTolerated
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.volumeChecker.numAsyncDatasetChecks
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.volumeChecker.numSkippedChecks
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.volumeChecker.numVolumeChecks
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.xserver.balanceThrottler.bytesAlreadyUsed
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.xserver.balanceThrottler.numThreads
DataNode.instance.data.asyncDiskService.numDeletedBlocks == NameNode.instance.ACTIVE_STATE.lastHATransitionTime
DataNode.instance.data.asyncDiskService.numDeletedBlocks == NameNode.instance.OBSERVER_STATE.lastHATransitionTime
DataNode.instance.data.asyncDiskService.numDeletedBlocks == NameNode.instance.STANDBY_STATE.lastHATransitionTime
DataNode.instance.data.asyncDiskService.numDeletedBlocks == NameNode.instance.namesystem.dir.yieldCount
DataNode.instance.data.asyncDiskService.numDeletedBlocks == NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.data.asyncDiskService.numDeletedBlocks == NameNode.instance.namesystem.fsLock.longestReadLockHeldIntervalMs
DataNode.instance.data.asyncDiskService.numDeletedBlocks == NameNode.instance.namesystem.fsLock.numReadLockWarningsSuppressed
DataNode.instance.data.asyncDiskService.numDeletedBlocks == NameNode.instance.namesystem.fsLock.timeStampOfLastReadLockReportMs
DataNode.instance.data.asyncDiskService.numDeletedBlocks == NameNode.instance.namesystem.maxFsObjects
DataNode.instance.data.asyncDiskService.numDeletedBlocks == NameNode.instance.namesystem.minBlockSize
DataNode.instance.data.asyncDiskService.numDeletedBlocks == NameNode.instance.namesystem.numCommittedAllowed
DataNode.instance.data.asyncDiskService.numDeletedBlocks == NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.data.asyncDiskService.numDeletedBlocks == NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.data.asyncDiskService.numDeletedBlocks == NameNode.instance.state.lastHATransitionTime
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.blockReportLeaseManager.deferredHead.leaseId
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.blockReportLeaseManager.deferredHead.leaseTimeMs
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.blockReportLeaseManager.pendingHead.leaseId
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.blockReportLeaseManager.pendingHead.leaseTimeMs
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.blockReportThread.lastFull
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.bmSafeMode.blockReplQueueThreshold
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.bmSafeMode.blockSafe
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.bmSafeMode.blockThreshold
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.bmSafeMode.blockTotal
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.bmSafeMode.datanodeThreshold
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.bmSafeMode.extension
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.bmSafeMode.lastStatusReport
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.bmSafeMode.reachedTime
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.corruptReplicaBlocksCount
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.datanodeManager.numStaleNodes
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.datanodeManager.numStaleStorages
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.excessRedundancyMap.size
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.heartbeatManager.stats.cacheCapacity
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.heartbeatManager.stats.cacheUsed
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.heartbeatManager.stats.expiredHeartbeats
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.invalidateBlocks.blockIdManager.legacyGenerationStampLimit
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.invalidateBlocks.pendingPeriodInMs
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.neededReconstruction.QUEUE_HIGHEST_PRIORITY
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.pendingDNMessages.count
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.pendingReconstruction.timedOutCount
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.pendingReconstructionBlocksCount
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.modification
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.size
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.providedStorageMap.capacity
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.providedStorageMap.defaultReplication
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.scheduledReplicationBlocksCount
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.startupDelayBlockDeletionInMs
DataNode.instance.data.asyncDiskService.numDeletedBlocks == daikon.Quant.size(DataNode.instance.directoryScanner.diffs_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.numDeletedBlocks == daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.numDeletedBlocks == daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.numDeletedBlocks == daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.data.cacheManager.revocationMs == DataNode.instance.volumeChecker.delegateChecker.minMsBetweenChecks
DataNode.instance.data.cacheManager.revocationMs == DataNode.instance.volumeChecker.minDiskCheckGapMs
DataNode.instance.data.cacheManager.revocationPollingMs == NameNode.instance.namesystem.dir.contentSleepMicroSec
DataNode.instance.data.fsRunning == DataNode.instance.diskBalancer.isDiskBalancerEnabled
DataNode.instance.data.fsRunning == DataNode.instance.dnConf.tcpNoDelay
DataNode.instance.data.fsRunning == DataNode.instance.dnConf.transferToAllowed
DataNode.instance.data.fsRunning == DataNode.instance.hasAnyBlockPoolRegistered
DataNode.instance.data.fsRunning == DataNode.instance.isPermissionEnabled
DataNode.instance.data.fsRunning == DataNode.instance.shouldRun
DataNode.instance.data.fsRunning == NameNode.instance.OBSERVER_STATE.isObserver
DataNode.instance.data.fsRunning == NameNode.instance.namesystem.cacheManager.enabled
DataNode.instance.data.fsRunning == NameNode.instance.namesystem.dir.CHECK_RESERVED_FILE_NAMES
DataNode.instance.data.fsRunning == NameNode.instance.namesystem.dir.isPermissionEnabled
DataNode.instance.data.fsRunning == NameNode.instance.namesystem.dir.posixAclInheritanceEnabled
DataNode.instance.data.fsRunning == NameNode.instance.namesystem.dir.quotaByStorageTypeEnabled
DataNode.instance.data.fsRunning == NameNode.instance.namesystem.dir.storagePolicyEnabled
DataNode.instance.data.fsRunning == NameNode.instance.namesystem.dir.xattrsEnabled
DataNode.instance.data.fsRunning == NameNode.instance.namesystem.fsImage.isUpgradeFinalized
DataNode.instance.data.fsRunning == NameNode.instance.namesystem.fsRunning
DataNode.instance.data.fsRunning == NameNode.instance.namesystem.hasResourcesAvailable
DataNode.instance.data.fsRunning == NameNode.instance.namesystem.imageLoaded
DataNode.instance.data.fsRunning == NameNode.instance.namesystem.isPermissionEnabled
DataNode.instance.data.fsRunning == NameNode.instance.namesystem.leaseManager.shouldRunMonitor
DataNode.instance.data.fsRunning == NameNode.instance.namesystem.snapshotManager.snapshotDiffAllowSnapRootDescendant
DataNode.instance.data.fsRunning == NameNode.instance.namesystem.standbyShouldCheckpoint
DataNode.instance.data.fsRunning == NameNode.instance.namesystem.topConf.isEnabled
DataNode.instance.data.fsRunning == NameNode.instance.namesystem.topMetrics.isMetricsSourceEnabled
DataNode.instance.data.fsRunning == NameNode.instance.started
DataNode.instance.data.fsRunning == blockManagerInstance.datanodeManager.checkIpHostnameInRegistration
DataNode.instance.data.fsRunning == blockManagerInstance.datanodeManager.useDfsNetworkTopology
DataNode.instance.data.fsRunning == blockManagerInstance.initializedReplQueues
DataNode.instance.data.fsRunning == blockManagerInstance.pendingReconstruction.fsRunning
DataNode.instance.data.fsRunning == blockManagerInstance.placementPolicies.ecPolicy.considerLoad
DataNode.instance.data.fsRunning == blockManagerInstance.placementPolicies.ecPolicy.preferLocalNode
DataNode.instance.data.fsRunning == blockManagerInstance.placementPolicies.replicationPolicy.considerLoad
DataNode.instance.data.fsRunning == blockManagerInstance.placementPolicies.replicationPolicy.preferLocalNode
DataNode.instance.data.volsConfigured == blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.sequenceNumber
DataNode.instance.data.volsConfigured == blockManagerInstance.defaultReplication
DataNode.instance.data.volsConfigured == blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.volsConfigured == blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.volsConfigured == blockManagerInstance.heartbeatManager.stats.xceiverCount
DataNode.instance.data.volsConfigured == blockManagerInstance.maxReplicationStreams
DataNode.instance.data.volsConfigured == blockManagerInstance.neededReconstruction.QUEUE_LOW_REDUNDANCY
DataNode.instance.data.volsConfigured == blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandMultiplier
DataNode.instance.directoryScanner.MILLIS_PER_SECOND == NameNode.instance.namesystem.dir.lsLimit
DataNode.instance.directoryScanner.MILLIS_PER_SECOND == NameNode.instance.namesystem.edekCacheLoaderInterval
DataNode.instance.directoryScanner.MILLIS_PER_SECOND == NameNode.instance.namesystem.maxListOpenFilesResponses
DataNode.instance.directoryScanner.MILLIS_PER_SECOND == NameNode.instance.namesystem.snapshotDiffReportLimit
DataNode.instance.directoryScanner.MILLIS_PER_SECOND == blockManagerInstance.blockIdManager.impendingGenerationStamp.LAST_RESERVED_STAMP
DataNode.instance.directoryScanner.MILLIS_PER_SECOND == blockManagerInstance.blockIdManager.legacyGenerationStamp.LAST_RESERVED_STAMP
DataNode.instance.directoryScanner.MILLIS_PER_SECOND == blockManagerInstance.datanodeManager.blockInvalidateLimit
DataNode.instance.directoryScanner.MILLIS_PER_SECOND == blockManagerInstance.invalidateBlocks.blockInvalidateLimit
DataNode.instance.directoryScanner.MILLIS_PER_SECOND == blockManagerInstance.maxNumBlocksToLog
DataNode.instance.diskBalancer.bandwidth == NameNode.instance.namesystem.fsImage.SHUTDOWN_HOOK_PRIORITY
DataNode.instance.diskBalancer.bandwidth == blockManagerInstance.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE
DataNode.instance.dnConf.cacheReportInterval == blockManagerInstance.datanodeManager.blocksPerPostponedMisreplicatedBlocksRescan
DataNode.instance.dnConf.cacheReportInterval == blockManagerInstance.numBlocksPerIteration
DataNode.instance.dnConf.heartBeatInterval == blockManagerInstance.placementPolicies.replicationPolicy.heartbeatInterval
DataNode.instance.dnConf.heartBeatInterval == blockManagerInstance.redundancyRecheckIntervalMs
daikon.Quant.pairwiseEqual(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE, NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.cacheManager.scanIntervalMs == blockManagerInstance.datanodeManager.timeBetweenResendingCachingDirectivesMs
NameNode.instance.namesystem.cacheManager.scanIntervalMs == blockManagerInstance.placementPolicies.ecPolicy.staleInterval
NameNode.instance.namesystem.cacheManager.scanIntervalMs == blockManagerInstance.placementPolicies.replicationPolicy.staleInterval
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval == blockManagerInstance.datanodeManager.heartbeatManager.heartbeatRecheckInterval
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval == blockManagerInstance.datanodeManager.heartbeatRecheckInterval
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval == blockManagerInstance.heartbeatManager.heartbeatRecheckInterval
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval == blockManagerInstance.pendingReconstruction.DEFAULT_RECHECK_INTERVAL
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval == blockManagerInstance.pendingReconstruction.timeout
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.volsConfigured-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.volsConfigured-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.blocksReplWorkMultiplier-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.sequenceNumber-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.defaultReplication-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.heartbeatManager.stats.nodesInService-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.heartbeatManager.stats.xceiverCount-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.maxReplicationStreams-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.neededReconstruction.QUEUE_LOW_REDUNDANCY-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandMultiplier-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncLazyPersistService.MAXIMUM_THREADS_PER_VOLUME-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_SELECTOR_THREADS-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.volumeChecker.numSyncDatasetChecks-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.sequenceNumber-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.cacheManager.nextDirectiveId-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.nnResourceChecker.minimumRedundantVolumes-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.bmSafeMode.safeReplication-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.neededReconstruction.QUEUE_VERY_LOW_REDUNDANCY-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.volsConfigured) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.datanodeManager.heartbeatIntervalSeconds-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.volsConfigured) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.neededReconstruction.QUEUE_REPLICAS_BADLY_DISTRIBUTED-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.volsConfigured) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.shrinkThreshold-1)
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs == 5000
DataNode.instance.id.infoPort == 41075
DataNode.instance.id.ipcPort == 46043
DataNode.instance.id.nsInfo.cTime == 1731381997960L
DataNode.instance.id.nsInfo.namespaceID == 845993198
DataNode.instance.id.xferPort == 40107
DataNode.instance.lastDiskErrorCheck == 118106968
DataNode.instance.volumeChecker.lastAllVolumesCheck == 118106961
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118106202
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118107195148723L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118107231051562L
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118105073
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118104336
NameNode.instance.namesystem.startTime == 1731381999428L
blockManagerInstance.blockReportLeaseManager.nextId == -6316050801332311009L
blockManagerInstance.bmSafeMode.startTime == 118105032
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 98304
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 186916143104L
blockManagerInstance.heartbeatManager.stats.capacityTotal == 268200361984L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 67540238336L
blockManagerInstance.invalidateBlocks.startupTime == 118104339
daikon.Quant.fuzzy.eq(blockManagerInstance.reconstructionQueuesInitProgress, Double.NaN)
DataNode.instance.id.infoPort == 41747
DataNode.instance.id.ipcPort == 39819
DataNode.instance.id.nsInfo.cTime == 1731382026532L
DataNode.instance.id.nsInfo.namespaceID == 1950446581
DataNode.instance.id.xferPort == 33217
DataNode.instance.lastDiskErrorCheck == 118135536
DataNode.instance.volumeChecker.lastAllVolumesCheck == 118135529
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118134928
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118134551
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118132991
NameNode.instance.namesystem.startTime == 1731382028083L
blockManagerInstance.blockReportLeaseManager.nextId == -615436267100362629L
blockManagerInstance.bmSafeMode.startTime == 118133706
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 186875117568L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 67581263872L
blockManagerInstance.invalidateBlocks.startupTime == 118132994
blockManagerInstance.bmSafeMode.startTime > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.blockPoolUsed > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.capacityRemaining > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.capacityTotal > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == blockManagerInstance.replQueueCallsSinceReset
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.replQueueCallsSinceReset-1)
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118137067373339L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118137091532002L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118137171693592L
blockManagerInstance.lastRedundancyCycleTS == 118136706
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118135727319393L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118135740360991L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118135851411815L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118136937644478L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118136959164687L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118137031844079L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118137200782076L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118137221776435L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118137282819592L
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == blockManagerInstance.defaultReplication
DataNode.instance.data.asyncDiskService.numDeletedBlocks == NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.directoryScanner.timeRunningMs
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.directoryScanner.timeWaitingMs
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.diskBalancer.currentResult.result
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.dnConf.initialBlockReportDelayMs
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.dnConf.maxLockedMemory
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.dnConf.transferSocketRecvBufferSize
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.dnConf.transferSocketSendBufferSize
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.dnConf.volFailuresTolerated
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.fileIoProvider.profilingEventHook.sampleRangeMax
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.id.exportedKeys.keyUpdateInterval
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.id.exportedKeys.tokenLifetime
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.id.infoSecurePort
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.infoSecurePort
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.storage.cTime
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.storageLocationChecker.delegateChecker.diskCheckTimeout
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.volumeChecker.maxVolumeFailuresTolerated
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.volumeChecker.numAsyncDatasetChecks
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.volumeChecker.numSkippedChecks
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.volumeChecker.numVolumeChecks
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.xmitsInProgress
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.xserver.balanceThrottler.bytesAlreadyUsed
DataNode.instance.data.cacheManager.numBlocksCached == DataNode.instance.xserver.balanceThrottler.numThreads
DataNode.instance.data.cacheManager.numBlocksCached == NameNode.instance.ACTIVE_STATE.lastHATransitionTime
DataNode.instance.data.cacheManager.numBlocksCached == NameNode.instance.OBSERVER_STATE.lastHATransitionTime
DataNode.instance.data.cacheManager.numBlocksCached == NameNode.instance.STANDBY_STATE.lastHATransitionTime
DataNode.instance.data.cacheManager.numBlocksCached == NameNode.instance.namesystem.dir.maxComponentLength
DataNode.instance.data.cacheManager.numBlocksCached == NameNode.instance.namesystem.dir.yieldCount
DataNode.instance.data.cacheManager.numBlocksCached == NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.data.cacheManager.numBlocksCached == NameNode.instance.namesystem.fsLock.longestReadLockHeldIntervalMs
DataNode.instance.data.cacheManager.numBlocksCached == NameNode.instance.namesystem.fsLock.numReadLockWarningsSuppressed
DataNode.instance.data.cacheManager.numBlocksCached == NameNode.instance.namesystem.fsLock.timeStampOfLastReadLockReportMs
DataNode.instance.data.cacheManager.numBlocksCached == NameNode.instance.namesystem.maxFsObjects
DataNode.instance.data.cacheManager.numBlocksCached == NameNode.instance.namesystem.minBlockSize
DataNode.instance.data.cacheManager.numBlocksCached == NameNode.instance.namesystem.numCommittedAllowed
DataNode.instance.data.cacheManager.numBlocksCached == NameNode.instance.namesystem.snapshotManager.numSnapshots
DataNode.instance.data.cacheManager.numBlocksCached == NameNode.instance.namesystem.snapshotManager.snapshotCounter
DataNode.instance.data.cacheManager.numBlocksCached == NameNode.instance.state.lastHATransitionTime
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.blockReportLeaseManager.deferredHead.leaseId
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.blockReportLeaseManager.deferredHead.leaseTimeMs
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.blockReportLeaseManager.pendingHead.leaseId
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.blockReportLeaseManager.pendingHead.leaseTimeMs
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.blockReportThread.lastFull
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.bmSafeMode.blockReplQueueThreshold
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.bmSafeMode.blockSafe
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.bmSafeMode.blockThreshold
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.bmSafeMode.blockTotal
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.bmSafeMode.datanodeThreshold
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.bmSafeMode.extension
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.bmSafeMode.lastStatusReport
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.bmSafeMode.reachedTime
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.corruptReplicaBlocksCount
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.datanodeManager.numStaleNodes
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.datanodeManager.numStaleStorages
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.excessRedundancyMap.size
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.heartbeatManager.stats.cacheCapacity
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.heartbeatManager.stats.cacheUsed
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.heartbeatManager.stats.expiredHeartbeats
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.invalidateBlocks.blockIdManager.legacyGenerationStampLimit
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.invalidateBlocks.pendingPeriodInMs
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.neededReconstruction.QUEUE_HIGHEST_PRIORITY
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.pendingDNMessages.count
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.pendingReconstruction.timedOutCount
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.pendingReconstructionBlocksCount
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.modification
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.size
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.providedStorageMap.capacity
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.providedStorageMap.defaultReplication
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.scheduledReplicationBlocksCount
DataNode.instance.data.cacheManager.numBlocksCached == blockManagerInstance.startupDelayBlockDeletionInMs
DataNode.instance.data.cacheManager.numBlocksCached == daikon.Quant.size(DataNode.instance.directoryScanner.diffs_FOR_ENCLOSING_USE)
DataNode.instance.data.cacheManager.numBlocksCached == daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.data.cacheManager.numBlocksCached == daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.cacheManager.numBlocksCached == daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.data.volsConfigured == blockManagerInstance.replQueueCallsSinceReset
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.replQueueCallsSinceReset-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME-1) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_SELECTOR_THREADS-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.id.nsInfo.capabilities-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.volumeChecker.numSyncDatasetChecks-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.sequenceNumber-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.cacheManager.nextDirectiveId-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.nnResourceChecker.minimumRedundantVolumes-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.bmSafeMode.safeReplication-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.defaultReplication-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.heartbeatManager.stats.nodesInService-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.neededReconstruction.QUEUE_VERY_LOW_REDUNDANCY-1)
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 14
DataNode.instance.id.infoPort == 32985
DataNode.instance.id.ipcPort == 38853
DataNode.instance.id.nsInfo.cTime == 1731382094714L
DataNode.instance.id.nsInfo.namespaceID == 1728004648
DataNode.instance.id.xferPort == 44395
DataNode.instance.lastDiskErrorCheck == 118203547
DataNode.instance.volumeChecker.lastAllVolumesCheck == 118203541
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118202622
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118202557
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118200996
NameNode.instance.namesystem.startTime == 1731382096088L
blockManagerInstance.blockReportLeaseManager.nextId == 41004619899776898L
blockManagerInstance.bmSafeMode.startTime == 118201679
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 214412
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93262422016L
blockManagerInstance.heartbeatManager.stats.capacityTotal == 134100180992L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33965603444L
blockManagerInstance.invalidateBlocks.startupTime == 118200999
blockManagerInstance.lastRedundancyCycleTS == 118207679
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION == blockManagerInstance.replQueueCallsSinceReset
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.volsConfigured) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.replQueueCallsSinceReset-1)
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 28
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93252993024L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33975032436L
blockManagerInstance.lastRedundancyCycleTS == 118210680
DataNode.instance.data.asyncDiskService.numDeletedBlocks > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.lastRedundancyCycleTS > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.numDeletedBlocks == NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
blockManagerInstance.replQueueCallsSinceReset == blockManagerInstance.storagePolicySuite.defaultPolicyID
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 24
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 88
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93204881408L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 34023144052L
blockManagerInstance.lastRedundancyCycleTS == 118222681
blockManagerInstance.replQueueCallsSinceReset == 7
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 38
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 230938
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93240246272L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33987762662L
blockManagerInstance.lastRedundancyCycleTS == 118213680
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.data.volsConfigured
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.dnConf.volsConfigured
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.blocksReplWorkMultiplier
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.sequenceNumber
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.heartbeatManager.stats.xceiverCount
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.maxReplicationStreams
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.neededReconstruction.QUEUE_LOW_REDUNDANCY
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandMultiplier
DataNode.instance.data.asyncDiskService.numDeletedBlocks == daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION-1) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksFailedToUncache-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.datanodeManager.heartbeatIntervalSeconds-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.neededReconstruction.QUEUE_REPLICAS_BADLY_DISTRIBUTED-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.shrinkThreshold-1)
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 148308
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93268434944L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33959656620L
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == blockManagerInstance.heartbeatManager.stats.xceiverCount
DataNode.instance.data.asyncDiskService.numDeletedBlocks == NameNode.instance.namesystem.dir.maxComponentLength
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.defaultReplication-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.heartbeatManager.stats.nodesInService-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.heartbeatManager.stats.xceiverCount-1)
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 49152
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93275766784L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33952423936L
blockManagerInstance.lastRedundancyCycleTS == 118204679
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 14 || DataNode.instance.data.asyncDiskService.numDeletedBlocks == 26 || DataNode.instance.data.asyncDiskService.numDeletedBlocks == 28
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 14 || DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 24 || DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 28
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93252993024L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93262422016L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33965603444L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33975032436L
DataNode.instance.NUM_CORES > DataNode.instance.data.asyncDiskService.numDeletedBlocks
DataNode.instance.NUM_CORES > DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs > DataNode.instance.data.asyncDiskService.numDeletedBlocks
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs > DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < DataNode.instance.data.asyncDiskService.numDeletedBlocks
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < DataNode.instance.data.asyncDiskService.numDeletedBlocks
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < DataNode.instance.data.asyncDiskService.numDeletedBlocks
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS > DataNode.instance.data.asyncDiskService.numDeletedBlocks
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS > DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS > DataNode.instance.data.asyncDiskService.numDeletedBlocks
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS > DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.asyncDiskService.numDeletedBlocks > DataNode.instance.data.cacheManager.numBlocksCached
DataNode.instance.data.asyncDiskService.numDeletedBlocks >= DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.data.cacheManager.revocationMs
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.data.cacheManager.revocationPollingMs
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.data.maxDataLength
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.data.smallBufferSize
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.directoryScanner.MILLIS_PER_SECOND
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.directoryScanner.scanPeriodMsecs
DataNode.instance.data.asyncDiskService.numDeletedBlocks > DataNode.instance.diskBalancer.bandwidth
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.diskBalancer.planValidityInterval
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.dnConf.blockReportSplitThreshold
DataNode.instance.data.asyncDiskService.numDeletedBlocks != DataNode.instance.dnConf.bpReadyTimeout
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.dnConf.cacheReportInterval
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.dnConf.heartBeatInterval
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.dnConf.lifelineIntervalMs
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.dnConf.outliersReportIntervalMs
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.dnConf.readaheadLength
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.dnConf.restartReplicaExpiry
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.dnConf.socketKeepaliveTimeout
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.dnConf.socketTimeout
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.dnConf.socketWriteTimeout
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.id.infoPort
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.id.ipcPort
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.id.nsInfo.cTime
DataNode.instance.data.asyncDiskService.numDeletedBlocks > DataNode.instance.id.nsInfo.layoutVersion
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.id.xferPort
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.lastDiskErrorCheck
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.shortCircuitRegistry.SHM_LENGTH
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.xserver.balanceThrottler.bytesPerPeriod
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.xserver.balanceThrottler.maxThreads
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.xserver.balanceThrottler.periodExtension
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.xserver.estimateBlockSize
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.xserver.maxXceiverCount
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.DEFAULT_PORT
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL
DataNode.instance.data.asyncDiskService.numDeletedBlocks >= NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.asyncDiskService.numDeletedBlocks > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.namesystem.cacheManager.scanIntervalMs
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.namesystem.dir.maxDirItems
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.namesystem.dir.xattrMaxSize
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.namesystem.editLogRollerThreshold
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.namesystem.leaseManager.hardLimit
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.namesystem.leaseRecheckIntervalMs
DataNode.instance.data.asyncDiskService.numDeletedBlocks != NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.namesystem.nnResourceChecker.duReserved
DataNode.instance.data.asyncDiskService.numDeletedBlocks != NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.namesystem.startTime
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
DataNode.instance.data.asyncDiskService.numDeletedBlocks > blockManagerInstance.blockReportLeaseManager.maxPending
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.blocksMap.capacity
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.datanodeManager.defaultInfoPort
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.datanodeManager.defaultInfoSecurePort
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.datanodeManager.defaultIpcPort
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.datanodeManager.defaultXferPort
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.datanodeManager.heartbeatExpireInterval
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.asyncDiskService.numDeletedBlocks > blockManagerInstance.neededReconstruction.LEVEL
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
DataNode.instance.data.asyncDiskService.numDeletedBlocks != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
DataNode.instance.data.asyncDiskService.numDeletedBlocks > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
DataNode.instance.data.asyncDiskService.numDeletedBlocks != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.replQueueResetToHeadThreshold
DataNode.instance.data.asyncDiskService.numDeletedBlocks > blockManagerInstance.storagePolicySuite.defaultPolicyID
DataNode.instance.data.cacheManager.numBlocksCached < DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.cacheManager.numBlocksCached < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.cacheManager.numBlocksCached < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.data.cacheManager.revocationMs
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.data.cacheManager.revocationPollingMs
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.data.maxDataLength
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.data.smallBufferSize
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.directoryScanner.MILLIS_PER_SECOND
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.directoryScanner.scanPeriodMsecs
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > DataNode.instance.diskBalancer.bandwidth
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.diskBalancer.planValidityInterval
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.dnConf.blockReportSplitThreshold
DataNode.instance.data.cacheManager.numBlocksFailedToUncache != DataNode.instance.dnConf.bpReadyTimeout
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.dnConf.cacheReportInterval
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.dnConf.heartBeatInterval
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.dnConf.lifelineIntervalMs
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.dnConf.outliersReportIntervalMs
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.dnConf.readaheadLength
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.dnConf.restartReplicaExpiry
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.dnConf.socketKeepaliveTimeout
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.dnConf.socketTimeout
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.dnConf.socketWriteTimeout
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.id.infoPort
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.id.ipcPort
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.id.nsInfo.cTime
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > DataNode.instance.id.nsInfo.layoutVersion
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.id.xferPort
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.lastDiskErrorCheck
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.shortCircuitRegistry.SHM_LENGTH
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > DataNode.instance.storage.layoutVersion
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.xserver.balanceThrottler.bytesPerPeriod
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.xserver.balanceThrottler.maxThreads
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.xserver.balanceThrottler.periodExtension
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.xserver.estimateBlockSize
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.xserver.maxXceiverCount
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.DEFAULT_PORT
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL
DataNode.instance.data.cacheManager.numBlocksFailedToUncache >= NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.cacheManager.scanIntervalMs
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.dir.maxDirItems
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.dir.xattrMaxSize
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.editLogRollerThreshold
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.leaseManager.hardLimit
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.leaseRecheckIntervalMs
DataNode.instance.data.cacheManager.numBlocksFailedToUncache != NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.nnResourceChecker.duReserved
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.startTime
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > blockManagerInstance.blockReportLeaseManager.maxPending
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.blocksMap.capacity
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.datanodeManager.defaultInfoPort
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.datanodeManager.defaultInfoSecurePort
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.datanodeManager.defaultIpcPort
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.datanodeManager.defaultXferPort
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.datanodeManager.heartbeatExpireInterval
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > blockManagerInstance.neededReconstruction.LEVEL
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
DataNode.instance.data.cacheManager.numBlocksFailedToUncache != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
DataNode.instance.data.cacheManager.numBlocksFailedToUncache != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.replQueueResetToHeadThreshold
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > blockManagerInstance.storagePolicySuite.defaultPolicyID
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.cacheManager.revocationMs < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.cacheManager.revocationMs < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.cacheManager.revocationPollingMs < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.cacheManager.revocationPollingMs < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.maxDataLength < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.maxDataLength < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.smallBufferSize < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.smallBufferSize < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.blockReportSplitThreshold < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.blockReportSplitThreshold < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.bpReadyTimeout < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.bpReadyTimeout < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.cacheReportInterval < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.cacheReportInterval < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.heartBeatInterval < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.heartBeatInterval < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.lifelineIntervalMs < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.lifelineIntervalMs < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.outliersReportIntervalMs < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.outliersReportIntervalMs < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.readaheadLength < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.readaheadLength < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.restartReplicaExpiry < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.restartReplicaExpiry < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.socketKeepaliveTimeout < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.socketKeepaliveTimeout < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.socketTimeout < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.socketTimeout < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.socketWriteTimeout < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.socketWriteTimeout < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.volumeChecker.lastAllVolumesCheck < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.volumeChecker.lastAllVolumesCheck < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.xserver.balanceThrottler.curPeriodStart < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.xserver.balanceThrottler.curPeriodStart < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.xserver.balanceThrottler.maxThreads < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.xserver.balanceThrottler.maxThreads < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.xserver.balanceThrottler.periodExtension < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.xserver.balanceThrottler.periodExtension < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.xserver.estimateBlockSize < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.xserver.estimateBlockSize < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.xserver.maxXceiverCount < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.xserver.maxXceiverCount < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.DEFAULT_PORT < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.DEFAULT_PORT < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.cacheManager.scanIntervalMs < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.cacheManager.scanIntervalMs < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.dir.maxDirItems < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.dir.maxDirItems < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.dir.xattrMaxSize < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.dir.xattrMaxSize < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.editLogRollerThreshold < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.editLogRollerThreshold < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.lazyPersistFileScrubberTS < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.lazyPersistFileScrubberTS < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.leaseManager.hardLimit < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.leaseManager.hardLimit < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.leaseRecheckIntervalMs < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.leaseRecheckIntervalMs < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.nnResourceChecker.duReserved < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.nnResourceChecker.duReserved < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER < blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID < blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.blockReportLeaseManager.maxPending < blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.blockReportLeaseManager.maxPending < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.blocksMap.capacity < blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.blocksMap.capacity < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.bmSafeMode.startTime < blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.bmSafeMode.startTime < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.datanodeManager.defaultInfoPort < blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.datanodeManager.defaultInfoPort < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.datanodeManager.defaultInfoSecurePort < blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.datanodeManager.defaultInfoSecurePort < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.datanodeManager.defaultIpcPort < blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.datanodeManager.defaultIpcPort < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.datanodeManager.defaultXferPort < blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.datanodeManager.defaultXferPort < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.datanodeManager.heartbeatExpireInterval < blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.datanodeManager.heartbeatExpireInterval < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.heartbeatManager.stats.blockPoolUsed < blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.heartbeatManager.stats.blockPoolUsed < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.heartbeatManager.stats.capacityRemaining < blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.heartbeatManager.stats.capacityRemaining > blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.heartbeatManager.stats.capacityRemaining > blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.heartbeatManager.stats.capacityRemaining > blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.heartbeatManager.stats.capacityRemaining > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.heartbeatManager.stats.capacityRemaining > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.heartbeatManager.stats.capacityRemaining > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.heartbeatManager.stats.capacityRemaining > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.heartbeatManager.stats.capacityRemaining > blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.heartbeatManager.stats.capacityRemaining > blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.heartbeatManager.stats.capacityTotal > blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs > blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs > blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs > blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs > blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.lastRedundancyCycleTS == 118225681
blockManagerInstance.replQueueCallsSinceReset == 8
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 54
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 313568
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93227188224L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 34000738080L
blockManagerInstance.lastRedundancyCycleTS == 118216680 || blockManagerInstance.lastRedundancyCycleTS == 118219681
blockManagerInstance.replQueueCallsSinceReset == 5 || blockManagerInstance.replQueueCallsSinceReset == 6
DataNode.instance.NUM_CORES < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.asyncDiskService.numDeletedBlocks > blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.cacheManager.numBlocksCached < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.cacheManager.numBlocksCached < blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.cacheManager.revocationMs < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.cacheManager.revocationPollingMs < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.maxDataLength < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.data.smallBufferSize < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.directoryScanner.MILLIS_PER_SECOND < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.directoryScanner.scanPeriodMsecs < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.diskBalancer.bandwidth < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.diskBalancer.planValidityInterval < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.blockReportSplitThreshold < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.bpReadyTimeout < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.cacheReportInterval < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.heartBeatInterval < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.lifelineIntervalMs < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.outliersReportIntervalMs < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.readaheadLength < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.restartReplicaExpiry < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.socketKeepaliveTimeout < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.socketTimeout < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.dnConf.socketWriteTimeout < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.id.infoPort < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.id.ipcPort < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.id.xferPort < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.lastDiskErrorCheck < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.shortCircuitRegistry.SHM_LENGTH < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.volumeChecker.lastAllVolumesCheck < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.xserver.balanceThrottler.curPeriodStart < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.xserver.balanceThrottler.maxThreads < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.xserver.balanceThrottler.periodExtension < blockManagerInstance.lastRedundancyCycleTS
DataNode.instance.xserver.maxXceiverCount < blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.DEFAULT_PORT < blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL < blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses < blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.cacheManager.scanIntervalMs < blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval < blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.dir.maxDirItems < blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.dir.xattrMaxSize < blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.editLogRollerThreshold < blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.lazyPersistFileScrubberTS < blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.leaseManager.hardLimit < blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime < blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.leaseRecheckIntervalMs < blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs < blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.nnResourceChecker.duReserved < blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH < blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit < blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER < blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.blockReportLeaseManager.maxPending < blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.blockReportLeaseManager.maxPending >= blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.blocksMap.capacity < blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.bmSafeMode.startTime < blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.bmSafeMode.startTime > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.datanodeManager.defaultInfoPort < blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.datanodeManager.defaultInfoSecurePort < blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.datanodeManager.defaultIpcPort < blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.datanodeManager.defaultXferPort < blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.datanodeManager.heartbeatExpireInterval < blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.heartbeatManager.stats.blockPoolUsed < blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.heartbeatManager.stats.blockPoolUsed > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.heartbeatManager.stats.capacityRemaining > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.heartbeatManager.stats.capacityTotal > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.invalidateBlocks.startupTime < blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.lastRedundancyCycleTS > blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.lastRedundancyCycleTS > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.lastRedundancyCycleTS > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.lastRedundancyCycleTS > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.lastRedundancyCycleTS > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.lastRedundancyCycleTS > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.lastRedundancyCycleTS > blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.lastRedundancyCycleTS > blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.neededReconstruction.LEVEL <= blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.blockReportLeaseManager.maxPending == blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.lastRedundancyCycleTS == 118219681
blockManagerInstance.neededReconstruction.LEVEL == blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.lastRedundancyCycleTS == 118216680
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 78
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 330094
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93214162944L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 34013746834L
blockManagerInstance.replQueueCallsSinceReset > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 38 || DataNode.instance.data.asyncDiskService.numDeletedBlocks == 54
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 230938 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 313568
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93227188224L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93240246272L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33987762662L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 34000738080L
DataNode.instance.NUM_CORES < DataNode.instance.data.asyncDiskService.numDeletedBlocks
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.asyncDiskService.numDeletedBlocks > DataNode.instance.dnConf.bpReadyTimeout
DataNode.instance.data.asyncDiskService.numDeletedBlocks != DataNode.instance.xserver.balanceThrottler.maxThreads
DataNode.instance.data.asyncDiskService.numDeletedBlocks > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.asyncDiskService.numDeletedBlocks > NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
DataNode.instance.data.asyncDiskService.numDeletedBlocks > NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
DataNode.instance.data.asyncDiskService.numDeletedBlocks > blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
DataNode.instance.data.asyncDiskService.numDeletedBlocks > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
DataNode.instance.data.asyncDiskService.numDeletedBlocks > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
DataNode.instance.data.cacheManager.numBlocksCached < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.cacheManager.revocationPollingMs < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.smallBufferSize < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.bpReadyTimeout < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.cacheReportInterval < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.heartBeatInterval < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.lifelineIntervalMs < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.restartReplicaExpiry < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.socketKeepaliveTimeout < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.socketTimeout < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.xserver.balanceThrottler.maxThreads < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.xserver.balanceThrottler.periodExtension < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.xserver.maxXceiverCount < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.DEFAULT_PORT < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.cacheManager.scanIntervalMs < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.dir.xattrMaxSize < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.leaseRecheckIntervalMs < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.blockReportLeaseManager.maxPending < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.bmSafeMode.startTime > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.datanodeManager.defaultInfoPort < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.datanodeManager.defaultInfoSecurePort < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.datanodeManager.defaultIpcPort < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.datanodeManager.defaultXferPort < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.heartbeatManager.stats.blockPoolUsed < blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.heartbeatManager.stats.blockPoolUsed > blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.heartbeatManager.stats.blockPoolUsed > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.heartbeatManager.stats.blockPoolUsed > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.heartbeatManager.stats.blockPoolUsed > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.heartbeatManager.stats.blockPoolUsed > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.heartbeatManager.stats.blockPoolUsed > blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.heartbeatManager.stats.blockPoolUsed > blockManagerInstance.storagePolicySuite.defaultPolicyID
26762453 * DataNode.instance.data.asyncDiskService.numDeletedBlocks - 16 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 442804352 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) + 1.891495910354898E15 == 0
blockManagerInstance.lastRedundancyCycleTS == 118222681 || blockManagerInstance.lastRedundancyCycleTS == 118225681
blockManagerInstance.replQueueCallsSinceReset == 7 || blockManagerInstance.replQueueCallsSinceReset == 8
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == NameNode.instance.namesystem.snapshotManager.snapshotCounter
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.snapshotManager.snapshotCounter-1)
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 42 || DataNode.instance.data.asyncDiskService.numDeletedBlocks == 56
DataNode.instance.id.infoPort == 41027
DataNode.instance.id.ipcPort == 37053
DataNode.instance.id.nsInfo.cTime == 1731382064143L
DataNode.instance.id.nsInfo.namespaceID == 1935513821
DataNode.instance.id.xferPort == 38245
DataNode.instance.lastDiskErrorCheck == 118172871
DataNode.instance.volumeChecker.lastAllVolumesCheck == 118172865
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118172040
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118171973
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118170466
NameNode.instance.namesystem.startTime == 1731382065558L
blockManagerInstance.blockReportLeaseManager.nextId == 2200808785020884386L
blockManagerInstance.bmSafeMode.startTime == 118171185
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 197886 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 263990
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93308002304L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93319684096L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33908357890L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33919973578L
blockManagerInstance.invalidateBlocks.startupTime == 118170468
blockManagerInstance.lastRedundancyCycleTS == 118186187
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 30
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 94
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 247464
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93281861632L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33946130776L
blockManagerInstance.lastRedundancyCycleTS == 118195188
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 42
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 197886
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93319684096L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33908357890L
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION == blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION == blockManagerInstance.heartbeatManager.stats.xceiverCount
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == DataNode.instance.data.asyncDiskService.numDeletedBlocks
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == DataNode.instance.data.cacheManager.numBlocksFailedToUncache
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.volsConfigured) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.volsConfigured) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.heartbeatManager.stats.xceiverCount-1)
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 173097
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93344837632L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33883225047L
blockManagerInstance.lastRedundancyCycleTS == 118177186
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 36 || DataNode.instance.data.asyncDiskService.numDeletedBlocks == 42
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93319684096L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93329858560L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33898183426L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33908357890L
blockManagerInstance.lastRedundancyCycleTS == 118183187
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 36
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93329858560L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33898183426L
blockManagerInstance.lastRedundancyCycleTS == 118180186 || blockManagerInstance.lastRedundancyCycleTS == 118183187
blockManagerInstance.replQueueCallsSinceReset == 3 || blockManagerInstance.replQueueCallsSinceReset == 4
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION <= blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME >= blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == blockManagerInstance.heartbeatManager.stats.xceiverCount
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 263990
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93338345472L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33889630410L
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 56
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93308002304L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33919973578L
blockManagerInstance.lastRedundancyCycleTS == 118186187 || blockManagerInstance.lastRedundancyCycleTS == 118189187
blockManagerInstance.lastRedundancyCycleTS == 118180186
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.replQueueCallsSinceReset-1)
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 0 || DataNode.instance.data.asyncDiskService.numDeletedBlocks == 4
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 49152 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 173097
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93344837632L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93352050688L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33876140032L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33883225047L
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 1 || blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 3
blockManagerInstance.lastRedundancyCycleTS == 118174186
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION != DataNode.instance.data.asyncDiskService.numDeletedBlocks
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME != DataNode.instance.data.asyncDiskService.numDeletedBlocks
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME <= blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME >= DataNode.instance.data.asyncDiskService.numDeletedBlocks
DataNode.instance.data.asyncDiskService.numDeletedBlocks >= DataNode.instance.data.cacheManager.numBlocksCached
DataNode.instance.data.asyncDiskService.numDeletedBlocks != DataNode.instance.data.volsConfigured
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.diskBalancer.bandwidth
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.dnConf.bpReadyTimeout
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.blockReportLeaseManager.maxPending
DataNode.instance.data.asyncDiskService.numDeletedBlocks != blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.neededReconstruction.LEVEL
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.storagePolicySuite.defaultPolicyID
DataNode.instance.data.cacheManager.numBlocksCached < blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.bmSafeMode.startTime > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.heartbeatManager.stats.blockPoolUsed > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.heartbeatManager.stats.capacityRemaining > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.heartbeatManager.stats.capacityTotal > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount < blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93352050688L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33876140032L
blockManagerInstance.lastRedundancyCycleTS == 118189187
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93291855872L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33936053906L
blockManagerInstance.lastRedundancyCycleTS == 118189187 || blockManagerInstance.lastRedundancyCycleTS == 118192188
blockManagerInstance.replQueueCallsSinceReset == 6 || blockManagerInstance.replQueueCallsSinceReset == 7
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.blockReportLeaseManager.maxPending <= blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.neededReconstruction.LEVEL < blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.replQueueCallsSinceReset <= blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.lastRedundancyCycleTS == 118192188
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos % DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION == 0
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.rpcServer.serviceAuthEnabled
DataNode.instance.dnConf.xceiverStopTimeout == NameNode.instance.namesystem.leaseManager.softLimit
blockManagerInstance.blockIdManager.legacyGenerationStampLimit == blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.lastRedundancyCycleTS == daikon.Quant.size(DataNode.instance.directoryScanner.diffs_FOR_ENCLOSING_USE)-1
blockManagerInstance.lastRedundancyCycleTS == daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)-1
blockManagerInstance.lastRedundancyCycleTS == daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)-1
DataNode.instance.dnConf.socketTimeout == 100000000
DataNode.instance.dnConf.xceiverStopTimeout == 60000
DataNode.instance.id.infoPort == 42451
DataNode.instance.id.ipcPort == 36791
DataNode.instance.id.nsInfo.cTime == 1731382035058L
DataNode.instance.id.nsInfo.namespaceID == 339153920
DataNode.instance.id.xferPort == 37849
DataNode.instance.lastDiskErrorCheck == 118143719
DataNode.instance.storage.namespaceID == 339153920
DataNode.instance.volumeChecker.lastAllVolumesCheck == 117242846 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 118143711
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118142858
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118142173
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118141475
NameNode.instance.namesystem.startTime == 1731382036567L
blockManagerInstance.blockReportLeaseManager.nextId == -5387487438547939749L || blockManagerInstance.blockReportLeaseManager.nextId == -5387487438547939748L
blockManagerInstance.bmSafeMode.startTime == 0 || blockManagerInstance.bmSafeMode.startTime == 118142134
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 0 || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93431128064L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 0 || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33797062656L
blockManagerInstance.invalidateBlocks.startupTime == 118141477
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME >= DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.data.cacheManager.numBlocksCached <= DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.dnConf.xceiverStopTimeout < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.dnConf.xceiverStopTimeout > DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.dnConf.xceiverStopTimeout < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.dnConf.xceiverStopTimeout > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.xceiverStopTimeout > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.xceiverStopTimeout < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.xceiverStopTimeout > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.xceiverStopTimeout != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.dnConf.xceiverStopTimeout != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.dnConf.xceiverStopTimeout != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.dnConf.xceiverStopTimeout > blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.dnConf.xceiverStopTimeout > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.xceiverStopTimeout > daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.lastRedundancyCycleTS <= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
blockManagerInstance.lastRedundancyCycleTS <= daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
49152 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 1628964911 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 8.751015395328E12 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) - 5.8069240885460828E18 == 0
49152 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 1628964911 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 8.751015395328E12 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 - 5.8069328395614781E18 == 0
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 1628964911 * blockManagerInstance.heartbeatManager.stats.nodesInService - 178039864 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) - 1.18142173025433E14 == 0
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 1628964911 * blockManagerInstance.heartbeatManager.stats.nodesInService - 178039864 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 - 1.18142351065297E14 == 0
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION == blockManagerInstance.defaultReplication
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.fsRunning == NameNode.instance.namesystem.dir.aclsEnabled
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.volsConfigured) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.defaultReplication-1)
DataNode.instance.id.infoPort == 40235
DataNode.instance.id.ipcPort == 33079
DataNode.instance.id.nsInfo.cTime == 1731382012048L
DataNode.instance.id.nsInfo.namespaceID == 1505413540
DataNode.instance.id.xferPort == 35169
DataNode.instance.lastDiskErrorCheck == 118121267
DataNode.instance.volumeChecker.lastAllVolumesCheck == 118121257
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118120521
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118119153
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118118369
NameNode.instance.namesystem.startTime == 1731382013461L
blockManagerInstance.blockReportLeaseManager.nextId == 9007290290417269674L
blockManagerInstance.bmSafeMode.startTime == 118119111
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 196608
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 373812035584L
blockManagerInstance.heartbeatManager.stats.capacityTotal == 536400723968L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 135100727296L
blockManagerInstance.invalidateBlocks.startupTime == 118118371
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.storage.namespaceID
DataNode.instance.id.infoPort == 45941
DataNode.instance.id.ipcPort == 35761
DataNode.instance.id.xferPort == 34161
DataNode.instance.lastDiskErrorCheck == 118127384
DataNode.instance.volumeChecker.lastAllVolumesCheck == 118127379
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118127075
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 28
NameNode.instance.namesystem.fsImage.lastAppliedTxId == 98
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118126887
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118126525
NameNode.instance.namesystem.startTime == 1731382021617L
blockManagerInstance.blockReportLeaseManager.nextId == -1610548108126793778L
blockManagerInstance.bmSafeMode.startTime == 118126851
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 197259
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 373776711680L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 135136050549L
blockManagerInstance.invalidateBlocks.startupTime == 118126527
NameNode.instance.namesystem.fsImage.lastAppliedTxId < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.namesystem.fsImage.lastAppliedTxId > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == DataNode.instance.data.cacheManager.numBlocksFailedToUncache
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksFailedToUncache-1)
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION == NameNode.instance.namesystem.editLogTailer.maxRetries
DataNode.instance.directoryScanner.MILLIS_PER_SECOND == DataNode.instance.dnConf.heartBeatInterval
DataNode.instance.directoryScanner.diffs.serialVersionUID == DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED
DataNode.instance.directoryScanner.diffs.serialVersionUID == DataNode.instance.id.nsInfo.capabilities
DataNode.instance.directoryScanner.shouldRun == NameNode.instance.namesystem.fsRunning
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.editLogTailer.inProgressOk
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.leaseManager.shouldRunMonitor
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.namesystem.standbyShouldCheckpoint
DataNode.instance.dnConf.allowNonLocalLazyPersist == NameNode.instance.state.isObserver
DataNode.instance.dnConf.allowNonLocalLazyPersist == blockManagerInstance.bmSafeMode.inRollBack
DataNode.instance.dnConf.allowNonLocalLazyPersist == blockManagerInstance.datanodeManager.avoidStaleDataNodesForRead
DataNode.instance.dnConf.allowNonLocalLazyPersist == blockManagerInstance.datanodeManager.avoidStaleDataNodesForWrite
DataNode.instance.dnConf.allowNonLocalLazyPersist == blockManagerInstance.datanodeManager.dataNodeDiskStatsEnabled
DataNode.instance.dnConf.allowNonLocalLazyPersist == blockManagerInstance.datanodeManager.dataNodePeerStatsEnabled
DataNode.instance.dnConf.allowNonLocalLazyPersist == blockManagerInstance.datanodeManager.hasClusterEverBeenMultiRack
DataNode.instance.dnConf.allowNonLocalLazyPersist == blockManagerInstance.datanodeManager.heartbeatManager.enableLogStaleNodes
DataNode.instance.dnConf.allowNonLocalLazyPersist == blockManagerInstance.datanodeManager.rejectUnresolvedTopologyDN
DataNode.instance.dnConf.allowNonLocalLazyPersist == blockManagerInstance.datanodeManager.shouldSendCachingCommands
DataNode.instance.dnConf.allowNonLocalLazyPersist == blockManagerInstance.encryptDataTransfer
DataNode.instance.dnConf.allowNonLocalLazyPersist == blockManagerInstance.hasNonEcBlockUsingStripedID
DataNode.instance.dnConf.allowNonLocalLazyPersist == blockManagerInstance.heartbeatManager.enableLogStaleNodes
DataNode.instance.dnConf.allowNonLocalLazyPersist == blockManagerInstance.initializedReplQueues
DataNode.instance.dnConf.allowNonLocalLazyPersist == blockManagerInstance.providedStorageMap.providedEnabled
DataNode.instance.dnConf.heartBeatInterval == NameNode.instance.namesystem.blockDeletionIncrement
DataNode.instance.dnConf.heartBeatInterval == NameNode.instance.namesystem.dir.lsLimit
DataNode.instance.dnConf.heartBeatInterval == NameNode.instance.namesystem.edekCacheLoaderInterval
DataNode.instance.dnConf.heartBeatInterval == NameNode.instance.namesystem.editLogTailer.sleepTimeMs
DataNode.instance.dnConf.heartBeatInterval == NameNode.instance.namesystem.maxListOpenFilesResponses
DataNode.instance.dnConf.heartBeatInterval == NameNode.instance.namesystem.snapshotDiffReportLimit
DataNode.instance.dnConf.heartBeatInterval == blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP
DataNode.instance.dnConf.heartBeatInterval == blockManagerInstance.blockIdManager.impendingGenerationStamp.LAST_RESERVED_STAMP
DataNode.instance.dnConf.heartBeatInterval == blockManagerInstance.blockIdManager.legacyGenerationStamp.LAST_RESERVED_STAMP
DataNode.instance.dnConf.heartBeatInterval == blockManagerInstance.datanodeManager.blockInvalidateLimit
DataNode.instance.dnConf.heartBeatInterval == blockManagerInstance.invalidateBlocks.blockInvalidateLimit
DataNode.instance.dnConf.heartBeatInterval == blockManagerInstance.maxNumBlocksToLog
DataNode.instance.dnConf.ibrInterval == NameNode.instance.namesystem.editLogTailer.lastLoadedTxnId
DataNode.instance.dnConf.ibrInterval == NameNode.instance.namesystem.editLogTailer.maxSleepTimeMs
DataNode.instance.dnConf.ibrInterval == NameNode.instance.namesystem.editLogTailer.nnCount
DataNode.instance.dnConf.ibrInterval == NameNode.instance.namesystem.editLogTailer.nnLoopCount
DataNode.instance.dnConf.ibrInterval == NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.blockReportLeaseManager.deferredHead.leaseId
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.blockReportLeaseManager.deferredHead.leaseTimeMs
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.blockReportLeaseManager.pendingHead.leaseId
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.blockReportLeaseManager.pendingHead.leaseTimeMs
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.blockReportThread.lastFull
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.bmSafeMode.blockReplQueueThreshold
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.bmSafeMode.blockSafe
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.bmSafeMode.blockThreshold
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.bmSafeMode.blockTotal
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.bmSafeMode.datanodeThreshold
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.bmSafeMode.extension
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.bmSafeMode.lastStatusReport
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.bmSafeMode.reachedTime
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.corruptReplicaBlocksCount
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.datanodeManager.numStaleNodes
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.datanodeManager.numStaleStorages
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.excessRedundancyMap.size
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.heartbeatManager.stats.cacheCapacity
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.heartbeatManager.stats.cacheUsed
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.heartbeatManager.stats.expiredHeartbeats
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.invalidateBlocks.blockIdManager.legacyGenerationStampLimit
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.invalidateBlocks.pendingPeriodInMs
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.neededReconstruction.QUEUE_HIGHEST_PRIORITY
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.pendingDNMessages.count
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.pendingReconstruction.timedOutCount
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.pendingReconstructionBlocksCount
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.modification
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.size
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.providedStorageMap.capacity
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.providedStorageMap.defaultReplication
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.scheduledReplicationBlocksCount
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.startupDelayBlockDeletionInMs
DataNode.instance.dnConf.ibrInterval == daikon.Quant.size(DataNode.instance.directoryScanner.diffs_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.ibrInterval == daikon.Quant.size(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.ibrInterval == daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.ibrInterval == daikon.Quant.size(NameNode.instance.namesystem.snapshotManager.snapshottables_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.lifelineIntervalMs == NameNode.instance.namesystem.edekCacheLoaderDelay
DataNode.instance.dnConf.lifelineIntervalMs == blockManagerInstance.redundancyRecheckIntervalMs
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.haEnabled
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.namesystem.dir.skipQuotaCheck
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == NameNode.instance.namesystem.haEnabled
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == blockManagerInstance.bmSafeMode.haEnabled
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == blockManagerInstance.datanodeManager.checkIpHostnameInRegistration
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == blockManagerInstance.datanodeManager.useDfsNetworkTopology
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == blockManagerInstance.pendingReconstruction.fsRunning
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == blockManagerInstance.placementPolicies.ecPolicy.considerLoad
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == blockManagerInstance.placementPolicies.ecPolicy.preferLocalNode
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == blockManagerInstance.placementPolicies.replicationPolicy.considerLoad
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == blockManagerInstance.placementPolicies.replicationPolicy.preferLocalNode
DataNode.instance.dnConf.socketTimeout == NameNode.instance.namesystem.editLogTailer.rollEditsTimeoutMs
DataNode.instance.dnConf.volsConfigured == blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.sequenceNumber
DataNode.instance.dnConf.volsConfigured == blockManagerInstance.maxReplicationStreams
DataNode.instance.dnConf.volsConfigured == blockManagerInstance.neededReconstruction.QUEUE_LOW_REDUNDANCY
DataNode.instance.dnConf.volsConfigured == blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandMultiplier
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS == blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS == blockManagerInstance.defaultReplication
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS == blockManagerInstance.neededReconstruction.QUEUE_VERY_LOW_REDUNDANCY
DataNode.instance.httpServer.HTTP_MAX_THREADS == blockManagerInstance.neededReconstruction.QUEUE_WITH_CORRUPT_BLOCKS
DataNode.instance.httpServer.HTTP_MAX_THREADS == blockManagerInstance.placementPolicies.ecPolicy.tolerateHeartbeatMultiplier
DataNode.instance.httpServer.HTTP_MAX_THREADS == blockManagerInstance.placementPolicies.replicationPolicy.tolerateHeartbeatMultiplier
DataNode.instance.httpServer.HTTP_MAX_THREADS == blockManagerInstance.replicationStreamsHardLimit
DataNode.instance.httpServer.HTTP_MAX_THREADS == blockManagerInstance.storageInfoDefragmentTimeout
DataNode.instance.httpServer.HTTP_MAX_THREADS == blockManagerInstance.storagePolicySuite.ID_BIT_LENGTH
DataNode.instance.xserver.closed == NameNode.instance.stopRequested
NameNode.instance.namesystem.cacheManager.scanIntervalMs == blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE == blockManagerInstance.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE
NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT == NameNode.instance.namesystem.editLogTailer.maxTxnsPerLock
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs == NameNode.instance.namesystem.editLogTailer.lastRollTimeMs
NameNode.instance.namesystem.editLogTailer.maxRetries == blockManagerInstance.neededReconstruction.QUEUE_REPLICAS_BADLY_DISTRIBUTED
NameNode.instance.namesystem.editLogTailer.maxRetries == blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.shrinkThreshold
NameNode.instance.namesystem.editLogTailer.maxRetries == daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.fsRunning == blockManagerInstance.shouldPostponeBlocksFromFuture
blockManagerInstance.lastRedundancyCycleTS == daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.bmSafeMode.safeReplication-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.datanodeManager.heartbeatIntervalSeconds-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.defaultReplication-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.neededReconstruction.QUEUE_VERY_LOW_REDUNDANCY-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.volsConfigured) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, NameNode.instance.namesystem.editLogTailer.maxRetries-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.volsConfigured) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.neededReconstruction.QUEUE_REPLICAS_BADLY_DISTRIBUTED-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.volsConfigured) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.shrinkThreshold-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.blocksReplWorkMultiplier-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.sequenceNumber-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.maxReplicationStreams-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.neededReconstruction.QUEUE_LOW_REDUNDANCY-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandMultiplier-1)
DataNode.instance.dnConf.heartBeatInterval == 1000
DataNode.instance.dnConf.lifelineIntervalMs == 3000
DataNode.instance.id.infoPort == 38463
DataNode.instance.id.ipcPort == 41123
DataNode.instance.id.nsInfo.cTime == 1731382268417L || DataNode.instance.id.nsInfo.cTime == 1731382273544L
DataNode.instance.id.nsInfo.namespaceID == 364058305 || DataNode.instance.id.nsInfo.namespaceID == 1079442884
DataNode.instance.id.xferPort == 45205
DataNode.instance.lastDiskErrorCheck == 118379332
DataNode.instance.storage.namespaceID == 0 || DataNode.instance.storage.namespaceID == 364058305 || DataNode.instance.storage.namespaceID == 1079442884
DataNode.instance.volumeChecker.lastAllVolumesCheck == 117478995 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 118377438 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 118379331
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118376621 || DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118378997
NameNode.instance.ACTIVE_STATE.lastHATransitionTime == 1731382272856L
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 26 || NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 30
NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT == 9223372036854775807L
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs == 118376571 || NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs == 118378975
NameNode.instance.namesystem.editLogTailer.lastRollTriggerTxId == -12345
NameNode.instance.namesystem.editLogTailer.logRollPeriodMs == -1000
NameNode.instance.namesystem.editLogTailer.maxRetries == 3
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118377956792082L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118378976058927L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118379357998457L
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118376313 || NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118378743
NameNode.instance.namesystem.startTime == 1731382271405L || NameNode.instance.namesystem.startTime == 1731382273835L
blockManagerInstance.blockReportLeaseManager.nextId == 8333661402711551890L || blockManagerInstance.blockReportLeaseManager.nextId == 8333661402711551891L
blockManagerInstance.bmSafeMode.startTime == 0 || blockManagerInstance.bmSafeMode.startTime == 118378968
blockManagerInstance.datanodeManager.heartbeatExpireInterval == 610000
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 0 || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 92912230400L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 0 || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 34315960320L
blockManagerInstance.invalidateBlocks.startupTime == 118378747
daikon.Quant.fuzzy.eq(blockManagerInstance.reconstructionQueuesInitProgress, 0.0)
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < DataNode.instance.id.nsInfo.cTime
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < NameNode.instance.namesystem.startTime
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME < DataNode.instance.id.nsInfo.cTime
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME < NameNode.instance.namesystem.startTime
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS < DataNode.instance.id.nsInfo.cTime
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS < NameNode.instance.namesystem.startTime
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.cacheManager.numBlocksCached < DataNode.instance.id.nsInfo.cTime
DataNode.instance.data.cacheManager.numBlocksCached < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.data.cacheManager.numBlocksCached < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.data.cacheManager.numBlocksCached < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.cacheManager.numBlocksCached < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.data.cacheManager.numBlocksCached < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.data.cacheManager.numBlocksCached < NameNode.instance.namesystem.startTime
DataNode.instance.data.cacheManager.numBlocksCached <= blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.cacheManager.revocationMs < DataNode.instance.id.nsInfo.cTime
DataNode.instance.data.cacheManager.revocationMs < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.data.cacheManager.revocationMs < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.data.cacheManager.revocationMs > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.cacheManager.revocationMs < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.data.cacheManager.revocationMs < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.data.cacheManager.revocationMs < NameNode.instance.namesystem.startTime
DataNode.instance.data.cacheManager.revocationMs != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.cacheManager.revocationPollingMs < DataNode.instance.id.nsInfo.cTime
DataNode.instance.data.cacheManager.revocationPollingMs < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.data.cacheManager.revocationPollingMs < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.data.cacheManager.revocationPollingMs > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.cacheManager.revocationPollingMs < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.data.cacheManager.revocationPollingMs < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.data.cacheManager.revocationPollingMs < NameNode.instance.namesystem.startTime
DataNode.instance.data.cacheManager.revocationPollingMs != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.maxDataLength < DataNode.instance.id.nsInfo.cTime
DataNode.instance.data.maxDataLength < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.data.maxDataLength < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.data.maxDataLength > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.maxDataLength < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.data.maxDataLength < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.data.maxDataLength < NameNode.instance.namesystem.startTime
DataNode.instance.data.maxDataLength != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.smallBufferSize < DataNode.instance.id.nsInfo.cTime
DataNode.instance.data.smallBufferSize < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.data.smallBufferSize < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.data.smallBufferSize > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.smallBufferSize < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.data.smallBufferSize < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.data.smallBufferSize < NameNode.instance.namesystem.startTime
DataNode.instance.data.smallBufferSize != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.volsConfigured < DataNode.instance.id.nsInfo.cTime
DataNode.instance.data.volsConfigured < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.data.volsConfigured < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.data.volsConfigured < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.volsConfigured < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.data.volsConfigured < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.data.volsConfigured < NameNode.instance.namesystem.startTime
DataNode.instance.data.volsConfigured != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.directoryScanner.diffs.serialVersionUID < DataNode.instance.id.nsInfo.cTime
DataNode.instance.directoryScanner.diffs.serialVersionUID < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.directoryScanner.diffs.serialVersionUID > DataNode.instance.storage.layoutVersion
DataNode.instance.directoryScanner.diffs.serialVersionUID < DataNode.instance.storage.namespaceID
DataNode.instance.directoryScanner.diffs.serialVersionUID < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.directoryScanner.diffs.serialVersionUID < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.directoryScanner.diffs.serialVersionUID < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.directoryScanner.diffs.serialVersionUID < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.directoryScanner.diffs.serialVersionUID < NameNode.instance.namesystem.startTime
DataNode.instance.directoryScanner.diffs.serialVersionUID != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.directoryScanner.diffs.serialVersionUID >= blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.dnConf.blockReportInterval < DataNode.instance.id.nsInfo.cTime
DataNode.instance.dnConf.blockReportInterval < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.dnConf.blockReportInterval < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.dnConf.blockReportInterval > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.blockReportInterval < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.dnConf.blockReportInterval < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.dnConf.blockReportInterval < NameNode.instance.namesystem.startTime
DataNode.instance.dnConf.blockReportInterval != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.blockReportSplitThreshold < DataNode.instance.id.nsInfo.cTime
DataNode.instance.dnConf.blockReportSplitThreshold < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.dnConf.blockReportSplitThreshold < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.dnConf.blockReportSplitThreshold > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.blockReportSplitThreshold < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.dnConf.blockReportSplitThreshold < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.dnConf.blockReportSplitThreshold < NameNode.instance.namesystem.startTime
DataNode.instance.dnConf.blockReportSplitThreshold != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.bpReadyTimeout < DataNode.instance.id.nsInfo.cTime
DataNode.instance.dnConf.bpReadyTimeout < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.dnConf.bpReadyTimeout < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.dnConf.bpReadyTimeout < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.bpReadyTimeout < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.dnConf.bpReadyTimeout < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.dnConf.bpReadyTimeout < NameNode.instance.namesystem.startTime
DataNode.instance.dnConf.bpReadyTimeout != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.cacheReportInterval < DataNode.instance.id.nsInfo.cTime
DataNode.instance.dnConf.cacheReportInterval < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.dnConf.cacheReportInterval < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.dnConf.cacheReportInterval > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.cacheReportInterval < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.dnConf.cacheReportInterval < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.dnConf.cacheReportInterval < NameNode.instance.namesystem.startTime
DataNode.instance.dnConf.cacheReportInterval != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs < DataNode.instance.id.nsInfo.cTime
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs < NameNode.instance.namesystem.startTime
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.heartBeatInterval < DataNode.instance.id.nsInfo.cTime
DataNode.instance.dnConf.heartBeatInterval < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.dnConf.heartBeatInterval < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.dnConf.heartBeatInterval > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.heartBeatInterval < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.dnConf.heartBeatInterval < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.dnConf.heartBeatInterval < NameNode.instance.namesystem.startTime
DataNode.instance.dnConf.heartBeatInterval != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.ibrInterval < DataNode.instance.id.nsInfo.cTime
DataNode.instance.dnConf.ibrInterval < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.dnConf.ibrInterval < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.dnConf.ibrInterval < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.ibrInterval < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.dnConf.ibrInterval < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.dnConf.ibrInterval < NameNode.instance.namesystem.startTime
DataNode.instance.dnConf.ibrInterval <= blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.lifelineIntervalMs < DataNode.instance.id.nsInfo.cTime
DataNode.instance.dnConf.lifelineIntervalMs < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.dnConf.lifelineIntervalMs < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.dnConf.lifelineIntervalMs > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.lifelineIntervalMs < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.dnConf.lifelineIntervalMs < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.dnConf.lifelineIntervalMs < NameNode.instance.namesystem.startTime
DataNode.instance.dnConf.lifelineIntervalMs != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.maxDataLength < DataNode.instance.id.nsInfo.cTime
DataNode.instance.dnConf.maxDataLength < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.dnConf.maxDataLength < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.dnConf.maxDataLength > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.maxDataLength < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.dnConf.maxDataLength < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.dnConf.maxDataLength < NameNode.instance.namesystem.startTime
DataNode.instance.dnConf.maxDataLength != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.outliersReportIntervalMs < DataNode.instance.id.nsInfo.cTime
DataNode.instance.dnConf.outliersReportIntervalMs < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.dnConf.outliersReportIntervalMs < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.dnConf.outliersReportIntervalMs > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.outliersReportIntervalMs < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.dnConf.outliersReportIntervalMs < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.dnConf.outliersReportIntervalMs < NameNode.instance.namesystem.startTime
DataNode.instance.dnConf.outliersReportIntervalMs != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.readaheadLength < DataNode.instance.id.nsInfo.cTime
DataNode.instance.dnConf.readaheadLength < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.dnConf.readaheadLength < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.dnConf.readaheadLength > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.readaheadLength < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.dnConf.readaheadLength < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.dnConf.readaheadLength < NameNode.instance.namesystem.startTime
DataNode.instance.dnConf.readaheadLength != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.restartReplicaExpiry < DataNode.instance.id.nsInfo.cTime
DataNode.instance.dnConf.restartReplicaExpiry < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.dnConf.restartReplicaExpiry < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.dnConf.restartReplicaExpiry > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.restartReplicaExpiry < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.dnConf.restartReplicaExpiry < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.dnConf.restartReplicaExpiry < NameNode.instance.namesystem.startTime
DataNode.instance.dnConf.restartReplicaExpiry != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.socketKeepaliveTimeout < DataNode.instance.id.nsInfo.cTime
DataNode.instance.dnConf.socketKeepaliveTimeout < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.dnConf.socketKeepaliveTimeout < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.dnConf.socketKeepaliveTimeout > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.socketKeepaliveTimeout < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.dnConf.socketKeepaliveTimeout < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.dnConf.socketKeepaliveTimeout < NameNode.instance.namesystem.startTime
DataNode.instance.dnConf.socketKeepaliveTimeout != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.socketTimeout < DataNode.instance.id.nsInfo.cTime
DataNode.instance.dnConf.socketTimeout < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.dnConf.socketTimeout < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.dnConf.socketTimeout > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.socketTimeout < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.dnConf.socketTimeout < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.dnConf.socketTimeout < NameNode.instance.namesystem.startTime
DataNode.instance.dnConf.socketTimeout != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.socketWriteTimeout < DataNode.instance.id.nsInfo.cTime
DataNode.instance.dnConf.socketWriteTimeout < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.dnConf.socketWriteTimeout < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.dnConf.socketWriteTimeout > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.dnConf.socketWriteTimeout < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.dnConf.socketWriteTimeout < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.dnConf.socketWriteTimeout < NameNode.instance.namesystem.startTime
DataNode.instance.dnConf.socketWriteTimeout != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.dnConf.volsConfigured != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS < DataNode.instance.id.nsInfo.cTime
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS < NameNode.instance.namesystem.startTime
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.httpServer.HTTP_MAX_THREADS < DataNode.instance.id.nsInfo.cTime
DataNode.instance.httpServer.HTTP_MAX_THREADS < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.httpServer.HTTP_MAX_THREADS < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.httpServer.HTTP_MAX_THREADS < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.httpServer.HTTP_MAX_THREADS < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.httpServer.HTTP_MAX_THREADS < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.httpServer.HTTP_MAX_THREADS < NameNode.instance.namesystem.startTime
DataNode.instance.httpServer.HTTP_MAX_THREADS != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.id.nsInfo.cTime > DataNode.instance.id.nsInfo.layoutVersion
DataNode.instance.id.nsInfo.cTime > DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.id.nsInfo.cTime > DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks
DataNode.instance.id.nsInfo.cTime > DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout
DataNode.instance.id.nsInfo.cTime > DataNode.instance.xserver.balanceThrottler.bytesPerPeriod
DataNode.instance.id.nsInfo.cTime > DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.id.nsInfo.cTime > DataNode.instance.xserver.balanceThrottler.maxThreads
DataNode.instance.id.nsInfo.cTime > DataNode.instance.xserver.balanceThrottler.period
DataNode.instance.id.nsInfo.cTime > DataNode.instance.xserver.balanceThrottler.periodExtension
DataNode.instance.id.nsInfo.cTime > DataNode.instance.xserver.estimateBlockSize
DataNode.instance.id.nsInfo.cTime > DataNode.instance.xserver.maxXceiverCount
DataNode.instance.id.nsInfo.cTime != NameNode.instance.ACTIVE_STATE.lastHATransitionTime
DataNode.instance.id.nsInfo.cTime > NameNode.instance.DEFAULT_PORT
DataNode.instance.id.nsInfo.cTime > NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.cacheManager.scanIntervalMs
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.dir.inodeXAttrsLimit
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.dir.maxComponentLength
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.dir.maxDirItems
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.dir.xattrMaxSize
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.editLogRollerThreshold
DataNode.instance.id.nsInfo.cTime < NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.editLogTailer.lastRollTriggerTxId
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.editLogTailer.logRollPeriodMs
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.editLogTailer.maxRetries
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.leaseManager.hardLimit
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.leaseRecheckIntervalMs
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.nnResourceChecker.duReserved
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit
DataNode.instance.id.nsInfo.cTime < NameNode.instance.namesystem.startTime
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.blockReportLeaseManager.maxPending
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.blocksMap.capacity
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.datanodeManager.defaultInfoPort
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.datanodeManager.defaultInfoSecurePort
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.datanodeManager.defaultIpcPort
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.datanodeManager.defaultXferPort
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.datanodeManager.heartbeatExpireInterval
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.neededReconstruction.LEVEL
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.replQueueResetToHeadThreshold
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.storagePolicySuite.defaultPolicyID
DataNode.instance.id.nsInfo.layoutVersion < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.id.nsInfo.layoutVersion < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.id.nsInfo.layoutVersion < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.id.nsInfo.layoutVersion < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.id.nsInfo.layoutVersion < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.id.nsInfo.layoutVersion < NameNode.instance.namesystem.startTime
DataNode.instance.id.nsInfo.namespaceID > DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks
DataNode.instance.id.nsInfo.namespaceID > DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout
DataNode.instance.id.nsInfo.namespaceID > DataNode.instance.xserver.balanceThrottler.bytesPerPeriod
DataNode.instance.id.nsInfo.namespaceID > DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.id.nsInfo.namespaceID > DataNode.instance.xserver.balanceThrottler.maxThreads
DataNode.instance.id.nsInfo.namespaceID > DataNode.instance.xserver.balanceThrottler.period
DataNode.instance.id.nsInfo.namespaceID > DataNode.instance.xserver.balanceThrottler.periodExtension
DataNode.instance.id.nsInfo.namespaceID > DataNode.instance.xserver.estimateBlockSize
DataNode.instance.id.nsInfo.namespaceID > DataNode.instance.xserver.maxXceiverCount
DataNode.instance.id.nsInfo.namespaceID < NameNode.instance.ACTIVE_STATE.lastHATransitionTime
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.DEFAULT_PORT
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.cacheManager.scanIntervalMs
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.dir.inodeXAttrsLimit
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.dir.maxComponentLength
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.dir.maxDirItems
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.dir.xattrMaxSize
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.editLogRollerThreshold
DataNode.instance.id.nsInfo.namespaceID < NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.editLogTailer.lastRollTriggerTxId
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.editLogTailer.logRollPeriodMs
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.editLogTailer.maxRetries
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.leaseManager.hardLimit
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.leaseRecheckIntervalMs
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.nnResourceChecker.duReserved
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit
DataNode.instance.id.nsInfo.namespaceID < NameNode.instance.namesystem.startTime
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
DataNode.instance.id.nsInfo.namespaceID != blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.blockReportLeaseManager.maxPending
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.blocksMap.capacity
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.datanodeManager.defaultInfoPort
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.datanodeManager.defaultInfoSecurePort
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.datanodeManager.defaultIpcPort
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.datanodeManager.defaultXferPort
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.datanodeManager.heartbeatExpireInterval
DataNode.instance.id.nsInfo.namespaceID != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.id.nsInfo.namespaceID != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.id.nsInfo.namespaceID != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.neededReconstruction.LEVEL
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.replQueueResetToHeadThreshold
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.storagePolicySuite.defaultPolicyID
DataNode.instance.storage.layoutVersion < NameNode.instance.ACTIVE_STATE.lastHATransitionTime
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.storage.layoutVersion > NameNode.instance.namesystem.editLogTailer.lastRollTriggerTxId
DataNode.instance.storage.layoutVersion > NameNode.instance.namesystem.editLogTailer.logRollPeriodMs
DataNode.instance.storage.namespaceID < NameNode.instance.ACTIVE_STATE.lastHATransitionTime
DataNode.instance.storage.namespaceID < NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.editLogTailer.lastRollTriggerTxId
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.editLogTailer.logRollPeriodMs
DataNode.instance.storage.namespaceID != NameNode.instance.namesystem.editLogTailer.maxRetries
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks < NameNode.instance.namesystem.startTime
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout < NameNode.instance.namesystem.startTime
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.volumeChecker.lastAllVolumesCheck < NameNode.instance.ACTIVE_STATE.lastHATransitionTime
DataNode.instance.volumeChecker.lastAllVolumesCheck < NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT
DataNode.instance.volumeChecker.lastAllVolumesCheck != NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.editLogTailer.lastRollTriggerTxId
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.editLogTailer.logRollPeriodMs
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.editLogTailer.maxRetries
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.ACTIVE_STATE.lastHATransitionTime
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT
DataNode.instance.volumeChecker.numSyncDatasetChecks < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.volumeChecker.numSyncDatasetChecks > NameNode.instance.namesystem.editLogTailer.lastRollTriggerTxId
DataNode.instance.volumeChecker.numSyncDatasetChecks > NameNode.instance.namesystem.editLogTailer.logRollPeriodMs
DataNode.instance.volumeChecker.numSyncDatasetChecks != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod < NameNode.instance.namesystem.startTime
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.xserver.balanceThrottler.curPeriodStart > DataNode.instance.xserver.balanceThrottler.maxThreads
DataNode.instance.xserver.balanceThrottler.curPeriodStart > DataNode.instance.xserver.balanceThrottler.period
DataNode.instance.xserver.balanceThrottler.curPeriodStart > DataNode.instance.xserver.balanceThrottler.periodExtension
DataNode.instance.xserver.balanceThrottler.curPeriodStart < DataNode.instance.xserver.estimateBlockSize
DataNode.instance.xserver.balanceThrottler.curPeriodStart > DataNode.instance.xserver.maxXceiverCount
DataNode.instance.xserver.balanceThrottler.curPeriodStart < NameNode.instance.ACTIVE_STATE.lastHATransitionTime
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.DEFAULT_PORT
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.cacheManager.scanIntervalMs
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.dir.inodeXAttrsLimit
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.dir.maxComponentLength
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.dir.maxDirItems
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.dir.xattrMaxSize
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.editLogRollerThreshold
DataNode.instance.xserver.balanceThrottler.curPeriodStart < NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.editLogTailer.lastRollTriggerTxId
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.editLogTailer.logRollPeriodMs
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.editLogTailer.maxRetries
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.leaseManager.hardLimit
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.leaseRecheckIntervalMs
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.nnResourceChecker.duReserved
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit
DataNode.instance.xserver.balanceThrottler.curPeriodStart < NameNode.instance.namesystem.startTime
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
DataNode.instance.xserver.balanceThrottler.curPeriodStart < blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.blockReportLeaseManager.maxPending
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.blocksMap.capacity
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.datanodeManager.defaultInfoPort
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.datanodeManager.defaultInfoSecurePort
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.datanodeManager.defaultIpcPort
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.datanodeManager.defaultXferPort
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.datanodeManager.heartbeatExpireInterval
DataNode.instance.xserver.balanceThrottler.curPeriodStart != blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.neededReconstruction.LEVEL
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.replQueueResetToHeadThreshold
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.storagePolicySuite.defaultPolicyID
DataNode.instance.xserver.balanceThrottler.maxThreads > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.xserver.balanceThrottler.maxThreads < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.xserver.balanceThrottler.maxThreads < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.xserver.balanceThrottler.maxThreads < NameNode.instance.namesystem.startTime
DataNode.instance.xserver.balanceThrottler.maxThreads != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.xserver.balanceThrottler.period > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.xserver.balanceThrottler.period < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.xserver.balanceThrottler.period < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.xserver.balanceThrottler.period < NameNode.instance.namesystem.startTime
DataNode.instance.xserver.balanceThrottler.period != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.xserver.balanceThrottler.periodExtension > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.xserver.balanceThrottler.periodExtension < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.xserver.balanceThrottler.periodExtension < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.xserver.balanceThrottler.periodExtension < NameNode.instance.namesystem.startTime
DataNode.instance.xserver.balanceThrottler.periodExtension != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.xserver.estimateBlockSize > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.xserver.estimateBlockSize > NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.xserver.estimateBlockSize > NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.xserver.estimateBlockSize < NameNode.instance.namesystem.startTime
DataNode.instance.xserver.maxXceiverCount > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.xserver.maxXceiverCount < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
DataNode.instance.xserver.maxXceiverCount < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.xserver.maxXceiverCount < NameNode.instance.namesystem.startTime
DataNode.instance.xserver.maxXceiverCount != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.ACTIVE_STATE.lastHATransitionTime > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.ACTIVE_STATE.lastHATransitionTime > NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
NameNode.instance.ACTIVE_STATE.lastHATransitionTime < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.ACTIVE_STATE.lastHATransitionTime > NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.ACTIVE_STATE.lastHATransitionTime != NameNode.instance.namesystem.startTime
NameNode.instance.ACTIVE_STATE.lastHATransitionTime < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.ACTIVE_STATE.lastHATransitionTime > blockManagerInstance.bmSafeMode.startTime
NameNode.instance.ACTIVE_STATE.lastHATransitionTime > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.ACTIVE_STATE.lastHATransitionTime > blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.ACTIVE_STATE.lastHATransitionTime > blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.ACTIVE_STATE.lastHATransitionTime > blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.ACTIVE_STATE.lastHATransitionTime > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.DEFAULT_PORT > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.DEFAULT_PORT < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
NameNode.instance.DEFAULT_PORT < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.DEFAULT_PORT < NameNode.instance.namesystem.startTime
NameNode.instance.DEFAULT_PORT != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS < NameNode.instance.namesystem.startTime
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < NameNode.instance.namesystem.cacheManager.scanIntervalMs
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < NameNode.instance.namesystem.dir.inodeXAttrsLimit
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < NameNode.instance.namesystem.dir.maxComponentLength
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < NameNode.instance.namesystem.dir.maxDirItems
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < NameNode.instance.namesystem.dir.xattrMaxSize
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < NameNode.instance.namesystem.editLogRollerThreshold
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > NameNode.instance.namesystem.editLogTailer.lastRollTriggerTxId
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > NameNode.instance.namesystem.editLogTailer.logRollPeriodMs
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > NameNode.instance.namesystem.editLogTailer.maxRetries
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < NameNode.instance.namesystem.leaseManager.hardLimit
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < NameNode.instance.namesystem.leaseRecheckIntervalMs
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < NameNode.instance.namesystem.nnResourceChecker.duReserved
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE <= blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.blockReportLeaseManager.maxPending
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.blocksMap.capacity
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.datanodeManager.defaultInfoPort
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.datanodeManager.defaultInfoSecurePort
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.datanodeManager.defaultIpcPort
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.datanodeManager.defaultXferPort
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.datanodeManager.heartbeatExpireInterval
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.neededReconstruction.LEVEL
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.replQueueResetToHeadThreshold
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.storagePolicySuite.defaultPolicyID
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.cacheManager.scanIntervalMs < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
NameNode.instance.namesystem.cacheManager.scanIntervalMs < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.cacheManager.scanIntervalMs < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.cacheManager.scanIntervalMs != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.dir.inodeXAttrsLimit < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
NameNode.instance.namesystem.dir.inodeXAttrsLimit < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.dir.inodeXAttrsLimit < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.dir.inodeXAttrsLimit != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.dir.maxComponentLength < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
NameNode.instance.namesystem.dir.maxComponentLength < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.dir.maxComponentLength < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.dir.maxComponentLength != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.dir.maxDirItems < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
NameNode.instance.namesystem.dir.maxDirItems < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.dir.maxDirItems < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.dir.maxDirItems != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.dir.xattrMaxSize < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
NameNode.instance.namesystem.dir.xattrMaxSize < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.dir.xattrMaxSize < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.dir.xattrMaxSize != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.editLogRollerThreshold < NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
NameNode.instance.namesystem.editLogRollerThreshold < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.editLogRollerThreshold < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.editLogRollerThreshold != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT > NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs
NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT > NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT > NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT > NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT > blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT > blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT > blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT > blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.editLogTailer.DFS_HA_TAILEDITS_MAX_TXNS_PER_LOCK_DEFAULT > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > NameNode.instance.namesystem.editLogTailer.lastRollTriggerTxId
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > NameNode.instance.namesystem.editLogTailer.logRollPeriodMs
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > NameNode.instance.namesystem.editLogTailer.maxRetries
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > NameNode.instance.namesystem.leaseManager.hardLimit
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > NameNode.instance.namesystem.leaseRecheckIntervalMs
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > NameNode.instance.namesystem.nnResourceChecker.duReserved
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs < blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > blockManagerInstance.blockReportLeaseManager.maxPending
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > blockManagerInstance.blocksMap.capacity
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > blockManagerInstance.datanodeManager.defaultInfoPort
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > blockManagerInstance.datanodeManager.defaultInfoSecurePort
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > blockManagerInstance.datanodeManager.defaultIpcPort
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > blockManagerInstance.datanodeManager.defaultXferPort
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > blockManagerInstance.datanodeManager.heartbeatExpireInterval
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs != blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > blockManagerInstance.neededReconstruction.LEVEL
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > blockManagerInstance.replQueueResetToHeadThreshold
NameNode.instance.namesystem.editLogTailer.lastLoadTimeMs > blockManagerInstance.storagePolicySuite.defaultPolicyID
NameNode.instance.namesystem.editLogTailer.lastRollTriggerTxId < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.namesystem.editLogTailer.lastRollTriggerTxId < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.editLogTailer.lastRollTriggerTxId < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.editLogTailer.lastRollTriggerTxId < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.editLogTailer.lastRollTriggerTxId < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.editLogTailer.lastRollTriggerTxId < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.editLogTailer.lastRollTriggerTxId < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.editLogTailer.lastRollTriggerTxId < blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.editLogTailer.lastRollTriggerTxId < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.editLogTailer.lastRollTriggerTxId < blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.editLogTailer.logRollPeriodMs < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.namesystem.editLogTailer.logRollPeriodMs < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.editLogTailer.logRollPeriodMs < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.editLogTailer.logRollPeriodMs < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.editLogTailer.logRollPeriodMs < blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.editLogTailer.logRollPeriodMs < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.editLogTailer.logRollPeriodMs < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.editLogTailer.logRollPeriodMs < blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.editLogTailer.logRollPeriodMs < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.editLogTailer.logRollPeriodMs < blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.editLogTailer.maxRetries < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
NameNode.instance.namesystem.editLogTailer.maxRetries < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.editLogTailer.maxRetries < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.editLogTailer.maxRetries < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.editLogTailer.maxRetries != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.editLogTailer.maxRetries != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.editLogTailer.maxRetries != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.editLogTailer.maxRetries != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.editLogTailer.maxRetries != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.leaseManager.hardLimit < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.leaseManager.hardLimit < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.leaseManager.hardLimit != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > NameNode.instance.namesystem.leaseRecheckIntervalMs
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > NameNode.instance.namesystem.nnResourceChecker.duReserved
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime < blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.blockReportLeaseManager.maxPending
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.blocksMap.capacity
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.datanodeManager.defaultInfoPort
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.datanodeManager.defaultInfoSecurePort
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.datanodeManager.defaultIpcPort
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.datanodeManager.defaultXferPort
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.datanodeManager.heartbeatExpireInterval
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.neededReconstruction.LEVEL
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.replQueueResetToHeadThreshold
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.storagePolicySuite.defaultPolicyID
NameNode.instance.namesystem.leaseRecheckIntervalMs < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.leaseRecheckIntervalMs != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.nnResourceChecker.duReserved < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.nnResourceChecker.duReserved != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.startTime > blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
NameNode.instance.namesystem.startTime > blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
NameNode.instance.namesystem.startTime > blockManagerInstance.blockReportLeaseManager.maxPending
NameNode.instance.namesystem.startTime > blockManagerInstance.blocksMap.capacity
NameNode.instance.namesystem.startTime > blockManagerInstance.datanodeManager.defaultInfoPort
NameNode.instance.namesystem.startTime > blockManagerInstance.datanodeManager.defaultInfoSecurePort
NameNode.instance.namesystem.startTime > blockManagerInstance.datanodeManager.defaultIpcPort
NameNode.instance.namesystem.startTime > blockManagerInstance.datanodeManager.defaultXferPort
NameNode.instance.namesystem.startTime > blockManagerInstance.datanodeManager.heartbeatExpireInterval
NameNode.instance.namesystem.startTime > blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.startTime > blockManagerInstance.neededReconstruction.LEVEL
NameNode.instance.namesystem.startTime > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
NameNode.instance.namesystem.startTime > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
NameNode.instance.namesystem.startTime > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
NameNode.instance.namesystem.startTime > blockManagerInstance.replQueueResetToHeadThreshold
NameNode.instance.namesystem.startTime > blockManagerInstance.storagePolicySuite.defaultPolicyID
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs == blockManagerInstance.datanodeManager.timeBetweenResendingCachingDirectivesMs
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs == blockManagerInstance.placementPolicies.ecPolicy.staleInterval
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs == blockManagerInstance.placementPolicies.replicationPolicy.staleInterval
DataNode.instance.data.fsRunning == NameNode.instance.namesystem.alwaysUseDelegationTokensForTests
DataNode.instance.id.infoPort == 42617
DataNode.instance.id.ipcPort == 34951
DataNode.instance.id.nsInfo.cTime == 1731382408191L
DataNode.instance.id.nsInfo.namespaceID == 419279956
DataNode.instance.id.xferPort == 45491
DataNode.instance.lastDiskErrorCheck == 118516966
DataNode.instance.volumeChecker.lastAllVolumesCheck == 118516959
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118516245
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118515900
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118514559
NameNode.instance.namesystem.startTime == 1731382409651L
blockManagerInstance.blockReportLeaseManager.nextId == 5932638678100223020L
blockManagerInstance.bmSafeMode.startTime == 118515255
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185410699264L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69045682176L
blockManagerInstance.invalidateBlocks.startupTime == 118514561
blockManagerInstance.lastRedundancyCycleTS == 118518255
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS == DataNode.instance.data.asyncDiskService.numDeletedBlocks
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS == DataNode.instance.data.cacheManager.numBlocksFailedToUncache
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 139924 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 147137
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185296060416L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185313443840L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69142888767L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69160279404L
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 2 || blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 3
blockManagerInstance.lastRedundancyCycleTS == 118536258
DataNode.instance.data.volsConfigured <= blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.dir.maxComponentLength < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.dir.maxComponentLength < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.dir.maxComponentLength < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount < blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 139924
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185296060416L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69160279404L
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 147137
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185313443840L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69142888767L
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 144020
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185379176448L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69077159276L
blockManagerInstance.lastRedundancyCycleTS == 118524256
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 27
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 154410
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185361907712L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69094417622L
blockManagerInstance.lastRedundancyCycleTS == 118527256
blockManagerInstance.lastRedundancyCycleTS == 118521256
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 27 || DataNode.instance.data.asyncDiskService.numDeletedBlocks == 49 || DataNode.instance.data.asyncDiskService.numDeletedBlocks == 60
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 60 || DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 89 || DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 113
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 162752 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 177298
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185226690560L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185245106176L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69211210816L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69229611886L
blockManagerInstance.lastRedundancyCycleTS == 118548259
blockManagerInstance.replQueueCallsSinceReset == 11
DataNode.instance.NUM_CORES != DataNode.instance.data.asyncDiskService.numDeletedBlocks
DataNode.instance.NUM_CORES < DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS != DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS >= DataNode.instance.data.asyncDiskService.numDeletedBlocks
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS <= DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.asyncDiskService.numDeletedBlocks <= DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS
DataNode.instance.data.asyncDiskService.numDeletedBlocks < NameNode.instance.namesystem.dir.maxComponentLength
DataNode.instance.data.asyncDiskService.numDeletedBlocks != blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
DataNode.instance.data.asyncDiskService.numDeletedBlocks > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > DataNode.instance.dnConf.bpReadyTimeout
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > DataNode.instance.xserver.balanceThrottler.maxThreads
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.cacheManager.numBlocksFailedToUncache != NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.dir.maxComponentLength
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 139924 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 140963
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185280233472L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185296060416L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69160279404L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69176105309L
blockManagerInstance.lastRedundancyCycleTS == 118539258
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 49
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 113
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 177298
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185226690560L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69229611886L
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 140963
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185280233472L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69176105309L
blockManagerInstance.lastRedundancyCycleTS == 118542258
blockManagerInstance.replQueueCallsSinceReset == 9
blockManagerInstance.lastRedundancyCycleTS == 118539258 || blockManagerInstance.lastRedundancyCycleTS == 118542258
blockManagerInstance.replQueueCallsSinceReset == 8 || blockManagerInstance.replQueueCallsSinceReset == 9
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS < blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.dir.maxComponentLength < blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.blockReportLeaseManager.maxPending < blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.replQueueCallsSinceReset > blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 110772
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185398968320L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69057400652L
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 38 || DataNode.instance.data.asyncDiskService.numDeletedBlocks == 50 || DataNode.instance.data.asyncDiskService.numDeletedBlocks == 60
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 38 || DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 48 || DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 60
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 147137 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 154410
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185313443840L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185332523008L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69123802326L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69142888767L
blockManagerInstance.lastRedundancyCycleTS == 118533257 || blockManagerInstance.lastRedundancyCycleTS == 118536258
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS >= DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.cacheManager.numBlocksFailedToUncache != DataNode.instance.xserver.balanceThrottler.maxThreads
DataNode.instance.data.cacheManager.numBlocksFailedToUncache % blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 0
9539584 * DataNode.instance.data.asyncDiskService.numDeletedBlocks + 11 * blockManagerInstance.heartbeatManager.stats.capacityRemaining + 95395840 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) - 2.03902025728E12 == 0
9539584 * DataNode.instance.data.asyncDiskService.numDeletedBlocks + 11 * blockManagerInstance.heartbeatManager.stats.capacityRemaining + 95395840 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 - 2.03892486144E12 == 0
9539584 * DataNode.instance.data.cacheManager.numBlocksFailedToUncache + 11 * blockManagerInstance.heartbeatManager.stats.capacityRemaining + 114475008 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) - 2.03902025728E12 == 0
9539584 * DataNode.instance.data.cacheManager.numBlocksFailedToUncache + 11 * blockManagerInstance.heartbeatManager.stats.capacityRemaining + 114475008 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 - 2.038905782272E12 == 0
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 142981
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185347129344L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69109215611L
blockManagerInstance.lastRedundancyCycleTS == 118527256 || blockManagerInstance.lastRedundancyCycleTS == 118530257
blockManagerInstance.replQueueCallsSinceReset == 4 || blockManagerInstance.replQueueCallsSinceReset == 5
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME <= blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.lastRedundancyCycleTS == 118530257
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 152362
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185260982272L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69195345110L
blockManagerInstance.lastRedundancyCycleTS == 118542258 || blockManagerInstance.lastRedundancyCycleTS == 118545259
blockManagerInstance.replQueueCallsSinceReset == 9 || blockManagerInstance.replQueueCallsSinceReset == 10
DataNode.instance.diskBalancer.bandwidth >= blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.diskBalancer.bandwidth == blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 162752
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185245106176L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69211210816L
blockManagerInstance.lastRedundancyCycleTS == 118545259
blockManagerInstance.lastRedundancyCycleTS == 118536258 || blockManagerInstance.lastRedundancyCycleTS == 118539258
blockManagerInstance.replQueueCallsSinceReset >= blockManagerInstance.storagePolicySuite.defaultPolicyID
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == DataNode.instance.volumeChecker.numSkippedChecks
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == blockManagerInstance.bmSafeMode.blockReplQueueThreshold
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == blockManagerInstance.bmSafeMode.blockSafe
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == blockManagerInstance.bmSafeMode.blockThreshold
DataNode.instance.data.asyncDiskService.numDeletedBlocks == NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.data.volsConfigured == blockManagerInstance.bmSafeMode.blockTotal
blockManagerInstance.bmSafeMode.lastStatusReport == blockManagerInstance.bmSafeMode.startTime
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.bmSafeMode.blockTotal-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.volumeChecker.numSkippedChecks-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.bmSafeMode.blockReplQueueThreshold-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.bmSafeMode.blockSafe-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.bmSafeMode.blockThreshold-1)
DataNode.instance.id.infoPort == 42037
DataNode.instance.id.ipcPort == 40665
DataNode.instance.id.nsInfo.cTime == 1731382346909L
DataNode.instance.id.nsInfo.namespaceID == 1028734054
DataNode.instance.id.xferPort == 41813
DataNode.instance.lastDiskErrorCheck == 118456694
DataNode.instance.storage.namespaceID == 226535997
DataNode.instance.volumeChecker.lastAllVolumesCheck == 118456252
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118455282
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 54
NameNode.instance.namesystem.fsImage.lastAppliedTxId == 39
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118483782601614L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118485379598313L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118485384859832L
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118479033
NameNode.instance.namesystem.startTime == 1731382374125L
blockManagerInstance.blockReportLeaseManager.nextId == 8708349875696419992L
blockManagerInstance.bmSafeMode.lastStatusReport == 118479375
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 98376
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185565659136L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 217493
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68890603115L
blockManagerInstance.invalidateBlocks.startupTime == 118479044
blockManagerInstance.lastRedundancyCycleTS == 118482378 || blockManagerInstance.lastRedundancyCycleTS == 118485379
blockManagerInstance.lowRedundancyBlocksCount == 1 || blockManagerInstance.lowRedundancyBlocksCount == 2
daikon.Quant.fuzzy.eq(blockManagerInstance.reconstructionQueuesInitProgress, 1.0)
blockManagerInstance.replQueueCallsSinceReset == 1 || blockManagerInstance.replQueueCallsSinceReset == 2
DataNode.instance.NUM_CORES > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME <= blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME <= blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.cacheManager.revocationMs > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.data.cacheManager.revocationPollingMs > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.data.maxDataLength > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.data.smallBufferSize > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.data.volsConfigured >= blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.directoryScanner.MILLIS_PER_SECOND > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.directoryScanner.scanPeriodMsecs > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.diskBalancer.bandwidth > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.diskBalancer.planValidityInterval > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.dnConf.blockReportSplitThreshold > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.dnConf.bpReadyTimeout > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.dnConf.cacheReportInterval > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.dnConf.heartBeatInterval > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.dnConf.lifelineIntervalMs > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.dnConf.outliersReportIntervalMs > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.dnConf.readaheadLength > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.dnConf.restartReplicaExpiry > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.dnConf.socketKeepaliveTimeout > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.dnConf.socketTimeout > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.dnConf.socketWriteTimeout > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.id.infoPort > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.id.ipcPort > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.id.nsInfo.layoutVersion < blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.id.xferPort > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.lastDiskErrorCheck > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.shortCircuitRegistry.SHM_LENGTH > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.storage.layoutVersion < blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.storage.namespaceID > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.xserver.balanceThrottler.maxThreads > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.xserver.balanceThrottler.periodExtension > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.xserver.estimateBlockSize > blockManagerInstance.lowRedundancyBlocksCount
DataNode.instance.xserver.maxXceiverCount > blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.DEFAULT_PORT > blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS > blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL > blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses > blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval > blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.namesystem.dir.maxComponentLength > blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.namesystem.dir.maxDirItems > blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.namesystem.dir.xattrMaxSize > blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.namesystem.editLogRollerThreshold > blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.fsImage.lastAppliedTxId > blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.namesystem.fsImage.lastAppliedTxId > blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.bmSafeMode.lastStatusReport
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos % blockManagerInstance.lowRedundancyBlocksCount == 0
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.namesystem.leaseManager.hardLimit > blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.namesystem.leaseRecheckIntervalMs > blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs > blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.namesystem.nnResourceChecker.duReserved > blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH > blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit > blockManagerInstance.lowRedundancyBlocksCount
NameNode.instance.namesystem.startTime > blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER > blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID > blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.blockReportLeaseManager.maxPending > blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.blocksMap.capacity > blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.bmSafeMode.lastStatusReport < blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.bmSafeMode.lastStatusReport > blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.bmSafeMode.lastStatusReport > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.datanodeManager.defaultInfoPort > blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.datanodeManager.defaultInfoSecurePort > blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.datanodeManager.defaultIpcPort > blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.datanodeManager.defaultXferPort > blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.datanodeManager.heartbeatExpireInterval > blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.heartbeatManager.stats.blockPoolUsed > blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.heartbeatManager.stats.capacityRemaining > blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.heartbeatManager.stats.capacityTotal > blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.heartbeatManager.stats.capacityUsed < blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.heartbeatManager.stats.capacityUsed > blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.heartbeatManager.stats.capacityUsed > blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs > blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.invalidateBlocks.startupTime > blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.lastRedundancyCycleTS > blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.lowRedundancyBlocksCount < blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.lowRedundancyBlocksCount < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.lowRedundancyBlocksCount < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.lowRedundancyBlocksCount < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.lowRedundancyBlocksCount < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.lowRedundancyBlocksCount != blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.lowRedundancyBlocksCount < blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.lowRedundancyBlocksCount < blockManagerInstance.storagePolicySuite.defaultPolicyID
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 26
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118454999
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118454619
NameNode.instance.namesystem.startTime == 1731382349711L
blockManagerInstance.blockReportLeaseManager.nextId == 6073730542720156053L
blockManagerInstance.bmSafeMode.startTime == 118454963
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185594593280L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 196608
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68861689856L
blockManagerInstance.invalidateBlocks.startupTime == 118454624
blockManagerInstance.heartbeatManager.stats.capacityUsed > daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == blockManagerInstance.lowRedundancyBlocksCount
blockManagerInstance.blockReportLeaseManager.maxPending == blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.blockReportLeaseManager.maxPending == blockManagerInstance.heartbeatManager.stats.xceiverCount
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.lowRedundancyBlocksCount-1)
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118487384979154L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118488379991860L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185540689920L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 235204
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68915554620L
blockManagerInstance.lastRedundancyCycleTS == 118485379 || blockManagerInstance.lastRedundancyCycleTS == 118488380
blockManagerInstance.replQueueCallsSinceReset == 2 || blockManagerInstance.replQueueCallsSinceReset == 3
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION >= blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.volsConfigured <= blockManagerInstance.replQueueCallsSinceReset
DataNode.instance.data.cacheManager.numBlocksCached == NameNode.instance.namesystem.lazyPersistFileScrubberTS
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.volumeChecker.numSkippedChecks-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.bmSafeMode.blockReplQueueThreshold-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.bmSafeMode.blockSafe-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.bmSafeMode.blockThreshold-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.lowRedundancyBlocksCount-1)
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118499385785616L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185473691648L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 230976
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68982553024L
blockManagerInstance.lastRedundancyCycleTS == 118497381
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118489385080143L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185521025024L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 249678
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68935200946L
blockManagerInstance.lastRedundancyCycleTS == 118488380
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118500381363203L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118501385937639L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118501408738383L
blockManagerInstance.lastRedundancyCycleTS == 118500381
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118491385213075L
blockManagerInstance.lastRedundancyCycleTS == 118491380
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 8
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 72
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118506382376032L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118507386343319L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185435037696L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 263215
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69021187025L
blockManagerInstance.lastRedundancyCycleTS == 118506382
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118485707278107L
blockManagerInstance.lastRedundancyCycleTS == 118485379
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118509393319764L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185417842688L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 254873
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69038382183L
blockManagerInstance.lastRedundancyCycleTS == 118509382
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118488379991860L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118489385080143L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118499385785616L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118500381363203L
blockManagerInstance.lastRedundancyCycleTS == 118497381 || blockManagerInstance.lastRedundancyCycleTS == 118500381
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118503386095075L
blockManagerInstance.lastRedundancyCycleTS == 118503381
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118501408738383L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185451757568L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 238279
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69004483897L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118495385518141L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185482870784L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 255912
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68973353048L
blockManagerInstance.lastRedundancyCycleTS == 118494380
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118491385213075L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118493385358730L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185500205056L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 264224
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68956010464L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118493385358730L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118494380683880L
DataNode.instance.data.volsConfigured == blockManagerInstance.lowRedundancyBlocksCount
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.lowRedundancyBlocksCount-1)
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118483782601614L
blockManagerInstance.lastRedundancyCycleTS == 118482378
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 8 || DataNode.instance.data.asyncDiskService.numDeletedBlocks == 60 || DataNode.instance.data.asyncDiskService.numDeletedBlocks == 63
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 60 || DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 62 || DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 72
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185451757568L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185473691648L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 230976 || blockManagerInstance.heartbeatManager.stats.capacityUsed == 238279
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68982553024L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69004483897L
DataNode.instance.NUM_CORES < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.data.asyncDiskService.numDeletedBlocks != DataNode.instance.diskBalancer.bandwidth
DataNode.instance.data.asyncDiskService.numDeletedBlocks != NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.asyncDiskService.numDeletedBlocks != NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.bmSafeMode.lastStatusReport
DataNode.instance.data.asyncDiskService.numDeletedBlocks < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.data.asyncDiskService.numDeletedBlocks != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
DataNode.instance.data.cacheManager.numBlocksCached < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.storage.namespaceID
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.bmSafeMode.lastStatusReport
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.data.cacheManager.revocationMs > blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.data.cacheManager.revocationPollingMs < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.data.maxDataLength > blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.data.smallBufferSize < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.directoryScanner.MILLIS_PER_SECOND < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.directoryScanner.scanPeriodMsecs > blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.diskBalancer.bandwidth < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.diskBalancer.planValidityInterval > blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.dnConf.blockReportSplitThreshold > blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.dnConf.bpReadyTimeout < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.dnConf.cacheReportInterval < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.dnConf.heartBeatInterval < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.dnConf.lifelineIntervalMs < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.dnConf.outliersReportIntervalMs > blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.dnConf.readaheadLength > blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.dnConf.restartReplicaExpiry < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.dnConf.socketKeepaliveTimeout < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.dnConf.socketTimeout < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.dnConf.socketWriteTimeout > blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.id.infoPort < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.id.ipcPort < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.id.nsInfo.layoutVersion < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.id.xferPort < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.lastDiskErrorCheck > blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.shortCircuitRegistry.SHM_LENGTH < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.storage.layoutVersion < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.storage.namespaceID < blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.storage.namespaceID > blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.storage.namespaceID < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout > blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod > blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.xserver.balanceThrottler.maxThreads < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.xserver.balanceThrottler.periodExtension < blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.xserver.estimateBlockSize > blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.xserver.maxXceiverCount < blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.DEFAULT_PORT < blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS < blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL > blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses < blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval > blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.dir.maxComponentLength < blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.dir.maxDirItems > blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.dir.xattrMaxSize < blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.editLogRollerThreshold > blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.leaseManager.hardLimit > blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.leaseRecheckIntervalMs < blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs < blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.nnResourceChecker.duReserved > blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH < blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit < blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.startTime > blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER < blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID > blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.blockReportLeaseManager.maxPending < blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.blocksMap.capacity > blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.bmSafeMode.lastStatusReport < blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.bmSafeMode.lastStatusReport > blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.bmSafeMode.lastStatusReport < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.datanodeManager.defaultInfoPort < blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.datanodeManager.defaultInfoSecurePort < blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.datanodeManager.defaultIpcPort < blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.datanodeManager.defaultXferPort < blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.datanodeManager.heartbeatExpireInterval > blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.heartbeatManager.stats.blockPoolUsed < blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.heartbeatManager.stats.capacityRemaining > blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.heartbeatManager.stats.capacityTotal > blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.heartbeatManager.stats.capacityUsed < blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.heartbeatManager.stats.capacityUsed < blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.heartbeatManager.stats.capacityUsed > blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.heartbeatManager.stats.capacityUsed > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.heartbeatManager.stats.capacityUsed > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.heartbeatManager.stats.capacityUsed > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.heartbeatManager.stats.capacityUsed > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.heartbeatManager.stats.capacityUsed > blockManagerInstance.replQueueResetToHeadThreshold
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118505386241581L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118507386343319L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185417842688L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185435037696L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 254873 || blockManagerInstance.heartbeatManager.stats.capacityUsed == 263215
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69021187025L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 69038382183L
blockManagerInstance.heartbeatManager.stats.capacityUsed > blockManagerInstance.storagePolicySuite.defaultPolicyID
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118507386343319L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118509383594166L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118509393319764L
blockManagerInstance.lastRedundancyCycleTS == 118506382 || blockManagerInstance.lastRedundancyCycleTS == 118509382
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == blockManagerInstance.bmSafeMode.blockTotal
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.bmSafeMode.blockTotal-1)
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 38
NameNode.instance.namesystem.fsImage.lastAppliedTxId == 18
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118470070418111L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118472070578981L
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118464070
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118463800
NameNode.instance.namesystem.startTime == 1731382358892L
blockManagerInstance.blockReportLeaseManager.nextId == 3714771817864751601L
blockManagerInstance.bmSafeMode.startTime == 118464040
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 98328 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 98376
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185575800832L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185591824384L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 200812 || blockManagerInstance.heartbeatManager.stats.capacityUsed == 213361
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68864454548L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68880465551L
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 2 || blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 4
blockManagerInstance.invalidateBlocks.startupTime == 118463803
blockManagerInstance.lastRedundancyCycleTS == 118470044
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION != blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME >= blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.fsImage.lastAppliedTxId > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.bmSafeMode.startTime > blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.heartbeatManager.stats.capacityUsed > blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION == blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.data.volsConfigured == DataNode.instance.volumeChecker.numSkippedChecks
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.volumeChecker.numSkippedChecks-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.volsConfigured) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.heartbeatManager.stats.nodesInService-1)
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 17
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 82
DataNode.instance.id.infoPort == 38543
DataNode.instance.id.ipcPort == 41643
DataNode.instance.id.nsInfo.cTime == 1731382190114L
DataNode.instance.id.nsInfo.namespaceID == 1446831877
DataNode.instance.id.xferPort == 38737
DataNode.instance.lastDiskErrorCheck == 118301622
DataNode.instance.volumeChecker.lastAllVolumesCheck == 118301397
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118300532
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 56
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118344384964028L
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118308416
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118308150
NameNode.instance.namesystem.startTime == 1731382203242L
blockManagerInstance.blockReportLeaseManager.nextId == -2736777389865002805L
blockManagerInstance.bmSafeMode.startTime == 118308385
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 147456
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278742409216L
blockManagerInstance.heartbeatManager.stats.capacityTotal == 402300542976L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 488283
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102941822117L
blockManagerInstance.invalidateBlocks.startupTime == 118308151
blockManagerInstance.lastRedundancyCycleTS == 118342093
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 61
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 62
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118334772313590L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278823288832L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 506985
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102860923799L
blockManagerInstance.lastRedundancyCycleTS == 118333092
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 31
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118330563732685L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278857490432L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 494487
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102826734697L
blockManagerInstance.lastRedundancyCycleTS == 118330092
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 9
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118318562890519L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118320384797169L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118320568405074L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278947700736L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278962266112L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278972096512L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 486297 || blockManagerInstance.heartbeatManager.stats.capacityUsed == 495648 || blockManagerInstance.heartbeatManager.stats.capacityUsed == 513250
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102712136807L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102721953760L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102736501534L
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 4 || blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 5 || blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 6
blockManagerInstance.lastRedundancyCycleTS == 118317568 || blockManagerInstance.lastRedundancyCycleTS == 118320568
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME <= blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.dnConf.socketWriteTimeout < blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval < blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.editLogRollerThreshold != blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.blockReportLeaseManager.maxPending >= blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount > blockManagerInstance.replQueueCallsSinceReset
8911 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 401102911 * blockManagerInstance.heartbeatManager.stats.capacityUsed - 7.060213439422E12 * blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount - 1.05411341792134656E18 == 0
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118324563276476L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278916636672L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 511172
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102767571772L
blockManagerInstance.lastRedundancyCycleTS == 118324092
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118342093548451L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118342772893190L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278750928896L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 485166
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102933305554L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118342772893190L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118316562736026L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118317384830264L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278992838656L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 479085
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102691401875L
blockManagerInstance.lastRedundancyCycleTS == 118314567
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == blockManagerInstance.neededReconstruction.LEVEL
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118320568405074L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278947700736L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 513250
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102736501534L
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 5
blockManagerInstance.lastRedundancyCycleTS == 118320568
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold == blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118345093757632L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118346773179849L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278726320128L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 505946
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102957893542L
blockManagerInstance.lastRedundancyCycleTS == 118345093
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118346773179849L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118347384848664L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278718447616L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 490331
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102965781669L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118318562890519L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278972096512L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 486297
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102712136807L
blockManagerInstance.lastRedundancyCycleTS == 118317568
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278908084224L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 520523
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102776114869L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118324563276476L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118326384861883L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118326563420793L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118324092250166L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118336093091672L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118336772460359L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278799663104L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 486265
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102884570247L
blockManagerInstance.lastRedundancyCycleTS == 118336093
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118336772460359L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118339093331077L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278779453440L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 487274
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102904774806L
blockManagerInstance.lastRedundancyCycleTS == 118339093
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118330092711655L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118330563732685L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118341384861836L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118342093548451L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278750928896L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278771130368L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 485166 || blockManagerInstance.heartbeatManager.stats.capacityUsed == 494547
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102913094701L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102933305554L
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 3 || blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 4
blockManagerInstance.lastRedundancyCycleTS == 118339093 || blockManagerInstance.lastRedundancyCycleTS == 118342093
blockManagerInstance.replQueueCallsSinceReset == 10 || blockManagerInstance.replQueueCallsSinceReset == 11
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION <= blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.diskBalancer.bandwidth <= blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118328563579088L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118329384850122L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278878724096L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 503838
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102805491682L
blockManagerInstance.lastRedundancyCycleTS == 118327092
DataNode.instance.id.nsInfo.cTime == 1731382193818L
DataNode.instance.id.nsInfo.namespaceID == 1567528467
DataNode.instance.storage.namespaceID == 1446831877
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118304082866808L
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118300083
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118298922
NameNode.instance.namesystem.startTime == 1731382194014L
blockManagerInstance.blockReportLeaseManager.nextId == -5163559665702215840L
blockManagerInstance.bmSafeMode.startTime == 118300055
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279062749184L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 451842
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102621518590L
blockManagerInstance.invalidateBlocks.startupTime == 118298925
blockManagerInstance.lastRedundancyCycleTS == 118303094
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118303093429212L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279081590784L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 393216
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102602735616L
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION == DataNode.instance.data.cacheManager.numBlocksFailedToUncache
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118314567852740L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279001571328L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 473890
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102682674398L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118326563420793L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118327092548630L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278888062976L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278908084224L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 520523 || blockManagerInstance.heartbeatManager.stats.capacityUsed == 536108
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102776114869L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102796120532L
blockManagerInstance.lastRedundancyCycleTS == 118324092 || blockManagerInstance.lastRedundancyCycleTS == 118327092
NameNode.instance.namesystem.editLogRollerThreshold < blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118346773179849L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278718447616L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278726320128L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 490331 || blockManagerInstance.heartbeatManager.stats.capacityUsed == 505946
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102957893542L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102965781669L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278779453440L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278791036928L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 487274 || blockManagerInstance.heartbeatManager.stats.capacityUsed == 489382
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102893189210L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102904774806L
blockManagerInstance.lastRedundancyCycleTS == 118336093 || blockManagerInstance.lastRedundancyCycleTS == 118339093
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279001571328L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279018332160L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 468515 || blockManagerInstance.heartbeatManager.stats.capacityUsed == 473890
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102665918941L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102682674398L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118330563732685L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118332772211003L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118333092891352L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278833291264L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278847692800L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278857490432L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 494487 || blockManagerInstance.heartbeatManager.stats.capacityUsed == 500721 || blockManagerInstance.heartbeatManager.stats.capacityUsed == 518384
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102826734697L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102836526095L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102850909968L
blockManagerInstance.lastRedundancyCycleTS == 118330092 || blockManagerInstance.lastRedundancyCycleTS == 118333092
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118336093091672L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118345093757632L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118341384861836L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278771130368L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 494547
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102913094701L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118324092250166L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118324563276476L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118320568405074L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118322563141553L
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 8 || DataNode.instance.data.asyncDiskService.numDeletedBlocks == 30
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 9 || DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 31
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118322563141553L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278938394624L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 278947700736L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 513250 || blockManagerInstance.heartbeatManager.stats.capacityUsed == 524679
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102736501534L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102745800313L
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 3 || blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 5
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME != blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.data.asyncDiskService.numDeletedBlocks < DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.asyncDiskService.numDeletedBlocks <= blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
DataNode.instance.data.cacheManager.numBlocksFailedToUncache != DataNode.instance.diskBalancer.bandwidth
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.cacheManager.numBlocksFailedToUncache != NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
DataNode.instance.data.cacheManager.numBlocksFailedToUncache != blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
DataNode.instance.data.cacheManager.numBlocksFailedToUncache > blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.cacheManager.numBlocksFailedToUncache != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount <= blockManagerInstance.neededReconstruction.LEVEL
DataNode.instance.id.infoPort == 39049
DataNode.instance.id.ipcPort == 38895
DataNode.instance.id.nsInfo.cTime == 1731382127132L
DataNode.instance.id.nsInfo.namespaceID == 1205464783
DataNode.instance.id.xferPort == 35305
DataNode.instance.lastDiskErrorCheck == 118235692
DataNode.instance.volumeChecker.lastAllVolumesCheck == 118235631
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118234613
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118238131701704L
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118234131
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118233014
NameNode.instance.namesystem.startTime == 1731382128106L
blockManagerInstance.blockReportLeaseManager.nextId == 3174158107023557856L
blockManagerInstance.bmSafeMode.startTime == 118234099
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279558144000L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279564222464L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279570432000L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 248877 || blockManagerInstance.heartbeatManager.stats.capacityUsed == 352376 || blockManagerInstance.heartbeatManager.stats.capacityUsed == 454836
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102114038739L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102120144776L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102126120780L
blockManagerInstance.invalidateBlocks.startupTime == 118233016
blockManagerInstance.lastRedundancyCycleTS == 118237500
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval != blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118235728888883L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118236131559000L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279576813568L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 245760
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102107660288L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118236131559000L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118237499701551L
blockManagerInstance.lastRedundancyCycleTS == -1 || blockManagerInstance.lastRedundancyCycleTS == 118237500
blockManagerInstance.heartbeatManager.stats.capacityUsed != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118236131559000L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118238131701704L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118240098482910L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118240131829827L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279558144000L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 454836
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102126120780L
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 45
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118250132357453L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118252098475178L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118252132500160L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279428096000L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 517176
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102256106440L
blockManagerInstance.lastRedundancyCycleTS == 118249501
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118255501933054L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118256132753101L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279406993408L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 519254
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102277206954L
blockManagerInstance.lastRedundancyCycleTS == 118255501
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118246132142019L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279495172096L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 514059
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102189033461L
blockManagerInstance.lastRedundancyCycleTS == 118243501
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118261502235321L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279333814272L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 497495
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102350407849L
blockManagerInstance.lastRedundancyCycleTS == 118261502
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118237499701551L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118238131701704L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118256132753101L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279371628544L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 534929
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102312556143L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118258502076073L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118260132986416L
blockManagerInstance.lastRedundancyCycleTS == 118258502
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 24 || DataNode.instance.data.asyncDiskService.numDeletedBlocks == 45
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118250132357453L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279428096000L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279440744448L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279453442048L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 517176 || blockManagerInstance.heartbeatManager.stats.capacityUsed == 524449 || blockManagerInstance.heartbeatManager.stats.capacityUsed == 536917
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102230753119L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102243438251L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102256106440L
DataNode.instance.data.asyncDiskService.numDeletedBlocks >= NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118264502431332L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279299497984L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 514119
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102384707513L
blockManagerInstance.lastRedundancyCycleTS == 118264502
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118246132142019L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118246501362927L
blockManagerInstance.lastRedundancyCycleTS == 118243501 || blockManagerInstance.lastRedundancyCycleTS == 118246501
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 9
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118243098468603L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279528374272L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 471460
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102155873884L
blockManagerInstance.lastRedundancyCycleTS == 118240501
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118244132058005L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118260132986416L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279464132608L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 520293
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102220066715L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118246501362927L
blockManagerInstance.lastRedundancyCycleTS == 118246501
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118240131829827L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118258502076073L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279333814272L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279346233344L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 279358652416L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 497495 || blockManagerInstance.heartbeatManager.stats.capacityUsed == 500642 || blockManagerInstance.heartbeatManager.stats.capacityUsed == 511032
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102325566558L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102337975240L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 102350407849L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118249501594268L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118250132357453L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118240501051926L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118248132247701L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118249098483106L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118243501206200L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118243501206200L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118244132058005L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118261098484622L
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 65
DataNode.instance.id.infoPort == 45471
DataNode.instance.id.ipcPort == 42759
DataNode.instance.id.nsInfo.cTime == 1731382299948L
DataNode.instance.id.nsInfo.namespaceID == 222810943
DataNode.instance.id.xferPort == 45511
DataNode.instance.lastDiskErrorCheck == 118408667
DataNode.instance.volumeChecker.lastAllVolumesCheck == 118408661
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118407972
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118422346405892L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118422395951384L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118422416850685L
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118407657
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118406321
NameNode.instance.namesystem.startTime == 1731382301413L
blockManagerInstance.blockReportLeaseManager.nextId == 4971152228154292776L
blockManagerInstance.bmSafeMode.startTime == 118406981
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 1404905
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185731350528L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68723724311L
blockManagerInstance.invalidateBlocks.startupTime == 118406324
blockManagerInstance.lastRedundancyCycleTS == 118422177
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.storagePolicySuite.defaultPolicyID
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 7
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 55
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 1372769
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185749585920L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68705521055L
blockManagerInstance.lastRedundancyCycleTS == 118415982
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118420892981259L
blockManagerInstance.lastRedundancyCycleTS == 118419177
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118419742910428L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118419781061098L
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 48
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 1333385
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185770704896L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68684441463L
blockManagerInstance.lastRedundancyCycleTS == 118412981
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 452274
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185802752000L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68653275470L
blockManagerInstance.lastRedundancyCycleTS == 118415982 || blockManagerInstance.lastRedundancyCycleTS == 118419177
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118408745052210L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118408825374177L
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185804750848L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68651630592L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118420920448473L
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118414576195490L
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 7 || DataNode.instance.data.asyncDiskService.numDeletedBlocks == 17
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 55 || DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 65
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 1372769 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 1404905
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185731350528L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185749585920L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68705521055L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68723724311L
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS != DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.asyncDiskService.numDeletedBlocks >= blockManagerInstance.storagePolicySuite.defaultPolicyID
DataNode.instance.data.cacheManager.revocationMs < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.blockReportSplitThreshold < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.socketWriteTimeout < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.dir.maxDirItems < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.editLogRollerThreshold < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.leaseManager.hardLimit < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.datanodeManager.heartbeatExpireInterval < blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.id.infoPort == 38887
DataNode.instance.id.ipcPort == 36181
DataNode.instance.id.nsInfo.cTime == 1731382162757L
DataNode.instance.id.nsInfo.namespaceID == 479260240
DataNode.instance.id.xferPort == 40003
DataNode.instance.lastDiskErrorCheck == 118271468
DataNode.instance.volumeChecker.lastAllVolumesCheck == 118271461
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118270702
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118270345
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118268954
NameNode.instance.namesystem.startTime == 1731382164046L
blockManagerInstance.blockReportLeaseManager.nextId == -5232127714966073996L
blockManagerInstance.bmSafeMode.startTime == 118269662
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 186215153664L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68241227776L
blockManagerInstance.invalidateBlocks.startupTime == 118268957
blockManagerInstance.lastRedundancyCycleTS == 118272662
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.diskBalancer.bandwidth
DataNode.instance.data.asyncDiskService.numDeletedBlocks == NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE
DataNode.instance.data.asyncDiskService.numDeletedBlocks == NameNode.instance.namesystem.fsImage.SHUTDOWN_HOOK_PRIORITY
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE
DataNode.instance.data.asyncDiskService.numDeletedBlocks == blockManagerInstance.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 10
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 181214
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 186177208320L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68279090210L
blockManagerInstance.lastRedundancyCycleTS == 118278662
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 278516
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 186089783296L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68366417932L
blockManagerInstance.lastRedundancyCycleTS == 118287663
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 127298
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 186200719360L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68255633086L
blockManagerInstance.lastRedundancyCycleTS == 118275662
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 98304 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 127298
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 186200719360L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 186215153664L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68241227776L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68255633086L
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 201854 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 278516
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 186068484096L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 186089783296L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68366417932L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68387793794L
blockManagerInstance.lastRedundancyCycleTS == 118290664
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 201854
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 186068484096L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68387793794L
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 206066
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 186155794432L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68300479246L
blockManagerInstance.lastRedundancyCycleTS == 118278662 || blockManagerInstance.lastRedundancyCycleTS == 118281663
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 257806
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185979469824L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68342534386L
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 10 || DataNode.instance.data.asyncDiskService.numDeletedBlocks == 17 || DataNode.instance.data.asyncDiskService.numDeletedBlocks == 30
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 10 || DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 16 || DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 30
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 181214 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 206066
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 186155794432L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 186177208320L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68279090210L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68300479246L
DataNode.instance.data.asyncDiskService.numDeletedBlocks >= DataNode.instance.diskBalancer.bandwidth
DataNode.instance.data.cacheManager.numBlocksFailedToUncache >= DataNode.instance.diskBalancer.bandwidth
DataNode.instance.data.cacheManager.numBlocksFailedToUncache != NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.cacheManager.numBlocksFailedToUncache <= blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
blockManagerInstance.lastRedundancyCycleTS == 118275662 || blockManagerInstance.lastRedundancyCycleTS == 118278662
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == blockManagerInstance.defaultReplication
DataNode.instance.id.infoPort == 36667
DataNode.instance.id.ipcPort == 45091
DataNode.instance.id.nsInfo.cTime == 1731382261563L
DataNode.instance.id.nsInfo.namespaceID == 329010625
DataNode.instance.id.xferPort == 45719
DataNode.instance.lastDiskErrorCheck == 118370276
DataNode.instance.volumeChecker.lastAllVolumesCheck == 118370268
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118369502
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118371127570972L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118371163690353L
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118368505
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118367815
NameNode.instance.namesystem.startTime == 1731382262907L
blockManagerInstance.blockReportLeaseManager.nextId == 1046953084607022056L
blockManagerInstance.bmSafeMode.startTime == 118368467
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 371638960128L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 137273802752L
blockManagerInstance.invalidateBlocks.startupTime == 118367817
DataNode.instance.id.infoPort == 43141
DataNode.instance.id.ipcPort == 41197
DataNode.instance.id.nsInfo.cTime == 1731382319811L
DataNode.instance.id.nsInfo.namespaceID == 1696677352
DataNode.instance.id.xferPort == 35323
DataNode.instance.lastDiskErrorCheck == 118428666
DataNode.instance.volumeChecker.lastAllVolumesCheck == 118428659
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118427943
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118427609
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118426183
NameNode.instance.namesystem.startTime == 1731382321275L
blockManagerInstance.blockReportLeaseManager.nextId == 218200049256990486L
blockManagerInstance.bmSafeMode.startTime == 118426825
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185719406592L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68736974848L
blockManagerInstance.invalidateBlocks.startupTime == 118426185
blockManagerInstance.lastRedundancyCycleTS == 118429828
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 123156 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 183285
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185687441408L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185708806144L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68747550444L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68768855051L
blockManagerInstance.lastRedundancyCycleTS == 118432828
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 183285
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185687441408L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68768855051L
blockManagerInstance.lastRedundancyCycleTS == 118435828
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 1 || DataNode.instance.data.asyncDiskService.numDeletedBlocks == 52
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 52 || DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 65
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 205996 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 212209
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185616859136L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185638600704L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68817673044L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68839408399L
blockManagerInstance.lastRedundancyCycleTS == 118444829
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME <= DataNode.instance.data.asyncDiskService.numDeletedBlocks
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME != DataNode.instance.data.asyncDiskService.numDeletedBlocks
DataNode.instance.data.asyncDiskService.numDeletedBlocks != blockManagerInstance.blockReportLeaseManager.maxPending
DataNode.instance.data.asyncDiskService.numDeletedBlocks != blockManagerInstance.neededReconstruction.LEVEL
DataNode.instance.data.asyncDiskService.numDeletedBlocks != blockManagerInstance.storagePolicySuite.defaultPolicyID
DataNode.instance.data.asyncDiskService.numDeletedBlocks >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 52
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 205996
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185638600704L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68817673044L
blockManagerInstance.lastRedundancyCycleTS == 118441829
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 29 || DataNode.instance.data.asyncDiskService.numDeletedBlocks == 52
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 205996 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 210173
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185638600704L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185654984704L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68801284867L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68817673044L
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME == DataNode.instance.data.asyncDiskService.numDeletedBlocks
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks-1) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached)
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 212209
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185616859136L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68839408399L
blockManagerInstance.lastRedundancyCycleTS == 118447830
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 123156
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185708806144L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68747550444L
blockManagerInstance.lastRedundancyCycleTS == 118432828 || blockManagerInstance.lastRedundancyCycleTS == 118435828
DataNode.instance.data.asyncDiskService.numDeletedBlocks == 29
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185537626112L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68784429838L
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 210173
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 185654984704L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 68801284867L
blockManagerInstance.lastRedundancyCycleTS == 118438829
blockManagerInstance.lastRedundancyCycleTS == 118441829 || blockManagerInstance.lastRedundancyCycleTS == 118444829
blockManagerInstance.lastRedundancyCycleTS == 118438829 || blockManagerInstance.lastRedundancyCycleTS == 118441829
DataNode.instance.id.infoPort == 35493
DataNode.instance.id.ipcPort == 43145
DataNode.instance.id.nsInfo.cTime == 1731382458870L
DataNode.instance.id.nsInfo.namespaceID == 1468547079
DataNode.instance.id.xferPort == 41619
DataNode.instance.lastDiskErrorCheck == 118570216
DataNode.instance.storage.namespaceID == 1552351488
DataNode.instance.volumeChecker.lastAllVolumesCheck == 118570182
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118569215
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118570825038028L
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118568825
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118567606
NameNode.instance.namesystem.startTime == 1731382462698L
blockManagerInstance.blockReportLeaseManager.nextId == 1271799686729321727L
blockManagerInstance.bmSafeMode.startTime == 118568790
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 277815894016L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 103868579840L
blockManagerInstance.invalidateBlocks.startupTime == 118567610
DataNode.instance.id.nsInfo.cTime == 1731382461713L
DataNode.instance.id.nsInfo.namespaceID == 924127513
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118576284270678L
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118573955
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118573674
NameNode.instance.namesystem.startTime == 1731382468766L
blockManagerInstance.blockReportLeaseManager.nextId == 6491487498767150841L
blockManagerInstance.bmSafeMode.startTime == 118573914
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 277801869312L
blockManagerInstance.heartbeatManager.stats.capacityUsed == 442368
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 103882407936L
blockManagerInstance.invalidateBlocks.startupTime == 118573675
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118571790313752L
blockManagerInstance.lastRedundancyCycleTS == 118571792
NameNode.instance.namesystem.fsRunning == NameNode.instance.namesystem.leaseManager.shouldRunMonitor
DataNode.instance.id.nsInfo.cTime == 1731382458870L || DataNode.instance.id.nsInfo.cTime == 1731382461713L
DataNode.instance.id.nsInfo.namespaceID == 924127513 || DataNode.instance.id.nsInfo.namespaceID == 1468547079
NameNode.instance.namesystem.fsImage.lastAppliedTxId == 0 || NameNode.instance.namesystem.fsImage.lastAppliedTxId == 4 || NameNode.instance.namesystem.fsImage.lastAppliedTxId == 50
blockManagerInstance.bmSafeMode.startTime == 0 || blockManagerInstance.bmSafeMode.startTime == 118568790 || blockManagerInstance.bmSafeMode.startTime == 118573914
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 0 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 98304 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 147456
blockManagerInstance.heartbeatManager.stats.capacityTotal == 0 || blockManagerInstance.heartbeatManager.stats.capacityTotal == 268200361984L || blockManagerInstance.heartbeatManager.stats.capacityTotal == 402300542976L
blockManagerInstance.heartbeatManager.stats.capacityUsed >= 0
blockManagerInstance.heartbeatManager.stats.nodesInService == 0 || blockManagerInstance.heartbeatManager.stats.nodesInService == 2 || blockManagerInstance.heartbeatManager.stats.nodesInService == 3
blockManagerInstance.lastRedundancyCycleTS == -1 || blockManagerInstance.lastRedundancyCycleTS == 118571792
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.NUM_CORES < DataNode.instance.id.nsInfo.cTime
DataNode.instance.NUM_CORES < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.NUM_CORES < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.NUM_CORES != NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.NUM_CORES < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.NUM_CORES < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.NUM_CORES < NameNode.instance.namesystem.startTime
DataNode.instance.NUM_CORES != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.NUM_CORES != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.NUM_CORES != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.NUM_CORES != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.NUM_CORES != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.NUM_CORES != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.NUM_CORES != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.NUM_CORES < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs < DataNode.instance.id.nsInfo.cTime
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs < NameNode.instance.namesystem.startTime
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION != NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < DataNode.instance.id.nsInfo.cTime
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME != NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < NameNode.instance.namesystem.startTime
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME != blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < DataNode.instance.id.nsInfo.cTime
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < NameNode.instance.namesystem.startTime
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS < DataNode.instance.id.nsInfo.cTime
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS < NameNode.instance.namesystem.startTime
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS < DataNode.instance.id.nsInfo.cTime
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS < NameNode.instance.namesystem.startTime
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.data.asyncDiskService.numDeletedBlocks <= NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.data.asyncDiskService.numDeletedBlocks != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.asyncDiskService.numDeletedBlocks <= blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.asyncDiskService.numDeletedBlocks <= blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.asyncDiskService.numDeletedBlocks <= blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.asyncDiskService.numDeletedBlocks <= blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.asyncDiskService.numDeletedBlocks <= blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.data.asyncDiskService.numDeletedBlocks <= blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.asyncDiskService.numDeletedBlocks <= blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.cacheManager.revocationMs > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.data.cacheManager.revocationMs < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.data.cacheManager.revocationMs != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.cacheManager.revocationMs < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.data.cacheManager.revocationPollingMs > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.data.cacheManager.revocationPollingMs < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.data.cacheManager.revocationPollingMs != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.cacheManager.revocationPollingMs != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.data.cacheManager.revocationPollingMs < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.data.maxDataLength > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.data.maxDataLength < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.data.maxDataLength != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.maxDataLength < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.data.smallBufferSize > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.data.smallBufferSize < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.data.smallBufferSize != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.smallBufferSize != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.data.smallBufferSize < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.data.volsConfigured != NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.data.volsConfigured != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.data.volsConfigured != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.directoryScanner.MILLIS_PER_SECOND < DataNode.instance.id.nsInfo.cTime
DataNode.instance.directoryScanner.MILLIS_PER_SECOND < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.directoryScanner.MILLIS_PER_SECOND > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.directoryScanner.MILLIS_PER_SECOND > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.directoryScanner.MILLIS_PER_SECOND < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.directoryScanner.MILLIS_PER_SECOND < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.directoryScanner.MILLIS_PER_SECOND < NameNode.instance.namesystem.startTime
DataNode.instance.directoryScanner.MILLIS_PER_SECOND != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.directoryScanner.MILLIS_PER_SECOND != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.directoryScanner.MILLIS_PER_SECOND != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.directoryScanner.MILLIS_PER_SECOND != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.directoryScanner.MILLIS_PER_SECOND != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.directoryScanner.MILLIS_PER_SECOND != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.directoryScanner.MILLIS_PER_SECOND != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.directoryScanner.MILLIS_PER_SECOND < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.directoryScanner.scanPeriodMsecs < DataNode.instance.id.nsInfo.cTime
DataNode.instance.directoryScanner.scanPeriodMsecs < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.directoryScanner.scanPeriodMsecs > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.directoryScanner.scanPeriodMsecs > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.directoryScanner.scanPeriodMsecs < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.directoryScanner.scanPeriodMsecs < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.directoryScanner.scanPeriodMsecs < NameNode.instance.namesystem.startTime
DataNode.instance.directoryScanner.scanPeriodMsecs != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.directoryScanner.scanPeriodMsecs != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.directoryScanner.scanPeriodMsecs != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.directoryScanner.scanPeriodMsecs != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.directoryScanner.scanPeriodMsecs != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.directoryScanner.scanPeriodMsecs < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.diskBalancer.bandwidth < DataNode.instance.id.nsInfo.cTime
DataNode.instance.diskBalancer.bandwidth < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.diskBalancer.bandwidth < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.diskBalancer.bandwidth != NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.diskBalancer.bandwidth < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.diskBalancer.bandwidth < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.diskBalancer.bandwidth < NameNode.instance.namesystem.startTime
DataNode.instance.diskBalancer.bandwidth != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.diskBalancer.bandwidth != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.diskBalancer.bandwidth != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.diskBalancer.bandwidth != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.diskBalancer.bandwidth != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.diskBalancer.bandwidth != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.diskBalancer.bandwidth != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.diskBalancer.bandwidth < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.diskBalancer.planValidityInterval < DataNode.instance.id.nsInfo.cTime
DataNode.instance.diskBalancer.planValidityInterval < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.diskBalancer.planValidityInterval > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.diskBalancer.planValidityInterval > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.diskBalancer.planValidityInterval < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.diskBalancer.planValidityInterval < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.diskBalancer.planValidityInterval < NameNode.instance.namesystem.startTime
DataNode.instance.diskBalancer.planValidityInterval != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.diskBalancer.planValidityInterval != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.diskBalancer.planValidityInterval != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.diskBalancer.planValidityInterval != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.diskBalancer.planValidityInterval != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.diskBalancer.planValidityInterval < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.dnConf.blockReportSplitThreshold > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.dnConf.blockReportSplitThreshold < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.dnConf.blockReportSplitThreshold != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.blockReportSplitThreshold < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.dnConf.bpReadyTimeout != NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.dnConf.bpReadyTimeout < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.dnConf.bpReadyTimeout != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.bpReadyTimeout != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.dnConf.bpReadyTimeout < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.dnConf.cacheReportInterval > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.dnConf.cacheReportInterval < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.dnConf.cacheReportInterval != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.cacheReportInterval != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.dnConf.cacheReportInterval < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.dnConf.heartBeatInterval > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.dnConf.heartBeatInterval < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.dnConf.heartBeatInterval != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.heartBeatInterval != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.dnConf.heartBeatInterval < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.dnConf.lifelineIntervalMs > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.dnConf.lifelineIntervalMs < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.dnConf.lifelineIntervalMs != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.lifelineIntervalMs != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.dnConf.lifelineIntervalMs < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.dnConf.outliersReportIntervalMs > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.dnConf.outliersReportIntervalMs < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.dnConf.outliersReportIntervalMs != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.outliersReportIntervalMs < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.dnConf.readaheadLength > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.dnConf.readaheadLength < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.dnConf.readaheadLength != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.readaheadLength < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.dnConf.restartReplicaExpiry > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.dnConf.restartReplicaExpiry < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.dnConf.restartReplicaExpiry != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.restartReplicaExpiry != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.dnConf.restartReplicaExpiry < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.dnConf.socketKeepaliveTimeout > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.dnConf.socketKeepaliveTimeout < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.dnConf.socketKeepaliveTimeout != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.socketKeepaliveTimeout != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.dnConf.socketKeepaliveTimeout < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.dnConf.socketTimeout > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.dnConf.socketTimeout < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.dnConf.socketTimeout != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.socketTimeout != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.dnConf.socketTimeout < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.dnConf.socketWriteTimeout > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.dnConf.socketWriteTimeout < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.dnConf.socketWriteTimeout != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.dnConf.socketWriteTimeout < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.id.infoPort < DataNode.instance.id.nsInfo.cTime
DataNode.instance.id.infoPort < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.id.infoPort > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.id.infoPort > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.id.infoPort < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.id.infoPort < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.id.infoPort < NameNode.instance.namesystem.startTime
DataNode.instance.id.infoPort != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.id.infoPort != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.id.infoPort != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.id.infoPort != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.id.infoPort != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.id.infoPort != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.id.infoPort != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.id.infoPort < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.id.ipcPort < DataNode.instance.id.nsInfo.cTime
DataNode.instance.id.ipcPort < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.id.ipcPort > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.id.ipcPort > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.id.ipcPort < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.id.ipcPort < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.id.ipcPort < NameNode.instance.namesystem.startTime
DataNode.instance.id.ipcPort != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.id.ipcPort != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.id.ipcPort != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.id.ipcPort != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.id.ipcPort != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.id.ipcPort != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.id.ipcPort != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.id.ipcPort < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.id.nsInfo.cTime > DataNode.instance.id.xferPort
DataNode.instance.id.nsInfo.cTime > DataNode.instance.lastDiskErrorCheck
DataNode.instance.id.nsInfo.cTime > DataNode.instance.shortCircuitRegistry.SHM_LENGTH
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.id.nsInfo.cTime != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
DataNode.instance.id.nsInfo.layoutVersion < NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.id.nsInfo.layoutVersion < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.id.nsInfo.layoutVersion != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.id.nsInfo.layoutVersion < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.id.nsInfo.namespaceID > DataNode.instance.id.xferPort
DataNode.instance.id.nsInfo.namespaceID > DataNode.instance.lastDiskErrorCheck
DataNode.instance.id.nsInfo.namespaceID > DataNode.instance.shortCircuitRegistry.SHM_LENGTH
DataNode.instance.id.nsInfo.namespaceID < DataNode.instance.storage.namespaceID
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.id.nsInfo.namespaceID != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
DataNode.instance.id.xferPort > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.id.xferPort > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.id.xferPort < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.id.xferPort < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.id.xferPort < NameNode.instance.namesystem.startTime
DataNode.instance.id.xferPort != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.id.xferPort != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.id.xferPort != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.id.xferPort != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.id.xferPort != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.id.xferPort != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.id.xferPort != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.id.xferPort < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.lastDiskErrorCheck > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.lastDiskErrorCheck > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.lastDiskErrorCheck != NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.lastDiskErrorCheck != NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.lastDiskErrorCheck < NameNode.instance.namesystem.startTime
DataNode.instance.lastDiskErrorCheck != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.lastDiskErrorCheck != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.lastDiskErrorCheck != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.lastDiskErrorCheck != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.lastDiskErrorCheck != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.lastDiskErrorCheck != blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.shortCircuitRegistry.SHM_LENGTH > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.shortCircuitRegistry.SHM_LENGTH > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.shortCircuitRegistry.SHM_LENGTH < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.shortCircuitRegistry.SHM_LENGTH < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.shortCircuitRegistry.SHM_LENGTH < NameNode.instance.namesystem.startTime
DataNode.instance.shortCircuitRegistry.SHM_LENGTH != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.shortCircuitRegistry.SHM_LENGTH != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.shortCircuitRegistry.SHM_LENGTH != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.shortCircuitRegistry.SHM_LENGTH != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.shortCircuitRegistry.SHM_LENGTH != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.shortCircuitRegistry.SHM_LENGTH != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.shortCircuitRegistry.SHM_LENGTH != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.shortCircuitRegistry.SHM_LENGTH < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.storage.layoutVersion < NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.storage.layoutVersion != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.storage.namespaceID != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.storage.namespaceID > blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.volumeChecker.lastAllVolumesCheck > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.volumeChecker.lastAllVolumesCheck != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.xserver.balanceThrottler.curPeriodStart != NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.xserver.balanceThrottler.curPeriodStart != NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.xserver.balanceThrottler.curPeriodStart != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.balanceThrottler.curPeriodStart != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.xserver.balanceThrottler.maxThreads >= NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.xserver.balanceThrottler.maxThreads < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.xserver.balanceThrottler.maxThreads != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.balanceThrottler.maxThreads != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.xserver.balanceThrottler.maxThreads < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.xserver.balanceThrottler.periodExtension > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.xserver.balanceThrottler.periodExtension < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.xserver.balanceThrottler.periodExtension != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.balanceThrottler.periodExtension != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.xserver.balanceThrottler.periodExtension < blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.xserver.estimateBlockSize > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.xserver.estimateBlockSize > NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.xserver.estimateBlockSize != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.estimateBlockSize > blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.xserver.maxXceiverCount > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.xserver.maxXceiverCount < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.xserver.maxXceiverCount != blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.xserver.maxXceiverCount != blockManagerInstance.heartbeatManager.stats.capacityUsed
DataNode.instance.xserver.maxXceiverCount < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.DEFAULT_PORT > NameNode.instance.namesystem.fsImage.lastAppliedTxId
NameNode.instance.DEFAULT_PORT < NameNode.instance.namesystem.lazyPersistFileScrubberTS
NameNode.instance.DEFAULT_PORT != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.DEFAULT_PORT != blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.DEFAULT_PORT < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS > NameNode.instance.namesystem.fsImage.lastAppliedTxId
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS < NameNode.instance.namesystem.lazyPersistFileScrubberTS
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS != blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL > NameNode.instance.namesystem.fsImage.lastAppliedTxId
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL < NameNode.instance.namesystem.lazyPersistFileScrubberTS
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE != NameNode.instance.namesystem.fsImage.lastAppliedTxId
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < NameNode.instance.namesystem.lazyPersistFileScrubberTS
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE != blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < NameNode.instance.namesystem.fsImage.lastAppliedTxId
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < NameNode.instance.namesystem.lazyPersistFileScrubberTS
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses > NameNode.instance.namesystem.fsImage.lastAppliedTxId
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses < NameNode.instance.namesystem.lazyPersistFileScrubberTS
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses != blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval > NameNode.instance.namesystem.fsImage.lastAppliedTxId
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval < NameNode.instance.namesystem.lazyPersistFileScrubberTS
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.dir.maxComponentLength > NameNode.instance.namesystem.fsImage.lastAppliedTxId
NameNode.instance.namesystem.dir.maxComponentLength < NameNode.instance.namesystem.lazyPersistFileScrubberTS
NameNode.instance.namesystem.dir.maxComponentLength != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.dir.maxComponentLength != blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.dir.maxComponentLength < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.dir.maxDirItems > NameNode.instance.namesystem.fsImage.lastAppliedTxId
NameNode.instance.namesystem.dir.maxDirItems < NameNode.instance.namesystem.lazyPersistFileScrubberTS
NameNode.instance.namesystem.dir.maxDirItems != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.dir.maxDirItems < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.dir.xattrMaxSize > NameNode.instance.namesystem.fsImage.lastAppliedTxId
NameNode.instance.namesystem.dir.xattrMaxSize < NameNode.instance.namesystem.lazyPersistFileScrubberTS
NameNode.instance.namesystem.dir.xattrMaxSize != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.dir.xattrMaxSize != blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.dir.xattrMaxSize < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.editLogRollerThreshold > NameNode.instance.namesystem.fsImage.lastAppliedTxId
NameNode.instance.namesystem.editLogRollerThreshold < NameNode.instance.namesystem.lazyPersistFileScrubberTS
NameNode.instance.namesystem.editLogRollerThreshold != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.editLogRollerThreshold < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.fsImage.lastAppliedTxId < NameNode.instance.namesystem.lazyPersistFileScrubberTS
NameNode.instance.namesystem.fsImage.lastAppliedTxId < NameNode.instance.namesystem.leaseManager.hardLimit
NameNode.instance.namesystem.fsImage.lastAppliedTxId < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.fsImage.lastAppliedTxId < NameNode.instance.namesystem.leaseRecheckIntervalMs
NameNode.instance.namesystem.fsImage.lastAppliedTxId != NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
NameNode.instance.namesystem.fsImage.lastAppliedTxId < NameNode.instance.namesystem.nnResourceChecker.duReserved
NameNode.instance.namesystem.fsImage.lastAppliedTxId != NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
NameNode.instance.namesystem.fsImage.lastAppliedTxId < NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit
NameNode.instance.namesystem.fsImage.lastAppliedTxId < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.fsImage.lastAppliedTxId != blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
NameNode.instance.namesystem.fsImage.lastAppliedTxId != blockManagerInstance.blockReportLeaseManager.maxPending
NameNode.instance.namesystem.fsImage.lastAppliedTxId != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.blocksMap.capacity
NameNode.instance.namesystem.fsImage.lastAppliedTxId != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.datanodeManager.defaultInfoPort
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.datanodeManager.defaultInfoSecurePort
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.datanodeManager.defaultIpcPort
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.datanodeManager.defaultXferPort
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.datanodeManager.heartbeatExpireInterval
NameNode.instance.namesystem.fsImage.lastAppliedTxId != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.fsImage.lastAppliedTxId != blockManagerInstance.heartbeatManager.stats.capacityRemaining
NameNode.instance.namesystem.fsImage.lastAppliedTxId != blockManagerInstance.heartbeatManager.stats.capacityTotal
NameNode.instance.namesystem.fsImage.lastAppliedTxId != blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.fsImage.lastAppliedTxId != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
NameNode.instance.namesystem.fsImage.lastAppliedTxId != blockManagerInstance.heartbeatManager.stats.nodesInService
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.fsImage.lastAppliedTxId != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.fsImage.lastAppliedTxId % blockManagerInstance.lastRedundancyCycleTS == 0
NameNode.instance.namesystem.fsImage.lastAppliedTxId != blockManagerInstance.neededReconstruction.LEVEL
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
NameNode.instance.namesystem.fsImage.lastAppliedTxId != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
NameNode.instance.namesystem.fsImage.lastAppliedTxId != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
NameNode.instance.namesystem.fsImage.lastAppliedTxId != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
NameNode.instance.namesystem.fsImage.lastAppliedTxId != blockManagerInstance.replQueueCallsSinceReset
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.replQueueResetToHeadThreshold
NameNode.instance.namesystem.fsImage.lastAppliedTxId != blockManagerInstance.storagePolicySuite.defaultPolicyID
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.lazyPersistFileScrubberTS > NameNode.instance.namesystem.leaseManager.hardLimit
NameNode.instance.namesystem.lazyPersistFileScrubberTS > NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.lazyPersistFileScrubberTS > NameNode.instance.namesystem.leaseRecheckIntervalMs
NameNode.instance.namesystem.lazyPersistFileScrubberTS > NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
NameNode.instance.namesystem.lazyPersistFileScrubberTS > NameNode.instance.namesystem.nnResourceChecker.duReserved
NameNode.instance.namesystem.lazyPersistFileScrubberTS > NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
NameNode.instance.namesystem.lazyPersistFileScrubberTS > NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit
NameNode.instance.namesystem.lazyPersistFileScrubberTS < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
NameNode.instance.namesystem.lazyPersistFileScrubberTS < blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.blockReportLeaseManager.maxPending
NameNode.instance.namesystem.lazyPersistFileScrubberTS != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.blocksMap.capacity
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.datanodeManager.defaultInfoPort
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.datanodeManager.defaultInfoSecurePort
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.datanodeManager.defaultIpcPort
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.datanodeManager.defaultXferPort
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.datanodeManager.heartbeatExpireInterval
NameNode.instance.namesystem.lazyPersistFileScrubberTS != blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.neededReconstruction.LEVEL
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.replQueueResetToHeadThreshold
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.storagePolicySuite.defaultPolicyID
NameNode.instance.namesystem.leaseManager.hardLimit != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.leaseManager.hardLimit < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - NameNode.instance.namesystem.startTime + 2147483647 == 0
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
NameNode.instance.namesystem.leaseRecheckIntervalMs != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.leaseRecheckIntervalMs != blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.leaseRecheckIntervalMs < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs != blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.nnResourceChecker.duReserved != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.nnResourceChecker.duReserved < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH != blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit != blockManagerInstance.heartbeatManager.stats.capacityUsed
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit < blockManagerInstance.invalidateBlocks.startupTime
NameNode.instance.namesystem.startTime != blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.startTime > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER != blockManagerInstance.blockReportLeaseManager.nextId
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER != blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER < blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID != blockManagerInstance.blockReportLeaseManager.nextId
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID > blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.blockReportLeaseManager.maxPending != blockManagerInstance.blockReportLeaseManager.nextId
blockManagerInstance.blockReportLeaseManager.maxPending != blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.blockReportLeaseManager.maxPending < blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.blocksMap.capacity
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.bmSafeMode.startTime
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.datanodeManager.defaultInfoPort
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.datanodeManager.defaultInfoSecurePort
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.datanodeManager.defaultIpcPort
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.datanodeManager.defaultXferPort
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.datanodeManager.heartbeatExpireInterval
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.blockReportLeaseManager.nextId != blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.blocksMap.capacity < blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.bmSafeMode.startTime >= blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.datanodeManager.defaultInfoPort != blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.datanodeManager.defaultInfoPort < blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.datanodeManager.defaultInfoSecurePort != blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.datanodeManager.defaultInfoSecurePort < blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.datanodeManager.defaultIpcPort != blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.datanodeManager.defaultIpcPort < blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.datanodeManager.defaultXferPort != blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.datanodeManager.defaultXferPort < blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.datanodeManager.heartbeatExpireInterval < blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.heartbeatManager.stats.blockPoolUsed <= blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.heartbeatManager.stats.capacityRemaining >= blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.heartbeatManager.stats.capacityTotal >= blockManagerInstance.heartbeatManager.stats.capacityUsed
blockManagerInstance.heartbeatManager.stats.capacityUsed <= blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.heartbeatManager.stats.capacityUsed >= blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.heartbeatManager.stats.capacityUsed != blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.heartbeatManager.stats.capacityUsed != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.heartbeatManager.stats.capacityUsed != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.heartbeatManager.stats.capacityUsed != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.heartbeatManager.stats.capacityUsed != blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.heartbeatManager.stats.capacityUsed >= blockManagerInstance.replQueueCallsSinceReset
blockManagerInstance.heartbeatManager.stats.capacityUsed != blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.heartbeatManager.stats.capacityUsed != blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.invalidateBlocks.startupTime > blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.invalidateBlocks.startupTime > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.invalidateBlocks.startupTime > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.invalidateBlocks.startupTime > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.invalidateBlocks.startupTime > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.invalidateBlocks.startupTime > blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.invalidateBlocks.startupTime > blockManagerInstance.storagePolicySuite.defaultPolicyID
1.4392623175E10 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE + 1496234931 * NameNode.instance.namesystem.fsImage.lastAppliedTxId - 96 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1.1382344950439542E16 == 0
238529025 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 4 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 1527778592 * blockManagerInstance.heartbeatManager.stats.nodesInService + 4.74282680487834E14 == 0
238529025 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 4 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 4.583335776E9 * blockManagerInstance.replQueueCallsSinceReset + 4.74282680487834E14 == 0
4.7686475747E10 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 118573914 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 2109 * blockManagerInstance.bmSafeMode.startTime + 1.4057357572552664E16 == 0
5.7093339591E10 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 118573914 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 2599 * blockManagerInstance.bmSafeMode.startTime + 1.4056855570125426E16 == 0
1.19858464735E11 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 6065 * blockManagerInstance.bmSafeMode.startTime - 355716618 * blockManagerInstance.invalidateBlocks.startupTime + 4.21726337315944E16 == 0
2813952 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 2689 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 73728 * blockManagerInstance.invalidateBlocks.startupTime + 8.742042329088E12 == 0
4689920 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 2689 * blockManagerInstance.heartbeatManager.stats.capacityUsed - 122880 * blockManagerInstance.invalidateBlocks.startupTime + 1.457007054848E13 == 0
9.050980199E9 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 237143586 * blockManagerInstance.invalidateBlocks.startupTime - 10756 * blockManagerInstance.lastRedundancyCycleTS + 2.8118479639796652E16 == 0
3969414 * NameNode.instance.namesystem.fsImage.lastAppliedTxId + NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 625766225 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1.18573667612427E14 == 0
3969414 * NameNode.instance.namesystem.fsImage.lastAppliedTxId + NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1877298675 * blockManagerInstance.replQueueCallsSinceReset - 1.18573667612427E14 == 0
8158426 * NameNode.instance.namesystem.fsImage.lastAppliedTxId + 687 * NameNode.instance.namesystem.startTime - 6068 * blockManagerInstance.invalidateBlocks.startupTime - 1.188740283616046E15 == 0
4826 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 715587075 * NameNode.instance.namesystem.lazyPersistFileScrubberTS + 1.843264871248E12 * blockManagerInstance.heartbeatManager.stats.nodesInService - 4.8738667118084403E17 == 0
4826 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 715587075 * NameNode.instance.namesystem.lazyPersistFileScrubberTS + 5.529794613744E12 * blockManagerInstance.replQueueCallsSinceReset - 4.8738667118084403E17 == 0
214 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 26503225 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime + 8.1736154672E10 * blockManagerInstance.heartbeatManager.stats.nodesInService - 2.2232184396077592E16 == 0
214 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 26503225 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime + 2.45208464016E11 * blockManagerInstance.replQueueCallsSinceReset - 2.2232184396077592E16 == 0
145 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 152 * NameNode.instance.namesystem.startTime - 178486 * blockManagerInstance.replQueueCallsSinceReset + 2.63152942028957E14 == 0
937984 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 255455 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 7004160 * blockManagerInstance.invalidateBlocks.startupTime + 7.1928851888128E14 == 0
937984 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 153273 * blockManagerInstance.heartbeatManager.stats.capacityUsed - 7004160 * blockManagerInstance.invalidateBlocks.startupTime + 7.1928851888128E14 == 0
229 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 3065460 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1710 * blockManagerInstance.invalidateBlocks.startupTime + 1.75607548555E11 == 0
229 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 1710 * blockManagerInstance.invalidateBlocks.startupTime - 9196380 * blockManagerInstance.replQueueCallsSinceReset + 1.75607548555E11 == 0
12662784 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 4079213 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 111845376 * blockManagerInstance.invalidateBlocks.startupTime + 1.1760444442128384E16 == 0
21104640 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 4079213 * blockManagerInstance.heartbeatManager.stats.capacityUsed - 186408960 * blockManagerInstance.invalidateBlocks.startupTime + 1.960074073688064E16 == 0
2061 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 32633704 * blockManagerInstance.heartbeatManager.stats.nodesInService - 18204 * blockManagerInstance.invalidateBlocks.startupTime + 1.914134837586E12 == 0
687 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 6068 * blockManagerInstance.invalidateBlocks.startupTime - 32633704 * blockManagerInstance.replQueueCallsSinceReset + 6.38044945862E11 == 0
2061 * NameNode.instance.namesystem.startTime - 32633704 * blockManagerInstance.heartbeatManager.stats.nodesInService - 18204 * blockManagerInstance.invalidateBlocks.startupTime - 3.566220752947026E15 == 0
687 * NameNode.instance.namesystem.startTime - 6068 * blockManagerInstance.invalidateBlocks.startupTime - 32633704 * blockManagerInstance.replQueueCallsSinceReset - 1.188740250982342E15 == 0
18195 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 6065 * blockManagerInstance.heartbeatManager.stats.capacityUsed + 196608 * blockManagerInstance.invalidateBlocks.startupTime - 2.33125330944E13 == 0
8.1458821791E10 * blockManagerInstance.heartbeatManager.stats.nodesInService - 237143586 * blockManagerInstance.invalidateBlocks.startupTime - 12817 * blockManagerInstance.lastRedundancyCycleTS + 2.8118823577042152E16 == 0
DataNode.instance.dnConf.allowNonLocalLazyPersist == blockManagerInstance.shouldPostponeBlocksFromFuture
NameNode.instance.namesystem.blockDeletionIncrement == blockManagerInstance.blockIdManager.impendingGenerationStamp.LAST_RESERVED_STAMP
NameNode.instance.namesystem.blockDeletionIncrement == blockManagerInstance.blockIdManager.legacyGenerationStamp.LAST_RESERVED_STAMP
NameNode.instance.namesystem.blockDeletionIncrement == blockManagerInstance.datanodeManager.blockInvalidateLimit
NameNode.instance.namesystem.blockDeletionIncrement == blockManagerInstance.invalidateBlocks.blockInvalidateLimit
NameNode.instance.namesystem.blockDeletionIncrement == blockManagerInstance.maxNumBlocksToLog
NameNode.instance.namesystem.fsRunning == blockManagerInstance.datanodeManager.shouldSendCachingCommands
NameNode.instance.namesystem.fsRunning == blockManagerInstance.initializedReplQueues
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds == daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.volsConfigured) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.datanodeManager.heartbeatIntervalSeconds-1)
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.dnConf.volsConfigured) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.defaultReplication-1)
DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 0 || DataNode.instance.data.cacheManager.numBlocksFailedToUncache == 1
DataNode.instance.id.infoPort == 39005
DataNode.instance.id.ipcPort == 44847
DataNode.instance.id.nsInfo.cTime == 1731381572103L || DataNode.instance.id.nsInfo.cTime == 1731381574916L
DataNode.instance.id.nsInfo.namespaceID == 56678422 || DataNode.instance.id.nsInfo.namespaceID == 1398609070
DataNode.instance.id.xferPort == 42537
DataNode.instance.lastDiskErrorCheck == 117681588
DataNode.instance.storage.namespaceID == 56678422 || DataNode.instance.storage.namespaceID == 1398609070
DataNode.instance.volumeChecker.lastAllVolumesCheck == 116780989 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 117678295 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 117681586
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 117677763 || DataNode.instance.xserver.balanceThrottler.curPeriodStart == 117680990
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 106 || NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 110
NameNode.instance.namesystem.fsImage.lastAppliedTxId == 0 || NameNode.instance.namesystem.fsImage.lastAppliedTxId == 15
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 117677478 || NameNode.instance.namesystem.lazyPersistFileScrubberTS == 117680630
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 117677186 || NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 117680070
NameNode.instance.namesystem.startTime == 1731381572277L || NameNode.instance.namesystem.startTime == 1731381575162L
blockManagerInstance.bmSafeMode.startTime == 0 || blockManagerInstance.bmSafeMode.startTime == 117680486
blockManagerInstance.heartbeatManager.stats.blockPoolUsed >= 0
blockManagerInstance.heartbeatManager.stats.capacityTotal >= 0
blockManagerInstance.heartbeatManager.stats.nodesInService >= 0
blockManagerInstance.invalidateBlocks.startupTime == 117680071
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < DataNode.instance.id.nsInfo.cTime
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < NameNode.instance.namesystem.startTime
DataNode.instance.NUM_CORES < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.NUM_CORES > NameNode.instance.namesystem.fsImage.lastAppliedTxId
blockManagerInstance.heartbeatManager.stats.blockPoolUsed % DataNode.instance.NUM_CORES == 0
blockManagerInstance.heartbeatManager.stats.capacityRemaining % DataNode.instance.NUM_CORES == 0
blockManagerInstance.heartbeatManager.stats.capacityTotal % DataNode.instance.NUM_CORES == 0
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs % DataNode.instance.NUM_CORES == 0
DataNode.instance.NUM_CORES % blockManagerInstance.heartbeatManager.stats.nodesInService == 0
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs % blockManagerInstance.heartbeatManager.stats.nodesInService == 0
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION > DataNode.instance.data.cacheManager.numBlocksFailedToUncache
blockManagerInstance.heartbeatManager.stats.blockPoolUsed % DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION == 0
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME >= DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME > DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME > NameNode.instance.namesystem.fsImage.lastAppliedTxId
blockManagerInstance.heartbeatManager.stats.blockPoolUsed % DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == 0
blockManagerInstance.heartbeatManager.stats.capacityRemaining % DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == 0
blockManagerInstance.heartbeatManager.stats.capacityTotal % DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == 0
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs % DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME == 0
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
blockManagerInstance.heartbeatManager.stats.blockPoolUsed % DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS == 0
blockManagerInstance.heartbeatManager.stats.capacityRemaining % DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS == 0
blockManagerInstance.heartbeatManager.stats.capacityTotal % DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS == 0
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs % DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS == 0
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS % blockManagerInstance.heartbeatManager.stats.nodesInService == 0
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS % blockManagerInstance.heartbeatManager.stats.nodesInService == 0
DataNode.instance.data.asyncDiskService.numDeletedBlocks % blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 0
DataNode.instance.data.asyncDiskService.numDeletedBlocks % blockManagerInstance.heartbeatManager.stats.capacityRemaining == 0
DataNode.instance.data.asyncDiskService.numDeletedBlocks % blockManagerInstance.heartbeatManager.stats.capacityTotal == 0
DataNode.instance.data.asyncDiskService.numDeletedBlocks % blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 0
DataNode.instance.data.asyncDiskService.numDeletedBlocks % blockManagerInstance.heartbeatManager.stats.nodesInService == 0
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME >= DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME != NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS > DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.data.cacheManager.numBlocksCached <= DataNode.instance.data.cacheManager.numBlocksFailedToUncache
DataNode.instance.data.cacheManager.numBlocksCached <= NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.data.cacheManager.numBlocksCached < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.data.volsConfigured
DataNode.instance.data.cacheManager.numBlocksFailedToUncache <= DataNode.instance.directoryScanner.diffs.serialVersionUID
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.diskBalancer.bandwidth
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.dnConf.blockReportInterval
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.dnConf.bpReadyTimeout
DataNode.instance.data.cacheManager.numBlocksFailedToUncache >= DataNode.instance.dnConf.ibrInterval
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.dnConf.maxDataLength
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.dnConf.volsConfigured
DataNode.instance.data.cacheManager.numBlocksFailedToUncache <= DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.httpServer.HTTP_MAX_THREADS
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks
DataNode.instance.data.cacheManager.numBlocksFailedToUncache <= DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < DataNode.instance.xserver.balanceThrottler.period
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.blockDeletionIncrement
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.dir.inodeXAttrsLimit
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.blockReportLeaseManager.maxPending
4 * DataNode.instance.data.cacheManager.numBlocksFailedToUncache - blockManagerInstance.blockReportLeaseManager.nextId - -2147483648 == 0
DataNode.instance.data.cacheManager.numBlocksFailedToUncache <= blockManagerInstance.bmSafeMode.startTime
DataNode.instance.data.cacheManager.numBlocksFailedToUncache <= blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.data.cacheManager.numBlocksFailedToUncache <= blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.data.cacheManager.numBlocksFailedToUncache <= blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.data.cacheManager.numBlocksFailedToUncache <= blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.data.cacheManager.numBlocksFailedToUncache <= blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.neededReconstruction.LEVEL
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
DataNode.instance.data.cacheManager.numBlocksFailedToUncache < blockManagerInstance.storagePolicySuite.defaultPolicyID
DataNode.instance.data.cacheManager.numBlocksFailedToUncache >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
DataNode.instance.data.maxDataLength != DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.data.maxDataLength != DataNode.instance.storage.namespaceID
blockManagerInstance.heartbeatManager.stats.blockPoolUsed % DataNode.instance.data.smallBufferSize == 0
blockManagerInstance.heartbeatManager.stats.capacityRemaining % DataNode.instance.data.smallBufferSize == 0
blockManagerInstance.heartbeatManager.stats.capacityTotal % DataNode.instance.data.smallBufferSize == 0
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs % DataNode.instance.data.smallBufferSize == 0
DataNode.instance.data.volsConfigured < NameNode.instance.namesystem.lazyPersistFileScrubberTS
blockManagerInstance.heartbeatManager.stats.blockPoolUsed % DataNode.instance.data.volsConfigured == 0
blockManagerInstance.heartbeatManager.stats.capacityRemaining % DataNode.instance.data.volsConfigured == 0
blockManagerInstance.heartbeatManager.stats.capacityTotal % DataNode.instance.data.volsConfigured == 0
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs % DataNode.instance.data.volsConfigured == 0
DataNode.instance.directoryScanner.MILLIS_PER_SECOND < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.directoryScanner.MILLIS_PER_SECOND % blockManagerInstance.heartbeatManager.stats.nodesInService == 0
DataNode.instance.directoryScanner.diffs.serialVersionUID != NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.directoryScanner.diffs.serialVersionUID < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.directoryScanner.scanPeriodMsecs < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.directoryScanner.scanPeriodMsecs % blockManagerInstance.heartbeatManager.stats.nodesInService == 0
DataNode.instance.diskBalancer.bandwidth < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.diskBalancer.bandwidth > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.diskBalancer.planValidityInterval > DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.diskBalancer.planValidityInterval > DataNode.instance.storage.namespaceID
DataNode.instance.diskBalancer.planValidityInterval < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.diskBalancer.planValidityInterval % blockManagerInstance.heartbeatManager.stats.nodesInService == 0
DataNode.instance.dnConf.blockReportInterval < DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.blockReportInterval > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.dnConf.blockReportInterval < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.dnConf.blockReportSplitThreshold < DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.bpReadyTimeout < DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.bpReadyTimeout > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.dnConf.cacheReportInterval < DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs < DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.heartBeatInterval < DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.ibrInterval < DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.ibrInterval <= NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.dnConf.ibrInterval < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.dnConf.lifelineIntervalMs < DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.maxDataLength != DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.dnConf.maxDataLength > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.dnConf.maxDataLength < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.dnConf.outliersReportIntervalMs < DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.readaheadLength < DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.restartReplicaExpiry < DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.socketKeepaliveTimeout < DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.socketTimeout < DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.socketWriteTimeout < DataNode.instance.storage.namespaceID
DataNode.instance.dnConf.volsConfigured != NameNode.instance.namesystem.fsImage.lastAppliedTxId
blockManagerInstance.heartbeatManager.stats.blockPoolUsed % DataNode.instance.dnConf.volsConfigured == 0
blockManagerInstance.heartbeatManager.stats.capacityRemaining % DataNode.instance.dnConf.volsConfigured == 0
blockManagerInstance.heartbeatManager.stats.capacityTotal % DataNode.instance.dnConf.volsConfigured == 0
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs % DataNode.instance.dnConf.volsConfigured == 0
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS < DataNode.instance.storage.namespaceID
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS != NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.httpServer.HTTP_MAX_THREADS < DataNode.instance.storage.namespaceID
DataNode.instance.httpServer.HTTP_MAX_THREADS != NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.httpServer.HTTP_MAX_THREADS < NameNode.instance.namesystem.lazyPersistFileScrubberTS
blockManagerInstance.heartbeatManager.stats.blockPoolUsed % DataNode.instance.httpServer.HTTP_MAX_THREADS == 0
blockManagerInstance.heartbeatManager.stats.capacityRemaining % DataNode.instance.httpServer.HTTP_MAX_THREADS == 0
blockManagerInstance.heartbeatManager.stats.capacityTotal % DataNode.instance.httpServer.HTTP_MAX_THREADS == 0
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs % DataNode.instance.httpServer.HTTP_MAX_THREADS == 0
DataNode.instance.httpServer.HTTP_MAX_THREADS >= blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.id.infoPort < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.id.ipcPort < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.id.nsInfo.cTime > NameNode.instance.namesystem.blockDeletionIncrement
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
DataNode.instance.id.nsInfo.namespaceID < DataNode.instance.lastDiskErrorCheck
DataNode.instance.id.nsInfo.namespaceID != DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.id.nsInfo.namespaceID != DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.id.nsInfo.namespaceID != DataNode.instance.xserver.estimateBlockSize
DataNode.instance.id.nsInfo.namespaceID > NameNode.instance.namesystem.blockDeletionIncrement
DataNode.instance.id.nsInfo.namespaceID != NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.id.nsInfo.namespaceID != NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.id.nsInfo.namespaceID != NameNode.instance.namesystem.nnResourceChecker.duReserved
DataNode.instance.id.nsInfo.namespaceID != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
DataNode.instance.id.nsInfo.namespaceID != blockManagerInstance.invalidateBlocks.startupTime
DataNode.instance.id.xferPort < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.lastDiskErrorCheck > DataNode.instance.storage.namespaceID
DataNode.instance.lastDiskErrorCheck > DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.lastDiskErrorCheck > NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.lastDiskErrorCheck > NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.lastDiskErrorCheck % blockManagerInstance.heartbeatManager.stats.nodesInService == 0
DataNode.instance.shortCircuitRegistry.SHM_LENGTH < DataNode.instance.xserver.balanceThrottler.curPeriodStart
blockManagerInstance.heartbeatManager.stats.blockPoolUsed % DataNode.instance.shortCircuitRegistry.SHM_LENGTH == 0
blockManagerInstance.heartbeatManager.stats.capacityRemaining % DataNode.instance.shortCircuitRegistry.SHM_LENGTH == 0
blockManagerInstance.heartbeatManager.stats.capacityTotal % DataNode.instance.shortCircuitRegistry.SHM_LENGTH == 0
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs % DataNode.instance.shortCircuitRegistry.SHM_LENGTH == 0
DataNode.instance.shortCircuitRegistry.SHM_LENGTH % blockManagerInstance.heartbeatManager.stats.nodesInService == 0
DataNode.instance.storage.layoutVersion < DataNode.instance.storage.namespaceID
DataNode.instance.storage.namespaceID > DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks
DataNode.instance.storage.namespaceID > DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout
DataNode.instance.storage.namespaceID > DataNode.instance.xserver.balanceThrottler.bytesPerPeriod
DataNode.instance.storage.namespaceID > DataNode.instance.xserver.balanceThrottler.maxThreads
DataNode.instance.storage.namespaceID > DataNode.instance.xserver.balanceThrottler.period
DataNode.instance.storage.namespaceID > DataNode.instance.xserver.balanceThrottler.periodExtension
DataNode.instance.storage.namespaceID > DataNode.instance.xserver.maxXceiverCount
DataNode.instance.storage.namespaceID > NameNode.instance.DEFAULT_PORT
DataNode.instance.storage.namespaceID > NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.blockDeletionIncrement
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.cacheManager.scanIntervalMs
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.dir.inodeXAttrsLimit
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.dir.maxComponentLength
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.dir.maxDirItems
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.dir.xattrMaxSize
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.editLogRollerThreshold
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.leaseManager.hardLimit
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.leaseRecheckIntervalMs
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
DataNode.instance.storage.namespaceID > NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit
DataNode.instance.storage.namespaceID > blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
DataNode.instance.storage.namespaceID > blockManagerInstance.blockReportLeaseManager.maxPending
DataNode.instance.storage.namespaceID > blockManagerInstance.blocksMap.capacity
DataNode.instance.storage.namespaceID > blockManagerInstance.datanodeManager.defaultInfoPort
DataNode.instance.storage.namespaceID > blockManagerInstance.datanodeManager.defaultInfoSecurePort
DataNode.instance.storage.namespaceID > blockManagerInstance.datanodeManager.defaultIpcPort
DataNode.instance.storage.namespaceID > blockManagerInstance.datanodeManager.defaultXferPort
DataNode.instance.storage.namespaceID > blockManagerInstance.datanodeManager.heartbeatExpireInterval
DataNode.instance.storage.namespaceID > blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
DataNode.instance.storage.namespaceID > blockManagerInstance.neededReconstruction.LEVEL
DataNode.instance.storage.namespaceID > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
DataNode.instance.storage.namespaceID > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
DataNode.instance.storage.namespaceID > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
DataNode.instance.storage.namespaceID > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
DataNode.instance.storage.namespaceID > blockManagerInstance.replQueueResetToHeadThreshold
DataNode.instance.storage.namespaceID > blockManagerInstance.storagePolicySuite.defaultPolicyID
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks < NameNode.instance.namesystem.lazyPersistFileScrubberTS
2 * DataNode.instance.volumeChecker.numSyncDatasetChecks + blockManagerInstance.blockReportLeaseManager.nextId + 2147483647 == 0
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.blockDeletionIncrement
DataNode.instance.xserver.balanceThrottler.curPeriodStart > NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
DataNode.instance.xserver.balanceThrottler.maxThreads < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.xserver.balanceThrottler.maxThreads > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.xserver.balanceThrottler.period > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.xserver.balanceThrottler.period < NameNode.instance.namesystem.lazyPersistFileScrubberTS
blockManagerInstance.heartbeatManager.stats.blockPoolUsed % DataNode.instance.xserver.maxXceiverCount == 0
blockManagerInstance.heartbeatManager.stats.capacityRemaining % DataNode.instance.xserver.maxXceiverCount == 0
blockManagerInstance.heartbeatManager.stats.capacityTotal % DataNode.instance.xserver.maxXceiverCount == 0
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs % DataNode.instance.xserver.maxXceiverCount == 0
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < NameNode.instance.namesystem.blockDeletionIncrement
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > NameNode.instance.namesystem.dir.inodeXAttrsLimit
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > NameNode.instance.namesystem.fsImage.lastAppliedTxId
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
NameNode.instance.namesystem.blockDeletionIncrement > NameNode.instance.namesystem.fsImage.lastAppliedTxId
NameNode.instance.namesystem.blockDeletionIncrement < NameNode.instance.namesystem.lazyPersistFileScrubberTS
NameNode.instance.namesystem.blockDeletionIncrement < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
NameNode.instance.namesystem.blockDeletionIncrement < NameNode.instance.namesystem.startTime
NameNode.instance.namesystem.blockDeletionIncrement != blockManagerInstance.bmSafeMode.startTime
NameNode.instance.namesystem.cacheManager.scanIntervalMs > NameNode.instance.namesystem.fsImage.lastAppliedTxId
NameNode.instance.namesystem.cacheManager.scanIntervalMs < NameNode.instance.namesystem.lazyPersistFileScrubberTS
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE != NameNode.instance.namesystem.fsImage.lastAppliedTxId
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE < NameNode.instance.namesystem.lazyPersistFileScrubberTS
NameNode.instance.namesystem.dir.inodeXAttrsLimit > NameNode.instance.namesystem.fsImage.lastAppliedTxId
NameNode.instance.namesystem.dir.inodeXAttrsLimit < NameNode.instance.namesystem.lazyPersistFileScrubberTS
blockManagerInstance.heartbeatManager.stats.blockPoolUsed % NameNode.instance.namesystem.dir.inodeXAttrsLimit == 0
blockManagerInstance.heartbeatManager.stats.capacityRemaining % NameNode.instance.namesystem.dir.inodeXAttrsLimit == 0
blockManagerInstance.heartbeatManager.stats.capacityTotal % NameNode.instance.namesystem.dir.inodeXAttrsLimit == 0
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs % NameNode.instance.namesystem.dir.inodeXAttrsLimit == 0
blockManagerInstance.heartbeatManager.stats.blockPoolUsed % NameNode.instance.namesystem.dir.xattrMaxSize == 0
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs % NameNode.instance.namesystem.dir.xattrMaxSize == 0
NameNode.instance.namesystem.fsImage.lastAppliedTxId < NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN
NameNode.instance.namesystem.fsImage.lastAppliedTxId < NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
NameNode.instance.namesystem.fsImage.lastAppliedTxId < NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
NameNode.instance.namesystem.fsImage.lastAppliedTxId > blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.fsImage.lastAppliedTxId != blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
NameNode.instance.namesystem.fsImage.lastAppliedTxId <= blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
NameNode.instance.namesystem.fsImage.lastAppliedTxId >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
NameNode.instance.namesystem.lazyPersistFileScrubberTS > NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
blockManagerInstance.heartbeatManager.stats.blockPoolUsed % NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN == 0
blockManagerInstance.heartbeatManager.stats.capacityRemaining % NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN == 0
blockManagerInstance.heartbeatManager.stats.capacityTotal % NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN == 0
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs % NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN == 0
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
blockManagerInstance.heartbeatManager.stats.blockPoolUsed % NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH == 0
NameNode.instance.namesystem.startTime > blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
blockManagerInstance.heartbeatManager.stats.blockPoolUsed % blockManagerInstance.blockReportLeaseManager.maxPending == 0
blockManagerInstance.heartbeatManager.stats.blockPoolUsed % blockManagerInstance.datanodeManager.heartbeatIntervalSeconds == 0
16369651 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 6 * blockManagerInstance.heartbeatManager.stats.capacityTotal == 0
blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 49152 * blockManagerInstance.heartbeatManager.stats.nodesInService == 0
blockManagerInstance.heartbeatManager.stats.blockPoolUsed % blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY == 0
blockManagerInstance.heartbeatManager.stats.blockPoolUsed % blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold == 0
blockManagerInstance.heartbeatManager.stats.capacityRemaining % blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY == 0
blockManagerInstance.heartbeatManager.stats.capacityTotal - -2147483648 * blockManagerInstance.heartbeatManager.stats.nodesInService == 0
blockManagerInstance.heartbeatManager.stats.capacityTotal % blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY == 0
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs % blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY == 0
2813 * DataNode.instance.data.cacheManager.numBlocksFailedToUncache - DataNode.instance.id.nsInfo.cTime + 2813 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) + 1.731381572103E12 == 0
2813 * DataNode.instance.data.cacheManager.numBlocksFailedToUncache - DataNode.instance.id.nsInfo.cTime + 2813 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 + 1.731381574916E12 == 0
3291 * DataNode.instance.data.cacheManager.numBlocksFailedToUncache - DataNode.instance.volumeChecker.lastAllVolumesCheck + 3291 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) + 117678295 == 0
3291 * DataNode.instance.data.cacheManager.numBlocksFailedToUncache - DataNode.instance.volumeChecker.lastAllVolumesCheck + 3291 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 + 117681586 == 0
3227 * DataNode.instance.data.cacheManager.numBlocksFailedToUncache - DataNode.instance.xserver.balanceThrottler.curPeriodStart + 3227 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) + 117677763 == 0
3227 * DataNode.instance.data.cacheManager.numBlocksFailedToUncache - DataNode.instance.xserver.balanceThrottler.curPeriodStart + 3227 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 + 117680990 == 0
894884714 * DataNode.instance.data.cacheManager.numBlocksFailedToUncache + 1019900951 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 2 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 2.3525085306088E14 == 0
6.711635355E9 * DataNode.instance.data.cacheManager.numBlocksFailedToUncache - 2039801902 * NameNode.instance.namesystem.fsImage.lastAppliedTxId - 15 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1.765222816241175E15 == 0
3152 * DataNode.instance.data.cacheManager.numBlocksFailedToUncache - NameNode.instance.namesystem.lazyPersistFileScrubberTS + 3152 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) + 117677478 == 0
3152 * DataNode.instance.data.cacheManager.numBlocksFailedToUncache - NameNode.instance.namesystem.lazyPersistFileScrubberTS + 3152 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 + 117680630 == 0
2884 * DataNode.instance.data.cacheManager.numBlocksFailedToUncache - NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime + 2884 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) + 117677186 == 0
2884 * DataNode.instance.data.cacheManager.numBlocksFailedToUncache - NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime + 2884 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 + 117680070 == 0
2885 * DataNode.instance.data.cacheManager.numBlocksFailedToUncache - NameNode.instance.namesystem.startTime + 2885 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) + 1.731381572277E12 == 0
2885 * DataNode.instance.data.cacheManager.numBlocksFailedToUncache - NameNode.instance.namesystem.startTime + 2885 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 + 1.731381575162E12 == 0
1781721000 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 1019900951 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 2 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 2.3524907133988E14 == 0
1.33629075E10 * DataNode.instance.volumeChecker.numSyncDatasetChecks - 2039801902 * NameNode.instance.namesystem.fsImage.lastAppliedTxId - 15 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1.765209453333675E15 == 0
3.114927529984E13 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 16384 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 15400113 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 1.92809177058063155E18 == 0
1148941402 * DataNode.instance.volumeChecker.numSyncDatasetChecks + NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 296953500 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1.17680630222245E14 == 0
164134486 * DataNode.instance.xserver.balanceThrottler.curPeriodStart - 461 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1.368955635E11 * blockManagerInstance.heartbeatManager.stats.nodesInService + 3.4935261726833804E16 == 0
574470701 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 2 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 593907000 * blockManagerInstance.heartbeatManager.stats.nodesInService + 2.3529806866738E14 == 0
1148941402 * NameNode.instance.namesystem.fsImage.lastAppliedTxId + 15 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 4.4543025E9 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1.765209453333675E15 == 0
1576 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 574470701 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 4.67998716E11 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1.1786059922003648E17 == 0
206 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 82067243 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 6.1172421E10 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1.458453092483546E16 == 0
DataNode.instance.id.infoPort == 34369
DataNode.instance.id.ipcPort == 38305
DataNode.instance.id.nsInfo.cTime == 1731381540746L || DataNode.instance.id.nsInfo.cTime == 1731381543964L
DataNode.instance.id.nsInfo.namespaceID == 331602514 || DataNode.instance.id.nsInfo.namespaceID == 900269145
DataNode.instance.id.xferPort == 41539
DataNode.instance.lastDiskErrorCheck == 117650267
DataNode.instance.storage.namespaceID == 0 || DataNode.instance.storage.namespaceID == 331602514 || DataNode.instance.storage.namespaceID == 900269145
DataNode.instance.volumeChecker.lastAllVolumesCheck == 116749682 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 117647123 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 117650264
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 117646544 || DataNode.instance.xserver.balanceThrottler.curPeriodStart == 117649683
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 58 || NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 62
NameNode.instance.namesystem.fsImage.lastAppliedTxId == 0 || NameNode.instance.namesystem.fsImage.lastAppliedTxId == 10
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 117646267 || NameNode.instance.namesystem.lazyPersistFileScrubberTS == 117649432
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 117645875 || NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 117649076
NameNode.instance.namesystem.startTime == 1731381540967L || NameNode.instance.namesystem.startTime == 1731381544168L
blockManagerInstance.bmSafeMode.startTime == 0 || blockManagerInstance.bmSafeMode.startTime == 117649366
blockManagerInstance.invalidateBlocks.startupTime == 117649077
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS != NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
blockManagerInstance.heartbeatManager.stats.capacityRemaining % DataNode.instance.diskBalancer.bandwidth == 0
DataNode.instance.id.nsInfo.namespaceID < blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
DataNode.instance.storage.layoutVersion <= NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.storage.namespaceID >= NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.storage.namespaceID < blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
2 * DataNode.instance.volumeChecker.numSyncDatasetChecks + blockManagerInstance.blockReportLeaseManager.nextId - -2147483648 == 0
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 2 * blockManagerInstance.blockReportLeaseManager.nextId + 2147483647 == 0
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE >= NameNode.instance.namesystem.fsImage.lastAppliedTxId
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.blockReportLeaseManager.nextId
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.blockReportLeaseManager.nextId - blockManagerInstance.heartbeatManager.stats.nodesInService - -2147483648 == 0
246657322 * DataNode.instance.storage.layoutVersion + 2.720254814E10 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 19 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 2.235339224525136E15 == 0
102858752 * DataNode.instance.storage.layoutVersion - 1867776 * DataNode.instance.xserver.balanceThrottler.curPeriodStart + 59641 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed + 2.19743254315008E14 == 0
6278 * DataNode.instance.storage.layoutVersion - 114 * DataNode.instance.xserver.balanceThrottler.curPeriodStart + 178923 * blockManagerInstance.heartbeatManager.stats.nodesInService + 1.3412063862E10 == 0
246657322 * DataNode.instance.storage.layoutVersion - 6.800637035E9 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE + 19 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 2.234917585028966E15 == 0
246657322 * DataNode.instance.storage.layoutVersion + 2.720254814E9 * NameNode.instance.namesystem.fsImage.lastAppliedTxId + 19 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 2.235339224525136E15 == 0
36407426 * DataNode.instance.storage.layoutVersion - 3 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 2.14756959E9 * blockManagerInstance.heartbeatManager.stats.nodesInService + 3.52948298609232E14 == 0
34570240 * DataNode.instance.storage.layoutVersion - 622592 * NameNode.instance.namesystem.lazyPersistFileScrubberTS + 20045 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed + 7.3247595167744E13 == 0
2110 * DataNode.instance.storage.layoutVersion - 38 * NameNode.instance.namesystem.lazyPersistFileScrubberTS + 60135 * blockManagerInstance.heartbeatManager.stats.nodesInService + 4.470678416E9 == 0
34963456 * DataNode.instance.storage.layoutVersion - 622592 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime + 20273 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed + 7.3247373524992E13 == 0
2134 * DataNode.instance.storage.layoutVersion - 38 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime + 60819 * blockManagerInstance.heartbeatManager.stats.nodesInService + 4.470664888E9 == 0
2134 * DataNode.instance.storage.layoutVersion - 38 * NameNode.instance.namesystem.startTime + 60819 * blockManagerInstance.heartbeatManager.stats.nodesInService + 6.5792498678384E13 == 0
1607221712 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 747675975 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 2 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 2.35252509829038E14 == 0
12 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 3 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 4 * blockManagerInstance.blockReportLeaseManager.nextId + 7.1777909030030264E18 == 0
803610856 * DataNode.instance.volumeChecker.numSyncDatasetChecks - 149535195 * NameNode.instance.namesystem.fsImage.lastAppliedTxId - NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1.17649432869744E14 == 0
3.205780144128E13 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 24576 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 31819445 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 2.8913675197791437E18 == 0
2075223282 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 3 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 803610856 * blockManagerInstance.heartbeatManager.stats.nodesInService - 3.52948298609232E14 == 0
2075223282 * DataNode.instance.xserver.balanceThrottler.curPeriodStart - 9417 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 2.522534476984E12 * blockManagerInstance.heartbeatManager.stats.nodesInService + 8.6375534805285965E17 == 0
1037611641 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 6 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1607221712 * blockManagerInstance.heartbeatManager.stats.nodesInService + 7.05832265296722E14 == 0
1037611641 * NameNode.instance.namesystem.fsImage.lastAppliedTxId + 15 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 4.01805428E9 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1.76474149304616E15 == 0
3165 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 691741094 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 8.4780945308E11 * blockManagerInstance.heartbeatManager.stats.nodesInService - 2.9097750823258118E17 == 0
291 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 62885554 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 7.7950253032E10 * blockManagerInstance.heartbeatManager.stats.nodesInService - 2.68375576432474E16 == 0
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME == DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS == DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED == DataNode.instance.id.nsInfo.capabilities
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED == DataNode.instance.volumeChecker.numSyncDatasetChecks
DataNode.instance.id.infoPort == 38731
DataNode.instance.id.ipcPort == 37797
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED == 1
DataNode.instance.id.nsInfo.cTime == 1731381578794L || DataNode.instance.id.nsInfo.cTime == 1731381581694L
DataNode.instance.id.nsInfo.namespaceID == 1643239630 || DataNode.instance.id.nsInfo.namespaceID == 1677022604
DataNode.instance.id.xferPort == 38297
DataNode.instance.lastDiskErrorCheck == 117688352
DataNode.instance.storage.namespaceID == 0 || DataNode.instance.storage.namespaceID == 1643239630 || DataNode.instance.storage.namespaceID == 1677022604
DataNode.instance.volumeChecker.lastAllVolumesCheck == 116787673 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 117685363 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 117688351
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 117684766 || DataNode.instance.xserver.balanceThrottler.curPeriodStart == 117687674
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 130 || NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 134
NameNode.instance.namesystem.fsImage.lastAppliedTxId == 0 || NameNode.instance.namesystem.fsImage.lastAppliedTxId == 14
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 117684367 || NameNode.instance.namesystem.lazyPersistFileScrubberTS == 117687336
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 117683926 || NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 117686852
NameNode.instance.namesystem.startTime == 1731381579017L || NameNode.instance.namesystem.startTime == 1731381581944L
blockManagerInstance.bmSafeMode.startTime == 0 || blockManagerInstance.bmSafeMode.startTime == 117687233
blockManagerInstance.invalidateBlocks.startupTime == 117686855
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED) != null
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED-1) != null
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION != blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED < DataNode.instance.id.nsInfo.cTime
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED < DataNode.instance.id.nsInfo.namespaceID
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED > DataNode.instance.storage.layoutVersion
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED < DataNode.instance.storage.namespaceID
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED < DataNode.instance.volumeChecker.lastAllVolumesCheck
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED < DataNode.instance.xserver.balanceThrottler.curPeriodStart
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED < NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED != NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED < NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED < NameNode.instance.namesystem.lazyPersistFileScrubberTS
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED < NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED < NameNode.instance.namesystem.startTime
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED < blockManagerInstance.blockReportLeaseManager.nextId
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED != blockManagerInstance.bmSafeMode.startTime
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED != blockManagerInstance.heartbeatManager.stats.capacityRemaining
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED != blockManagerInstance.heartbeatManager.stats.capacityTotal
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
DataNode.instance.id.nsInfo.CAPABILITIES_SUPPORTED != blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID
2 * DataNode.instance.volumeChecker.numSyncDatasetChecks - blockManagerInstance.blockReportLeaseManager.nextId + 2147483647 == 0
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds != blockManagerInstance.heartbeatManager.stats.nodesInService
2.952917756068E12 * DataNode.instance.storage.layoutVersion - 1.16149658385E11 * DataNode.instance.xserver.balanceThrottler.curPeriodStart + 165756 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 5.8379989489875896E18 == 0
23822336 * DataNode.instance.storage.layoutVersion - 466944 * DataNode.instance.xserver.balanceThrottler.curPeriodStart + 13813 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed + 5.4953553248256E13 == 0
2908 * DataNode.instance.storage.layoutVersion - 57 * DataNode.instance.xserver.balanceThrottler.curPeriodStart + 82878 * blockManagerInstance.heartbeatManager.stats.nodesInService + 6.708197418E9 == 0
4.061785084E9 * DataNode.instance.storage.layoutVersion - 1.16149658385E11 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE + 228 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 2.6817148573304384E16 == 0
1.4216247794E10 * DataNode.instance.storage.layoutVersion + 1.16149658385E11 * NameNode.instance.namesystem.fsImage.lastAppliedTxId + 798 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 9.3914494196347904E16 == 0
3.014859978599E12 * DataNode.instance.storage.layoutVersion + 169233 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 1.16149658385E11 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 6.2472370751419249E18 == 0
1.56378725734E11 * DataNode.instance.storage.layoutVersion + 8778 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 6.113139915E9 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 3.1362324372792934E17 == 0
681511356 * DataNode.instance.storage.layoutVersion - 38 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 3.8716552795E10 * blockManagerInstance.heartbeatManager.stats.nodesInService + 4.472118771254662E15 == 0
97288192 * DataNode.instance.storage.layoutVersion - 1867776 * NameNode.instance.namesystem.lazyPersistFileScrubberTS + 56411 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed + 2.19813581684736E14 == 0
5938 * DataNode.instance.storage.layoutVersion - 114 * NameNode.instance.namesystem.lazyPersistFileScrubberTS + 169233 * blockManagerInstance.heartbeatManager.stats.nodesInService + 1.3416356304E10 == 0
2523136 * DataNode.instance.storage.layoutVersion - 49152 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime + 1463 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed + 5.784544149504E12 == 0
154 * DataNode.instance.storage.layoutVersion - 3 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime + 4389 * blockManagerInstance.heartbeatManager.stats.nodesInService + 353060556 == 0
5854 * DataNode.instance.storage.layoutVersion - 114 * NameNode.instance.namesystem.startTime + 166839 * blockManagerInstance.heartbeatManager.stats.nodesInService + 1.97377500341616E14 == 0
1463 * DataNode.instance.storage.namespaceID + 838511302 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 1.202029789345E12 * blockManagerInstance.heartbeatManager.stats.nodesInService - 9.8681755498801312E16 == 0
518501603 * DataNode.instance.volumeChecker.lastAllVolumesCheck - 4.66683634015584E14 * DataNode.instance.volumeChecker.numSyncDatasetChecks - 747 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 2.73583106913841E16 == 0
16384 * DataNode.instance.volumeChecker.lastAllVolumesCheck - 1.470775296E10 * DataNode.instance.volumeChecker.numSyncDatasetChecks - 249 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 1.913449234432E12 == 0
1454 * DataNode.instance.volumeChecker.lastAllVolumesCheck + 448845 * DataNode.instance.xserver.balanceThrottler.curPeriodStart - 327396453 * blockManagerInstance.heartbeatManager.stats.nodesInService - 5.2993333313072E13 == 0
5938 * DataNode.instance.volumeChecker.lastAllVolumesCheck + 1795380 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 1337056491 * blockManagerInstance.heartbeatManager.stats.nodesInService - 2.11986974509954E14 == 0
2926 * DataNode.instance.volumeChecker.lastAllVolumesCheck + 897690 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 658845957 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1.05988030903078E14 == 0
5854 * DataNode.instance.volumeChecker.lastAllVolumesCheck + 1795380 * NameNode.instance.namesystem.startTime - 1318142253 * blockManagerInstance.heartbeatManager.stats.nodesInService - 3.1084885482656563E18 == 0
7.64614527806E11 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 518501603 * DataNode.instance.xserver.balanceThrottler.curPeriodStart - 727 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 2.45374457119254E16 == 0
142934016 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 49152 * DataNode.instance.xserver.balanceThrottler.curPeriodStart - 727 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 5.784584552448E12 == 0
2908 * DataNode.instance.volumeChecker.numSyncDatasetChecks + DataNode.instance.xserver.balanceThrottler.curPeriodStart - 727 * blockManagerInstance.heartbeatManager.stats.nodesInService - 117687674 == 0
1051739378 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 518501603 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1.17617856870847E14 == 0
7.362175646E9 * DataNode.instance.volumeChecker.numSyncDatasetChecks - 1037003206 * NameNode.instance.namesystem.fsImage.lastAppliedTxId - 7 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 8.23811352599543E14 == 0
3.122614213282E12 * DataNode.instance.volumeChecker.numSyncDatasetChecks - 2969 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 2074006412 * NameNode.instance.namesystem.lazyPersistFileScrubberTS + 1.05329411363093456E17 == 0
1.538694710014E12 * DataNode.instance.volumeChecker.numSyncDatasetChecks - 1463 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1037003206 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime + 5.0134929865256976E16 == 0
1022267034 * DataNode.instance.volumeChecker.numSyncDatasetChecks + NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 518501603 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1.17687336085649E14 == 0
583729152 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 196608 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 2969 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 2.3138271756288E13 == 0
11876 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 4 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 2969 * blockManagerInstance.heartbeatManager.stats.nodesInService - 470749344 == 0
287637504 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 98304 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 1463 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 1.1569088299008E13 == 0
5852 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 2 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 1463 * blockManagerInstance.heartbeatManager.stats.nodesInService - 235373704 == 0
575471616 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 196608 * NameNode.instance.namesystem.startTime - 2927 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 3.4040347006284595E17 == 0
11708 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 4 * NameNode.instance.namesystem.startTime - 2927 * blockManagerInstance.heartbeatManager.stats.nodesInService - 6.925526327776E12 == 0
511133517 * DataNode.instance.xserver.balanceThrottler.curPeriodStart - 1454 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 3.82307263903E11 * blockManagerInstance.heartbeatManager.stats.nodesInService + 1.10963271949364192E17 == 0
511133517 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 2 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 525869689 * blockManagerInstance.heartbeatManager.stats.nodesInService + 2.3530618028002E14 == 0
1022267034 * NameNode.instance.namesystem.fsImage.lastAppliedTxId + 14 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 3.681087823E9 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1.647622705199086E15 == 0
5938 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 2044534068 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 1.561307106641E12 * blockManagerInstance.heartbeatManager.stats.nodesInService - 4.5821163385242093E17 == 0
2926 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 1022267034 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 7.69347355007E11 * blockManagerInstance.heartbeatManager.stats.nodesInService - 2.24045756251772E17 == 0
DataNode.instance.id.infoPort == 42985
DataNode.instance.id.ipcPort == 42911
DataNode.instance.id.nsInfo.cTime == 1731381549889L || DataNode.instance.id.nsInfo.cTime == 1731381572103L
DataNode.instance.id.nsInfo.namespaceID == 452757318 || DataNode.instance.id.nsInfo.namespaceID == 1398609070
DataNode.instance.id.xferPort == 45377
DataNode.instance.lastDiskErrorCheck == 117678296
DataNode.instance.storage.namespaceID == 0 || DataNode.instance.storage.namespaceID == 452757318 || DataNode.instance.storage.namespaceID == 1398609070
DataNode.instance.volumeChecker.lastAllVolumesCheck == 116777762 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 117656511 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 117678295
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 117655726 || DataNode.instance.xserver.balanceThrottler.curPeriodStart == 117677763
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 94 || NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 98
NameNode.instance.namesystem.fsImage.lastAppliedTxId == 0 || NameNode.instance.namesystem.fsImage.lastAppliedTxId == 2
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 117655374 || NameNode.instance.namesystem.lazyPersistFileScrubberTS == 117677478
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 117655031 || NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 117677186
NameNode.instance.namesystem.startTime == 1731381550123L || NameNode.instance.namesystem.startTime == 1731381572277L
blockManagerInstance.bmSafeMode.startTime == 0 || blockManagerInstance.bmSafeMode.startTime == 117677443
blockManagerInstance.invalidateBlocks.startupTime == 117677188
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION > NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.data.volsConfigured >= NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.dnConf.volsConfigured >= NameNode.instance.namesystem.fsImage.lastAppliedTxId
DataNode.instance.httpServer.HTTP_MAX_THREADS > NameNode.instance.namesystem.fsImage.lastAppliedTxId
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE > NameNode.instance.namesystem.fsImage.lastAppliedTxId
blockManagerInstance.heartbeatManager.stats.capacityRemaining % NameNode.instance.namesystem.dir.xattrMaxSize == 0
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.blockReportLeaseManager.maxPending
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.neededReconstruction.LEVEL
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.storagePolicySuite.defaultPolicyID
3.227402164E9 * DataNode.instance.storage.layoutVersion - 1.221275124375E12 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE + 228 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 2.6710780095105496E16 == 0
1613701082 * DataNode.instance.storage.layoutVersion + 1.221275124375E12 * NameNode.instance.namesystem.fsImage.lastAppliedTxId + 114 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 1.3415232528647124E16 == 0
1166 * DataNode.instance.storage.layoutVersion - 3 * NameNode.instance.namesystem.startTime + 33231 * blockManagerInstance.heartbeatManager.stats.nodesInService + 5.194144716831E12 == 0
66462 * DataNode.instance.volumeChecker.lastAllVolumesCheck + 2636247 * NameNode.instance.namesystem.startTime - 1.9950408082E10 * blockManagerInstance.heartbeatManager.stats.nodesInService - 4.5643572370541425E18 == 0
1651496136 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 1.0722388451E10 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 2 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 2.34304162574734E14 == 0
825748068 * DataNode.instance.volumeChecker.numSyncDatasetChecks - 1.0722388451E10 * NameNode.instance.namesystem.fsImage.lastAppliedTxId - NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1.17677478321466E14 == 0
1633370112 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 73728 * NameNode.instance.namesystem.startTime - 11077 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 1.27651300560838656E17 == 0
66462 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 3 * NameNode.instance.namesystem.startTime - 22154 * blockManagerInstance.heartbeatManager.stats.nodesInService - 5.194144716831E12 == 0
2.0619028834E10 * DataNode.instance.xserver.balanceThrottler.curPeriodStart - 22037 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 6.065670058172E12 * blockManagerInstance.heartbeatManager.stats.nodesInService + 1.66857401352527904E17 == 0
1.0309514417E10 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 2 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 550498712 * blockManagerInstance.heartbeatManager.stats.nodesInService + 2.34344624230066E14 == 0
1.0309514417E10 * NameNode.instance.namesystem.fsImage.lastAppliedTxId + NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 275249356 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1.17677478321466E14 == 0
11052 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 1.0309514417E10 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 3.042055882512E12 * blockManagerInstance.heartbeatManager.stats.nodesInService - 8.7373834411641904E16 == 0
22155 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 2.0619028834E10 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 6.09814948218E12 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1.80755240974098112E17 == 0
DataNode.instance.id.infoPort == 37981
DataNode.instance.id.ipcPort == 41089
DataNode.instance.id.nsInfo.cTime == 1731381538769L || DataNode.instance.id.nsInfo.cTime == 1731381540746L
DataNode.instance.id.nsInfo.namespaceID == 900269145 || DataNode.instance.id.nsInfo.namespaceID == 1335357340
DataNode.instance.id.xferPort == 43621
DataNode.instance.lastDiskErrorCheck == 117647125
DataNode.instance.storage.namespaceID == 0 || DataNode.instance.storage.namespaceID == 900269145 || DataNode.instance.storage.namespaceID == 1335357340
DataNode.instance.volumeChecker.lastAllVolumesCheck == 116746542 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 117645059 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 117647123
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 117644528 || DataNode.instance.xserver.balanceThrottler.curPeriodStart == 117646544
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 46 || NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 50
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 117644269 || NameNode.instance.namesystem.lazyPersistFileScrubberTS == 117646267
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 117643945 || NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 117645875
NameNode.instance.namesystem.startTime == 1731381539037L || NameNode.instance.namesystem.startTime == 1731381540967L
blockManagerInstance.bmSafeMode.startTime == 0 || blockManagerInstance.bmSafeMode.startTime == 117646230
blockManagerInstance.invalidateBlocks.startupTime == 117645876
blockManagerInstance.blockReportLeaseManager.nextId % DataNode.instance.diskBalancer.bandwidth == 0
DataNode.instance.xserver.balanceThrottler.maxThreads >= NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
689812190 * DataNode.instance.storage.layoutVersion + 8.6233215111E10 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 57 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 6.705837242579475E15 == 0
4.6355379168E11 * DataNode.instance.storage.layoutVersion - 2.8744405037E10 * DataNode.instance.xserver.balanceThrottler.curPeriodStart + 38304 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 1.12464271507416512E18 == 0
688128 * DataNode.instance.storage.layoutVersion - 19456 * DataNode.instance.xserver.balanceThrottler.curPeriodStart + 399 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed + 2.288931160064E12 == 0
672 * DataNode.instance.storage.layoutVersion - 19 * DataNode.instance.xserver.balanceThrottler.curPeriodStart + 19152 * blockManagerInstance.heartbeatManager.stats.nodesInService + 2.235284336E9 == 0
2.75924876E9 * DataNode.instance.storage.layoutVersion - 8.6233215111E10 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE + 228 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 2.6819037309562352E16 == 0
1379624380 * DataNode.instance.storage.layoutVersion + 8.6233215111E10 * NameNode.instance.namesystem.fsImage.lastAppliedTxId + 114 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 1.341167448515895E16 == 0
4.5941491854E11 * DataNode.instance.storage.layoutVersion + 37962 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 2.8744405037E10 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 1.08441565381888346E18 == 0
1.3313375267E12 * DataNode.instance.storage.layoutVersion + 110010 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 8.6233215111E10 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 2.7972838323815695E18 == 0
548700822 * DataNode.instance.storage.layoutVersion - 38 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 2.8744405037E10 * blockManagerInstance.heartbeatManager.stats.nodesInService + 4.47055816171965E15 == 0
10911744 * DataNode.instance.storage.layoutVersion - 311296 * NameNode.instance.namesystem.lazyPersistFileScrubberTS + 6327 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed + 3.6622812332032E13 == 0
666 * DataNode.instance.storage.layoutVersion - 19 * NameNode.instance.namesystem.lazyPersistFileScrubberTS + 18981 * blockManagerInstance.heartbeatManager.stats.nodesInService + 2.235279073E9 == 0
31621120 * DataNode.instance.storage.layoutVersion - 933888 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime + 18335 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed + 1.09868070912E14 == 0
1930 * DataNode.instance.storage.layoutVersion - 57 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime + 55005 * blockManagerInstance.heartbeatManager.stats.nodesInService + 6.705814875E9 == 0
1930 * DataNode.instance.storage.layoutVersion - 57 * NameNode.instance.namesystem.startTime + 55005 * blockManagerInstance.heartbeatManager.stats.nodesInService + 9.8688747835119E13 == 0
1496456186 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 785639663 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 2 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 2.352532528442E14 == 0
748228093 * DataNode.instance.volumeChecker.numSyncDatasetChecks - 785639663 * NameNode.instance.namesystem.fsImage.lastAppliedTxId - NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1.17646267413675E14 == 0
6.8617746038784E13 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 49152 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 58415903 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 5.782577499048788E18 == 0
2.469153699E9 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 3 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 748228093 * blockManagerInstance.heartbeatManager.stats.nodesInService - 3.52938802241025E14 == 0
274350411 * DataNode.instance.xserver.balanceThrottler.curPeriodStart - 672 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1.67603092832E11 * blockManagerInstance.heartbeatManager.stats.nodesInService + 4.6781914002860016E16 == 0
2.469153699E9 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 12 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 2.992912372E9 * blockManagerInstance.heartbeatManager.stats.nodesInService + 1.41163175127915E15 == 0
2.469153699E9 * NameNode.instance.namesystem.fsImage.lastAppliedTxId + 6 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 1496456186 * blockManagerInstance.heartbeatManager.stats.nodesInService - 7.0587760448205E14 == 0
222 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 91450137 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 5.5368878882E10 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1.5358704131147272E16 == 0
5790 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 2.469153699E9 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 1.44408021949E12 * blockManagerInstance.heartbeatManager.stats.nodesInService - 3.9068614089683661E17 == 0
DataNode.instance.id.infoPort == 36801
DataNode.instance.id.ipcPort == 46577
DataNode.instance.id.nsInfo.cTime == 1731381980061L || DataNode.instance.id.nsInfo.cTime == 1731381986614L
DataNode.instance.id.nsInfo.namespaceID == 1166829558 || DataNode.instance.id.nsInfo.namespaceID == 1667342582
DataNode.instance.id.xferPort == 43011
DataNode.instance.lastDiskErrorCheck == 118092793
DataNode.instance.storage.namespaceID == 0 || DataNode.instance.storage.namespaceID == 1166829558 || DataNode.instance.storage.namespaceID == 1667342582
DataNode.instance.volumeChecker.lastAllVolumesCheck == 117192276 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 118089239 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 118092792
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118088484 || DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118092278
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 22 || NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 26
NameNode.instance.namesystem.fsImage.lastAppliedTxId == 0 || NameNode.instance.namesystem.fsImage.lastAppliedTxId == 33
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118087199 || NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118092057
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118086474 || NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118091754
NameNode.instance.namesystem.startTime == 1731381981566L || NameNode.instance.namesystem.startTime == 1731381986846L
blockManagerInstance.bmSafeMode.startTime == 0 || blockManagerInstance.bmSafeMode.startTime == 118092017
blockManagerInstance.invalidateBlocks.startupTime == 118091757
daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) == 0 || daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) == 1 || daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) == 6
DataNode.instance.NUM_CORES > NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
DataNode.instance.data.volsConfigured != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.data.volsConfigured != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
DataNode.instance.directoryScanner.diffs.serialVersionUID != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
DataNode.instance.dnConf.volsConfigured != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.volsConfigured != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
DataNode.instance.httpServer.HTTP_MAX_THREADS != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
DataNode.instance.httpServer.HTTP_MAX_THREADS != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
DataNode.instance.volumeChecker.numSyncDatasetChecks != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE != NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE != NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
NameNode.instance.namesystem.dir.inodeXAttrsLimit != NameNode.instance.namesystem.fsImage.lastAppliedTxId
blockManagerInstance.blockReportLeaseManager.maxPending >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.bmSafeMode.startTime != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.bmSafeMode.startTime != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
blockManagerInstance.heartbeatManager.stats.blockPoolUsed != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
blockManagerInstance.heartbeatManager.stats.capacityRemaining != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
blockManagerInstance.heartbeatManager.stats.capacityTotal != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
blockManagerInstance.heartbeatManager.stats.nodesInService != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
blockManagerInstance.neededReconstruction.LEVEL != daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)
blockManagerInstance.neededReconstruction.LEVEL >= daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1
680226914 * DataNode.instance.storage.layoutVersion + 7.9404063522E10 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 57 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 6.731247295770951E15 == 0
62160896 * DataNode.instance.storage.layoutVersion - 933888 * DataNode.instance.xserver.balanceThrottler.curPeriodStart + 36043 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed + 1.10284961316864E14 == 0
3794 * DataNode.instance.storage.layoutVersion - 57 * DataNode.instance.xserver.balanceThrottler.curPeriodStart + 108129 * blockManagerInstance.heartbeatManager.stats.nodesInService + 6.731259846E9 == 0
1360453828 * DataNode.instance.storage.layoutVersion - 3.9702031761E10 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE + 114 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 1.3461462338716116E16 == 0
7.482496054E9 * DataNode.instance.storage.layoutVersion + 2.6468021174E10 * NameNode.instance.namesystem.fsImage.lastAppliedTxId + 627 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 7.4043720253480464E16 == 0
237608944 * DataNode.instance.storage.layoutVersion - 19 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1.3234010587E10 * blockManagerInstance.heartbeatManager.stats.nodesInService + 2.243749098590317E15 == 0
680226914 * DataNode.instance.storage.layoutVersion + 57 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1.3234010587E10 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) - 6.731247295770951E15 == 0
680226914 * DataNode.instance.storage.layoutVersion + 57 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1.3234010587E10 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 - 6.731234061760364E15 == 0
79593472 * DataNode.instance.storage.layoutVersion - 933888 * NameNode.instance.namesystem.lazyPersistFileScrubberTS + 46151 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed + 1.10284754927616E14 == 0
4858 * DataNode.instance.storage.layoutVersion - 57 * NameNode.instance.namesystem.lazyPersistFileScrubberTS + 138453 * blockManagerInstance.heartbeatManager.stats.nodesInService + 6.731247249E9 == 0
1802240 * DataNode.instance.storage.layoutVersion - 19456 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime + 1045 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed + 2.297593165824E12 == 0
1760 * DataNode.instance.storage.layoutVersion - 19 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime + 50160 * blockManagerInstance.heartbeatManager.stats.nodesInService + 2.243743326E9 == 0
1760 * DataNode.instance.storage.layoutVersion - 19 * NameNode.instance.namesystem.startTime + 50160 * blockManagerInstance.heartbeatManager.stats.nodesInService + 3.2896257750074E13 == 0
81944338 * DataNode.instance.volumeChecker.lastAllVolumesCheck - 7.3792187478408E13 * DataNode.instance.volumeChecker.numSyncDatasetChecks - 209 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1.5078138776385226E16 == 0
186482688 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 49152 * DataNode.instance.xserver.balanceThrottler.curPeriodStart - 1897 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 5.804471648256E12 == 0
3794 * DataNode.instance.volumeChecker.numSyncDatasetChecks + DataNode.instance.xserver.balanceThrottler.curPeriodStart - 1897 * blockManagerInstance.heartbeatManager.stats.nodesInService - 118092278 == 0
238780416 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 49152 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 2429 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 5.804460785664E12 == 0
4858 * DataNode.instance.volumeChecker.numSyncDatasetChecks + NameNode.instance.namesystem.lazyPersistFileScrubberTS - 2429 * blockManagerInstance.heartbeatManager.stats.nodesInService - 118092057 == 0
5406720 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 1024 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 55 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 1.20925956096E11 == 0
5280 * DataNode.instance.volumeChecker.numSyncDatasetChecks + NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 2640 * blockManagerInstance.heartbeatManager.stats.nodesInService - 118091754 == 0
5406720 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 1024 * NameNode.instance.namesystem.startTime - 55 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 1.772935154530304E15 == 0
5280 * DataNode.instance.volumeChecker.numSyncDatasetChecks + NameNode.instance.namesystem.startTime - 2640 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1.731381986846E12 == 0
356413416 * DataNode.instance.xserver.balanceThrottler.curPeriodStart - 1897 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 4.77123110835E11 * blockManagerInstance.heartbeatManager.stats.nodesInService + 1.81930961480368416E17 == 0
511449069 * DataNode.instance.xserver.balanceThrottler.curPeriodStart - 271 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 2.91210282719E11 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) - 2.8395237969822028E16 == 0
511449069 * DataNode.instance.xserver.balanceThrottler.curPeriodStart - 271 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 2.91210282719E11 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 - 2.8394946759539308E16 == 0
178206708 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 251514555 * blockManagerInstance.heartbeatManager.stats.nodesInService + 1.18087424446135E14 == 0
3.580143483E9 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 2 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 2.149153378E9 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) + 2.36091031910528E14 == 0
3.580143483E9 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 2 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 2.149153378E9 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 + 2.36093181063906E14 == 0
237608944 * NameNode.instance.namesystem.fsImage.lastAppliedTxId + 11 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 2.766660105E9 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1.299012636025973E15 == 0
2.386762322E9 * NameNode.instance.namesystem.fsImage.lastAppliedTxId + 11 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 1.1820343579E10 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) - 1.299012636025973E15 == 0
2.386762322E9 * NameNode.instance.namesystem.fsImage.lastAppliedTxId + 11 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 1.1820343579E10 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 - 1.299024456369552E15 == 0
7 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 1027128 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 1760601885 * blockManagerInstance.heartbeatManager.stats.nodesInService - 7.05348746421505E14 == 0
110 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 14850559 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 2.766660105E10 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1.1236397800069244E16 == 0
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 251514555 * blockManagerInstance.heartbeatManager.stats.nodesInService + 118804472 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) - 1.18092057820543E14 == 0
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 251514555 * blockManagerInstance.heartbeatManager.stats.nodesInService + 118804472 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 - 1.18091939016071E14 == 0
DataNode.instance.id.infoPort == 45137
DataNode.instance.id.ipcPort == 43449
DataNode.instance.id.nsInfo.cTime == 1731381980061L
DataNode.instance.id.nsInfo.namespaceID == 1667342582
DataNode.instance.id.xferPort == 45473
DataNode.instance.lastDiskErrorCheck == 118089246
DataNode.instance.storage.namespaceID == 1667342582
DataNode.instance.volumeChecker.lastAllVolumesCheck == 117188483 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 118089239
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118088484
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118087199
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118086474
NameNode.instance.namesystem.startTime == 1731381981566L
blockManagerInstance.blockReportLeaseManager.nextId == 1250788065119299552L || blockManagerInstance.blockReportLeaseManager.nextId == 1250788065119299555L
blockManagerInstance.blockReportLeaseManager.numPending == 0 || blockManagerInstance.blockReportLeaseManager.numPending == 3
blockManagerInstance.bmSafeMode.startTime == 0 || blockManagerInstance.bmSafeMode.startTime == 118087159
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 0 || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 280399847424L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 0 || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 101284724736L
blockManagerInstance.invalidateBlocks.startupTime == 118086476
blockManagerInstance.lastRedundancyCycleTS == -1 || blockManagerInstance.lastRedundancyCycleTS == 118090159
DataNode.instance.MAX_VOLUME_FAILURE_TOLERATED_LIMIT < blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.NUM_CORES > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.blockScanner.joinVolumeScannersTimeOutMs > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION >= blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME != blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.data.asyncDiskService.MAXIMUM_THREADS_PER_VOLUME > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.data.asyncDiskService.MAX_DELETED_BLOCKS > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.data.asyncDiskService.THREADS_KEEP_ALIVE_SECONDS > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.data.asyncDiskService.numDeletedBlocks <= blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME != blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.data.cacheManager.numBlocksCached <= blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.data.cacheManager.revocationMs > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.data.cacheManager.revocationPollingMs > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.data.maxDataLength > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.data.smallBufferSize > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.data.volsConfigured != blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.directoryScanner.MILLIS_PER_SECOND > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.directoryScanner.scanPeriodMsecs > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.diskBalancer.bandwidth > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.diskBalancer.planValidityInterval > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.dnConf.blockReportInterval > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.dnConf.blockReportSplitThreshold > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.dnConf.bpReadyTimeout > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.dnConf.cacheReportInterval > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.dnConf.heartBeatInterval > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.dnConf.ibrInterval <= blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.dnConf.lifelineIntervalMs > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.dnConf.maxDataLength > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.dnConf.outliersReportIntervalMs > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.dnConf.readaheadLength > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.dnConf.restartReplicaExpiry > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.dnConf.socketKeepaliveTimeout > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.dnConf.socketTimeout > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.dnConf.socketWriteTimeout > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.dnConf.volsConfigured != blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS != blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.httpServer.HTTP_MAX_THREADS > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.id.infoPort > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.id.ipcPort > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.id.nsInfo.layoutVersion < blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.id.xferPort > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.lastDiskErrorCheck > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.shortCircuitRegistry.SHM_LENGTH > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.storage.layoutVersion < blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.storage.namespaceID > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.xserver.balanceThrottler.maxThreads > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.xserver.balanceThrottler.period > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.xserver.balanceThrottler.periodExtension > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.xserver.estimateBlockSize > blockManagerInstance.blockReportLeaseManager.numPending
DataNode.instance.xserver.maxXceiverCount > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.DEFAULT_PORT > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.blockDeletionIncrement > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.cacheManager.scanIntervalMs > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.dir.inodeXAttrsLimit > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.dir.maxComponentLength > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.dir.maxDirItems > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.dir.xattrMaxSize > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.editLogRollerThreshold > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.leaseManager.hardLimit > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.leaseRecheckIntervalMs > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.nnResourceChecker.duReserved > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit > blockManagerInstance.blockReportLeaseManager.numPending
NameNode.instance.namesystem.startTime > blockManagerInstance.blockReportLeaseManager.numPending
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER > blockManagerInstance.blockReportLeaseManager.numPending
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID > blockManagerInstance.blockReportLeaseManager.numPending
blockManagerInstance.blockIdManager.generationStamp.LAST_RESERVED_STAMP > blockManagerInstance.blockReportLeaseManager.numPending
blockManagerInstance.blockIdManager.legacyGenerationStampLimit <= blockManagerInstance.blockReportLeaseManager.numPending
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs > blockManagerInstance.blockReportLeaseManager.numPending
blockManagerInstance.blockReportLeaseManager.maxPending > blockManagerInstance.blockReportLeaseManager.numPending
blockManagerInstance.blockReportLeaseManager.nextId > blockManagerInstance.blockReportLeaseManager.numPending
2 * blockManagerInstance.blockReportLeaseManager.nextId - 3 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) - -2147483648 == 0
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.blocksMap.capacity
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.blocksPerPostpondedRescan
blockManagerInstance.blockReportLeaseManager.numPending != blockManagerInstance.blocksReplWorkMultiplier
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE
blockManagerInstance.blockReportLeaseManager.numPending > blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size
blockManagerInstance.blockReportLeaseManager.numPending != blockManagerInstance.bmSafeMode.safeReplication
blockManagerInstance.blockReportLeaseManager.numPending <= blockManagerInstance.bmSafeMode.startTime
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.datanodeManager.defaultInfoPort
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.datanodeManager.defaultInfoSecurePort
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.datanodeManager.defaultIpcPort
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.datanodeManager.defaultXferPort
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.datanodeManager.heartbeatExpireInterval
blockManagerInstance.blockReportLeaseManager.numPending <= blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.datanodeManager.heartbeatManager.REPORT_STALE_NODE_NODES_PER_LINE
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.datanodeManager.staleInterval
blockManagerInstance.blockReportLeaseManager.numPending <= blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.blockReportLeaseManager.numPending <= blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.blockReportLeaseManager.numPending <= blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.blockReportLeaseManager.numPending <= blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.blockReportLeaseManager.numPending <= blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.blockReportLeaseManager.numPending != blockManagerInstance.lastRedundancyCycleTS
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.maxCorruptFilesReturned
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.placementPolicies.ecPolicy.heartbeatInterval
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.storageInfoDefragmentInterval
blockManagerInstance.blockReportLeaseManager.numPending < blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.blockReportLeaseManager.numPending <= daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)
blockManagerInstance.blockReportLeaseManager.numPending != daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1
2000043051 * DataNode.instance.volumeChecker.numSyncDatasetChecks - NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 115117337 * blockManagerInstance.heartbeatManager.stats.nodesInService + 1.18087199426012E14 == 0
2 * blockManagerInstance.blockReportLeaseManager.nextId - 2 * blockManagerInstance.blockReportLeaseManager.numPending - 3 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) - 2.5015761302385992E18 == 0
2 * blockManagerInstance.blockReportLeaseManager.nextId - 2 * blockManagerInstance.blockReportLeaseManager.numPending - 3 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 - 2.5015761302385992E18 == 0
blockManagerInstance.blockReportLeaseManager.nextId - 3 * blockManagerInstance.replQueueCallsSinceReset - 3 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) - 1.25078806511929958E18 == 0
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == blockManagerInstance.storagePolicySuite.defaultPolicyID
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksFailedToUncache-1)
DataNode.instance.id.infoPort == 34537
DataNode.instance.id.ipcPort == 40377
DataNode.instance.id.nsInfo.cTime == 1731381968526L
DataNode.instance.id.nsInfo.namespaceID == 407979337
DataNode.instance.id.xferPort == 41605
DataNode.instance.lastDiskErrorCheck == 118077516
DataNode.instance.volumeChecker.lastAllVolumesCheck == 118077509
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118076863
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118075674
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118074922
NameNode.instance.namesystem.startTime == 1731381970014L
blockManagerInstance.blockReportLeaseManager.nextId == -3378519502760484963L
blockManagerInstance.bmSafeMode.startTime == 118075634
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 171353
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 280291361792L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 101258969767L
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 7
blockManagerInstance.invalidateBlocks.startupTime == 118074924
blockManagerInstance.lastRedundancyCycleTS == 118078634
blockManagerInstance.lastRedundancyCycleTS == 118081635
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 280447598592L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 101236973568L
DataNode.instance.id.infoPort == 35905
DataNode.instance.id.ipcPort == 40999
DataNode.instance.id.nsInfo.cTime == 1731381959142L || DataNode.instance.id.nsInfo.cTime == 1731381963847L
DataNode.instance.id.nsInfo.namespaceID == 227860339 || DataNode.instance.id.nsInfo.namespaceID == 1038947711
DataNode.instance.id.xferPort == 34137
DataNode.instance.lastDiskErrorCheck == 118070308
DataNode.instance.storage.namespaceID == 0 || DataNode.instance.storage.namespaceID == 227860339 || DataNode.instance.storage.namespaceID == 1038947711
DataNode.instance.volumeChecker.lastAllVolumesCheck == 117169954 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 118068078 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 118070307
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118067247 || DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118069956
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118068542248273L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118069929512151L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118070334375643L
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118066378 || NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118069929
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118065643 || NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118068985
NameNode.instance.namesystem.startTime == 1731381960735L || NameNode.instance.namesystem.startTime == 1731381964077L
blockManagerInstance.blockReportLeaseManager.nextId == 7463640860720084463L || blockManagerInstance.blockReportLeaseManager.nextId == 7463640860720084464L
blockManagerInstance.bmSafeMode.startTime == 0 || blockManagerInstance.bmSafeMode.startTime == 118069890
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 0 || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93484843008L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 0 || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33743347712L
blockManagerInstance.invalidateBlocks.startupTime == 118068987
DataNode.instance.dnConf.volsConfigured == blockManagerInstance.defaultReplication
daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS) == daikon.Quant.getElement_Object(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE, blockManagerInstance.defaultReplication-1)
DataNode.instance.id.infoPort == 46027
DataNode.instance.id.ipcPort == 39747
DataNode.instance.id.nsInfo.cTime == 1731381604750L || DataNode.instance.id.nsInfo.cTime == 1731381611960L
DataNode.instance.id.nsInfo.namespaceID == 611988159 || DataNode.instance.id.nsInfo.namespaceID == 1938600423
DataNode.instance.id.xferPort == 43153
DataNode.instance.lastDiskErrorCheck == 117718440
DataNode.instance.storage.namespaceID == 0 || DataNode.instance.storage.namespaceID == 611988159 || DataNode.instance.storage.namespaceID == 1938600423
DataNode.instance.volumeChecker.lastAllVolumesCheck == 116817913 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 117714906 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 117718429
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 117714167 || DataNode.instance.xserver.balanceThrottler.curPeriodStart == 117717914
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 117712422 || NameNode.instance.namesystem.lazyPersistFileScrubberTS == 117717656
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 117711349 || NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 117717106
NameNode.instance.namesystem.startTime == 1731381606441L || NameNode.instance.namesystem.startTime == 1731381612198L
blockManagerInstance.blockReportLeaseManager.nextId == -8305888717269324769L || blockManagerInstance.blockReportLeaseManager.nextId == -8305888717269324768L || blockManagerInstance.blockReportLeaseManager.nextId == -8305888717269324767L
blockManagerInstance.bmSafeMode.startTime == 0 || blockManagerInstance.bmSafeMode.startTime == 117717628
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 0 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 49152 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 98304
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 0 || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 96560349184L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 193120681984L
blockManagerInstance.heartbeatManager.stats.capacityTotal == 0 || blockManagerInstance.heartbeatManager.stats.capacityTotal == 134100180992L || blockManagerInstance.heartbeatManager.stats.capacityTotal == 268200361984L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 0 || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 30667841536L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 61335699456L
blockManagerInstance.heartbeatManager.stats.nodesInService == 0 || blockManagerInstance.heartbeatManager.stats.nodesInService == 1 || blockManagerInstance.heartbeatManager.stats.nodesInService == 2
blockManagerInstance.invalidateBlocks.startupTime == 117717108
DataNode.instance.data.volsConfigured >= blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.dnConf.volsConfigured >= blockManagerInstance.heartbeatManager.stats.nodesInService
DataNode.instance.volumeChecker.numSyncDatasetChecks + blockManagerInstance.blockReportLeaseManager.nextId + 2147483647 == 0
blockManagerInstance.blockReportLeaseManager.nextId - 2 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) + 2147483647 == 0
1.014251469184E12 * DataNode.instance.storage.layoutVersion - 4.7673673813E10 * DataNode.instance.xserver.balanceThrottler.curPeriodStart + 71193 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 2.768627738801281E18 == 0
40927232 * DataNode.instance.storage.layoutVersion - 622592 * DataNode.instance.xserver.balanceThrottler.curPeriodStart + 23731 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed + 7.3290231513088E13 == 0
2498 * DataNode.instance.storage.layoutVersion - 38 * DataNode.instance.xserver.balanceThrottler.curPeriodStart + 71193 * blockManagerInstance.heartbeatManager.stats.nodesInService + 4.473280732E9 == 0
3.248203264E9 * DataNode.instance.storage.layoutVersion - 1.43021021439E11 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE + 228 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 2.6835907307034472E16 == 0
8.12050816E9 * DataNode.instance.storage.layoutVersion + 1.43021021439E11 * NameNode.instance.namesystem.fsImage.lastAppliedTxId + 570 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 6.709906463397972E16 == 0
1131393274 * DataNode.instance.storage.layoutVersion - 38 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 4.7673673813E10 * blockManagerInstance.heartbeatManager.stats.nodesInService + 4.473270975598648E15 == 0
85753856 * DataNode.instance.storage.layoutVersion - 933888 * NameNode.instance.namesystem.lazyPersistFileScrubberTS + 49723 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed + 1.09935106326528E14 == 0
5234 * DataNode.instance.storage.layoutVersion - 57 * NameNode.instance.namesystem.lazyPersistFileScrubberTS + 149169 * blockManagerInstance.heartbeatManager.stats.nodesInService + 6.709906392E9 == 0
3309568 * DataNode.instance.storage.layoutVersion - 32768 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime + 1919 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed + 3.857354129408E12 == 0
202 * DataNode.instance.storage.layoutVersion - 2 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime + 5757 * blockManagerInstance.heartbeatManager.stats.nodesInService + 235434212 == 0
202 * DataNode.instance.storage.layoutVersion - 2 * NameNode.instance.namesystem.startTime + 5757 * blockManagerInstance.heartbeatManager.stats.nodesInService + 3.462763224396E12 == 0
2.509140727E9 * DataNode.instance.volumeChecker.lastAllVolumesCheck - 2.259118061570759E15 * DataNode.instance.volumeChecker.numSyncDatasetChecks - 3523 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1.21609180895133344E17 == 0
98304 * DataNode.instance.volumeChecker.lastAllVolumesCheck - 8.8177999872E10 * DataNode.instance.volumeChecker.numSyncDatasetChecks - 3523 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 1.1483668119552E13 == 0
6.1335699456E10 * DataNode.instance.volumeChecker.lastAllVolumesCheck - 5.5017693062135808E16 * DataNode.instance.volumeChecker.numSyncDatasetChecks - 3523 * blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs - 7.1651084028451553E18 == 0
3747 * DataNode.instance.volumeChecker.lastAllVolumesCheck + 896993 * DataNode.instance.xserver.balanceThrottler.curPeriodStart - 1687116726 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1.06029861552613E14 == 0
5234 * DataNode.instance.volumeChecker.lastAllVolumesCheck + 896993 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 2.356650372E9 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1.0620333836505E14 == 0
5757 * DataNode.instance.volumeChecker.lastAllVolumesCheck + 896993 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 2.592135306E9 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1.06263940787399E14 == 0
5757 * DataNode.instance.volumeChecker.lastAllVolumesCheck + 896993 * NameNode.instance.namesystem.startTime - 2.592135306E9 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1.55303785899104563E18 == 0
3.042754407552E12 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 2.509140727E9 * DataNode.instance.xserver.balanceThrottler.curPeriodStart - 3747 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1.45717249410593728E17 == 0
122781696 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 32768 * DataNode.instance.xserver.balanceThrottler.curPeriodStart - 1249 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 3.857380605952E12 == 0
7.6608288620544E13 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 2.0445233152E10 * DataNode.instance.xserver.balanceThrottler.curPeriodStart - 1249 * blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs - 2.4067701978970849E18 == 0
7494 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 2 * DataNode.instance.xserver.balanceThrottler.curPeriodStart - 3747 * blockManagerInstance.heartbeatManager.stats.nodesInService - 235435828 == 0
3.248203264E9 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 2.509140727E9 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 4 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 4.70805391351482E14 == 0
8.12050816E9 * DataNode.instance.volumeChecker.numSyncDatasetChecks - 2.509140727E9 * NameNode.instance.namesystem.fsImage.lastAppliedTxId - 10 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1.17717657252596E15 == 0
4.250273970944E12 * DataNode.instance.volumeChecker.numSyncDatasetChecks - 5234 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 2.509140727E9 * NameNode.instance.namesystem.lazyPersistFileScrubberTS + 3.2076405310351155E17 == 0
4.674976547712E12 * DataNode.instance.volumeChecker.numSyncDatasetChecks - 5757 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 2.509140727E9 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime + 3.8233176787401914E17 == 0
3.394179822E9 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 2 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 2.509140727E9 * blockManagerInstance.heartbeatManager.stats.nodesInService - 2.35435314505192E14 == 0
257261568 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 49152 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 2617 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 5.786058227712E12 == 0
1.60515525476352E14 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 3.0667849728E10 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 2617 * blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs - 3.6101473845403976E18 == 0
5234 * DataNode.instance.volumeChecker.numSyncDatasetChecks + NameNode.instance.namesystem.lazyPersistFileScrubberTS - 2617 * blockManagerInstance.heartbeatManager.stats.nodesInService - 117717656 == 0
188645376 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 32768 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 1919 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 3.857354129408E12 == 0
1.17703207256064E14 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 2.0445233152E10 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 1919 * blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs - 2.4067536781486981E18 == 0
11514 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 2 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 5757 * blockManagerInstance.heartbeatManager.stats.nodesInService - 235434212 == 0
188645376 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 32768 * NameNode.instance.namesystem.startTime - 1919 * blockManagerInstance.heartbeatManager.stats.blockPoolUsed - 5.6733912668504064E16 == 0
11514 * DataNode.instance.volumeChecker.numSyncDatasetChecks + 2 * NameNode.instance.namesystem.startTime - 5757 * blockManagerInstance.heartbeatManager.stats.nodesInService - 3.462763224396E12 == 0
1131393274 * DataNode.instance.xserver.balanceThrottler.curPeriodStart - 2498 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1.076936249959E12 * blockManagerInstance.heartbeatManager.stats.nodesInService + 1.60873451688074368E17 == 0
1697089911 * NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE - 4 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos + 1724477582 * blockManagerInstance.heartbeatManager.stats.nodesInService + 4.70826504672698E14 == 0
1697089911 * NameNode.instance.namesystem.fsImage.lastAppliedTxId + 10 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 4.311193955E9 * blockManagerInstance.heartbeatManager.stats.nodesInService - 1.17717657252596E15 == 0
5234 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 1697089911 * NameNode.instance.namesystem.lazyPersistFileScrubberTS - 2.256478916047E12 * blockManagerInstance.heartbeatManager.stats.nodesInService - 4.1635677171591885E17 == 0
3838 * NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 1131393274 * NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime - 1.654636239929E12 * blockManagerInstance.heartbeatManager.stats.nodesInService - 3.186160265723184E17 == 0
DataNode.instance.id.infoPort == 38217
DataNode.instance.id.ipcPort == 37373
DataNode.instance.id.nsInfo.cTime == 1731381948608L
DataNode.instance.id.nsInfo.namespaceID == 100961160
DataNode.instance.id.xferPort == 45143
DataNode.instance.lastDiskErrorCheck == 118057595
DataNode.instance.storage.namespaceID == 100961160
DataNode.instance.volumeChecker.lastAllVolumesCheck == 117156876 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 118057588
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118056878
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118055682589235L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118057682585430L
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118055682
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118054874
NameNode.instance.namesystem.startTime == 1731381949966L
blockManagerInstance.blockReportLeaseManager.nextId == 5417828063669592554L || blockManagerInstance.blockReportLeaseManager.nextId == 5417828063669592557L
blockManagerInstance.bmSafeMode.startTime == 0 || blockManagerInstance.bmSafeMode.startTime == 118055636
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 0 || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 280463425536L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 0 || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 101221146624L
blockManagerInstance.invalidateBlocks.startupTime == 118054876
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.id.infoPort
DataNode.instance.data.asyncDiskService.numDeletedBlocks == DataNode.instance.infoPort
DataNode.instance.directoryScanner.diffs_FOR_ENCLOSING_USE == blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE
DataNode.instance.directoryScanner.shouldRun == DataNode.instance.id.exportedKeys.isBlockTokenEnabled
DataNode.instance.directoryScanner.shouldRun == DataNode.instance.isBlockTokenEnabled
DataNode.instance.dnConf.allowNonLocalLazyPersist == blockManagerInstance.blockTokenSecretManager.shouldWrapQOP
DataNode.instance.dnConf.allowNonLocalLazyPersist == blockManagerInstance.blockTokenSecretManager.useProto
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.blockTokenSecretManager.nnRangeStart
DataNode.instance.dnConf.ibrInterval == blockManagerInstance.datanodeManager.defaultInfoSecurePort
DataNode.instance.dnConf.pmemCacheRecoveryEnabled == blockManagerInstance.blockTokenSecretManager.isMaster
DataNode.instance.id.exportedKeys.keyUpdateInterval == DataNode.instance.id.exportedKeys.tokenLifetime
DataNode.instance.id.exportedKeys.keyUpdateInterval == blockManagerInstance.blockTokenSecretManager.keyUpdateInterval
DataNode.instance.id.infoSecurePort == DataNode.instance.infoSecurePort
blockManagerInstance.blockTokenSecretManager.keyUpdateInterval == blockManagerInstance.blockTokenSecretManager.tokenLifetime
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME-1) == daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks)
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME) == daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.data.volsConfigured-1)
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME-1) == daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached)
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.data.asyncLazyPersistService.MAXIMUM_THREADS_PER_VOLUME-1) == daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached)
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS-1)
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_SELECTOR_THREADS-1)
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.sequenceNumber-1)
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size)
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, NameNode.instance.namesystem.cacheManager.nextDirectiveId-1)
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, NameNode.instance.namesystem.nnResourceChecker.minimumRedundantVolumes-1)
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.size)
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, blockManagerInstance.bmSafeMode.safeReplication-1)
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, blockManagerInstance.defaultReplication-1)
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) == daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, blockManagerInstance.neededReconstruction.QUEUE_VERY_LOW_REDUNDANCY-1)
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.dnConf.volsConfigured-1) == daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS)
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS) == daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, blockManagerInstance.blocksReplWorkMultiplier-1)
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS) == daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.sequenceNumber-1)
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS) == daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, blockManagerInstance.maxReplicationStreams-1)
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS) == daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, blockManagerInstance.neededReconstruction.QUEUE_LOW_REDUNDANCY-1)
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS) == daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandMultiplier-1)
DataNode.instance.id.exportedKeys.keyUpdateInterval == 36000000
DataNode.instance.id.infoSecurePort == 46407
DataNode.instance.id.ipcPort == 42731
DataNode.instance.id.nsInfo.cTime == 1731381948608L || DataNode.instance.id.nsInfo.cTime == 1731381953948L
DataNode.instance.id.nsInfo.namespaceID == 100961160 || DataNode.instance.id.nsInfo.namespaceID == 142861123
DataNode.instance.id.xferPort == 36651
DataNode.instance.lastDiskErrorCheck == 118060808
DataNode.instance.storage.namespaceID == 0 || DataNode.instance.storage.namespaceID == 100961160 || DataNode.instance.storage.namespaceID == 142861123
DataNode.instance.volumeChecker.lastAllVolumesCheck == 117159722 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 118057588 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 118060807
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118056878 || DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118059724
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118058080197977L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118059665305243L || NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos == 118060823564884L
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118055682 || NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118059665
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118054874 || NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118059294
NameNode.instance.namesystem.startTime == 1731381949966L || NameNode.instance.namesystem.startTime == 1731381954386L
blockManagerInstance.blockReportLeaseManager.nextId == -5252279483860782811L || blockManagerInstance.blockReportLeaseManager.nextId == -5252279483860782810L
daikon.Quant.eltsNotEqual(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, null)
blockManagerInstance.blockTokenSecretManager.intRange == 2147483647
blockManagerInstance.blockTokenSecretManager.keyUpdateInterval == 36000000
blockManagerInstance.blockTokenSecretManager.serialNo == 675004884 || blockManagerInstance.blockTokenSecretManager.serialNo == 675004885
blockManagerInstance.bmSafeMode.startTime == 0 || blockManagerInstance.bmSafeMode.startTime == 118059619
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 0 || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 93487210496L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 0 || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 33740980224L
blockManagerInstance.invalidateBlocks.startupTime == 118059296
daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE) == 2 || daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE) == 3
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.CORE_THREADS_PER_VOLUME) != null
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.data.asyncDiskService.numDeletedBlocks) != null
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.data.cacheManager.numBlocksCached) != null
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.directoryScanner.diffs.serialVersionUID-1) != null
daikon.Quant.getElement_Object(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE, DataNode.instance.dnConf.ibrInterval) != null
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.data.MAX_BLOCK_EVICTIONS_PER_ITERATION >= daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.data.asyncLazyPersistService.CORE_THREADS_PER_VOLUME <= daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)-1
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.data.asyncLazyPersistService.THREADS_KEEP_ALIVE_SECONDS > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.data.cacheManager.numBlocksCached < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.data.cacheManager.numBlocksCached < daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)-1
DataNode.instance.data.cacheManager.revocationMs < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.data.cacheManager.revocationMs > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.data.cacheManager.revocationPollingMs < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.data.cacheManager.revocationPollingMs > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.data.maxDataLength < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.data.maxDataLength > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.data.smallBufferSize < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.data.smallBufferSize > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.data.volsConfigured < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.data.volsConfigured <= daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.data.volsConfigured >= daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)-1
DataNode.instance.directoryScanner.diffs.serialVersionUID < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.directoryScanner.diffs.serialVersionUID <= daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)-1
DataNode.instance.dnConf.blockReportInterval < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.dnConf.blockReportInterval > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.blockReportSplitThreshold < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.dnConf.blockReportSplitThreshold > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.bpReadyTimeout < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.dnConf.bpReadyTimeout > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.cacheReportInterval < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.dnConf.cacheReportInterval > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.dnConf.datanodeSlowIoWarningThresholdMs > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.heartBeatInterval < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.dnConf.heartBeatInterval > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.ibrInterval < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.dnConf.ibrInterval < daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)-1
DataNode.instance.dnConf.lifelineIntervalMs < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.dnConf.lifelineIntervalMs > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.maxDataLength < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.dnConf.maxDataLength > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.outliersReportIntervalMs < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.dnConf.outliersReportIntervalMs > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.readaheadLength < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.dnConf.readaheadLength > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.restartReplicaExpiry < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.dnConf.restartReplicaExpiry > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.socketKeepaliveTimeout < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.dnConf.socketKeepaliveTimeout > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.socketTimeout < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.dnConf.socketTimeout > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.socketWriteTimeout < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.dnConf.socketWriteTimeout > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.volsConfigured <= daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.dnConf.volsConfigured >= daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)-1
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.httpServer.HTTP_ACCEPTOR_THREADS <= daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)-1
DataNode.instance.httpServer.HTTP_MAX_THREADS < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.httpServer.HTTP_MAX_THREADS > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.blockTokenSecretManager.intRange
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.blockTokenSecretManager.keyUpdateInterval
DataNode.instance.id.nsInfo.cTime > blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.id.nsInfo.cTime > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.id.nsInfo.layoutVersion < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.id.nsInfo.layoutVersion < daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)-1
DataNode.instance.id.nsInfo.namespaceID < blockManagerInstance.blockTokenSecretManager.intRange
DataNode.instance.id.nsInfo.namespaceID > blockManagerInstance.blockTokenSecretManager.keyUpdateInterval
DataNode.instance.id.nsInfo.namespaceID < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.id.nsInfo.namespaceID > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.storage.layoutVersion < blockManagerInstance.blockTokenSecretManager.intRange
DataNode.instance.storage.layoutVersion < blockManagerInstance.blockTokenSecretManager.keyUpdateInterval
DataNode.instance.storage.layoutVersion < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.storage.layoutVersion < daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)-1
DataNode.instance.storage.namespaceID < blockManagerInstance.blockTokenSecretManager.intRange
DataNode.instance.storage.namespaceID != blockManagerInstance.blockTokenSecretManager.keyUpdateInterval
DataNode.instance.storage.namespaceID < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.storage.namespaceID != daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.storage.namespaceID != daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)-1
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.volumeChecker.lastAllVolumesCheck < blockManagerInstance.blockTokenSecretManager.intRange
DataNode.instance.volumeChecker.lastAllVolumesCheck > blockManagerInstance.blockTokenSecretManager.keyUpdateInterval
DataNode.instance.volumeChecker.lastAllVolumesCheck < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.volumeChecker.lastAllVolumesCheck > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.blockTokenSecretManager.intRange
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.blockTokenSecretManager.keyUpdateInterval
DataNode.instance.volumeChecker.numSyncDatasetChecks < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.volumeChecker.numSyncDatasetChecks <= daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)-1
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.curPeriodStart < blockManagerInstance.blockTokenSecretManager.intRange
DataNode.instance.xserver.balanceThrottler.curPeriodStart > blockManagerInstance.blockTokenSecretManager.keyUpdateInterval
DataNode.instance.xserver.balanceThrottler.curPeriodStart < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.xserver.balanceThrottler.curPeriodStart > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.maxThreads < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.xserver.balanceThrottler.maxThreads > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.period < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.xserver.balanceThrottler.period > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.xserver.balanceThrottler.periodExtension < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.xserver.balanceThrottler.periodExtension > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.xserver.estimateBlockSize < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.xserver.estimateBlockSize > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.xserver.maxXceiverCount < blockManagerInstance.blockTokenSecretManager.serialNo
DataNode.instance.xserver.maxXceiverCount > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.DEFAULT_PORT < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.DEFAULT_PORT > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.HEALTH_MONITOR_WARN_THRESHOLD_MS > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.blockTokenSecretManager.intRange
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.blockTokenSecretManager.keyUpdateInterval
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.STEP_AWAITING_REPORTED_BLOCKS.size < daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)-1
NameNode.instance.namesystem.blockDeletionIncrement < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.blockDeletionIncrement > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
daikon.Quant.subsetOf(NameNode.instance.namesystem.cacheManager.directivesById_FOR_ENCLOSING_USE, blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.cacheManager.maxListCacheDirectivesNumResponses > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.cacheManager.scanIntervalMs < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.cacheManager.scanIntervalMs > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.datanodeStatistics.REPORT_STALE_NODE_NODES_PER_LINE > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.datanodeStatistics.heartbeatRecheckInterval > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.dir.inodeXAttrsLimit < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.dir.inodeXAttrsLimit > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.dir.maxComponentLength < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.dir.maxComponentLength > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.dir.maxDirItems < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.dir.maxDirItems > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.dir.xattrMaxSize < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.dir.xattrMaxSize > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.editLogRollerThreshold < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.editLogRollerThreshold > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.blockTokenSecretManager.intRange
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.blockTokenSecretManager.keyUpdateInterval
NameNode.instance.namesystem.fsImage.lastAppliedTxId < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.fsImage.lastAppliedTxId <= daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.fsImage.lastAppliedTxId != daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)-1
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.blockTokenSecretManager.intRange
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.blockTokenSecretManager.keyUpdateInterval
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.lazyPersistFileScrubberTS < blockManagerInstance.blockTokenSecretManager.intRange
NameNode.instance.namesystem.lazyPersistFileScrubberTS > blockManagerInstance.blockTokenSecretManager.keyUpdateInterval
NameNode.instance.namesystem.lazyPersistFileScrubberTS < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.lazyPersistFileScrubberTS > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.leaseManager.INODE_FILTER_WORKER_TASK_MIN > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.leaseManager.hardLimit < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.leaseManager.hardLimit > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime < blockManagerInstance.blockTokenSecretManager.intRange
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > blockManagerInstance.blockTokenSecretManager.keyUpdateInterval
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.leaseRecheckIntervalMs < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.leaseRecheckIntervalMs > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.maxLockHoldToReleaseLeaseMs > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.nnResourceChecker.duReserved < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.nnResourceChecker.duReserved > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.snapshotManager.SNAPSHOT_ID_BIT_WIDTH > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit < blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.snapshotManager.maxSnapshotLimit > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
NameNode.instance.namesystem.startTime > blockManagerInstance.blockTokenSecretManager.intRange
NameNode.instance.namesystem.startTime > blockManagerInstance.blockTokenSecretManager.keyUpdateInterval
NameNode.instance.namesystem.startTime > blockManagerInstance.blockTokenSecretManager.serialNo
NameNode.instance.namesystem.startTime > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER < blockManagerInstance.blockTokenSecretManager.serialNo
blockManagerInstance.BLOCK_RECOVERY_TIMEOUT_MULTIPLIER > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID > blockManagerInstance.blockTokenSecretManager.serialNo
blockManagerInstance.blockIdManager.blockIdGenerator.LAST_RESERVED_BLOCK_ID > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.blockReportLeaseManager.maxPending < blockManagerInstance.blockTokenSecretManager.serialNo
blockManagerInstance.blockReportLeaseManager.maxPending > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.blockTokenSecretManager.intRange
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.blockTokenSecretManager.keyUpdateInterval
blockManagerInstance.blockReportLeaseManager.nextId < blockManagerInstance.blockTokenSecretManager.serialNo
blockManagerInstance.blockReportLeaseManager.nextId < daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)-1
blockManagerInstance.blockTokenSecretManager.intRange > blockManagerInstance.blockTokenSecretManager.serialNo
blockManagerInstance.blockTokenSecretManager.intRange > blockManagerInstance.bmSafeMode.startTime
blockManagerInstance.blockTokenSecretManager.intRange > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.blockTokenSecretManager.intRange != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.blockTokenSecretManager.intRange != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.blockTokenSecretManager.intRange != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.blockTokenSecretManager.intRange > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.blockTokenSecretManager.intRange > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.blockTokenSecretManager.keyUpdateInterval < blockManagerInstance.blockTokenSecretManager.serialNo
blockManagerInstance.blockTokenSecretManager.keyUpdateInterval != blockManagerInstance.bmSafeMode.startTime
blockManagerInstance.blockTokenSecretManager.keyUpdateInterval > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.blockTokenSecretManager.keyUpdateInterval != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.blockTokenSecretManager.keyUpdateInterval != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.blockTokenSecretManager.keyUpdateInterval != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.blockTokenSecretManager.keyUpdateInterval > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.blockTokenSecretManager.keyUpdateInterval > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.blockTokenSecretManager.serialNo > blockManagerInstance.blocksMap.capacity
blockManagerInstance.blockTokenSecretManager.serialNo > blockManagerInstance.bmSafeMode.startTime
blockManagerInstance.blockTokenSecretManager.serialNo > blockManagerInstance.datanodeManager.defaultInfoPort
blockManagerInstance.blockTokenSecretManager.serialNo > blockManagerInstance.datanodeManager.defaultIpcPort
blockManagerInstance.blockTokenSecretManager.serialNo > blockManagerInstance.datanodeManager.defaultXferPort
blockManagerInstance.blockTokenSecretManager.serialNo > blockManagerInstance.datanodeManager.heartbeatExpireInterval
blockManagerInstance.blockTokenSecretManager.serialNo > blockManagerInstance.datanodeManager.heartbeatIntervalSeconds
blockManagerInstance.blockTokenSecretManager.serialNo > blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.blockTokenSecretManager.serialNo != blockManagerInstance.heartbeatManager.stats.capacityRemaining
blockManagerInstance.blockTokenSecretManager.serialNo != blockManagerInstance.heartbeatManager.stats.capacityTotal
blockManagerInstance.blockTokenSecretManager.serialNo != blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs
blockManagerInstance.blockTokenSecretManager.serialNo > blockManagerInstance.heartbeatManager.stats.nodesInService
blockManagerInstance.blockTokenSecretManager.serialNo > blockManagerInstance.invalidateBlocks.startupTime
blockManagerInstance.blockTokenSecretManager.serialNo > blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.blockTokenSecretManager.serialNo > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval
blockManagerInstance.blockTokenSecretManager.serialNo > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY
blockManagerInstance.blockTokenSecretManager.serialNo > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold
blockManagerInstance.blockTokenSecretManager.serialNo > blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask
blockManagerInstance.blockTokenSecretManager.serialNo > blockManagerInstance.replQueueResetToHeadThreshold
blockManagerInstance.blockTokenSecretManager.serialNo > blockManagerInstance.storagePolicySuite.defaultPolicyID
blockManagerInstance.blockTokenSecretManager.serialNo > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.blocksMap.capacity > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.bmSafeMode.startTime != daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.bmSafeMode.startTime != daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)-1
blockManagerInstance.datanodeManager.defaultInfoPort > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.defaultIpcPort > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.defaultXferPort > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.heartbeatExpireInterval > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.datanodeManager.heartbeatIntervalSeconds >= daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.blockPoolUsed != daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.blockPoolUsed != daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)-1
blockManagerInstance.heartbeatManager.stats.capacityRemaining != daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.capacityRemaining != daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)-1
blockManagerInstance.heartbeatManager.stats.capacityTotal != daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.capacityTotal != daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)-1
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs != daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs != daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)-1
blockManagerInstance.heartbeatManager.stats.nodesInService < daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)-1
blockManagerInstance.invalidateBlocks.startupTime > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.neededReconstruction.LEVEL > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeoutInterval > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.MINIMUM_CAPACITY > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.expandThreshold > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.pendingRecoveryBlocks.recoveryTimeouts.hash_mask > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.replQueueResetToHeadThreshold > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
blockManagerInstance.storagePolicySuite.defaultPolicyID > daikon.Quant.size(blockManagerInstance.blockTokenSecretManager.allKeys_FOR_ENCLOSING_USE)
DataNode.instance.id.infoPort == 42145
DataNode.instance.id.ipcPort == 46407
DataNode.instance.id.nsInfo.cTime == 1731381937765L
DataNode.instance.id.nsInfo.namespaceID == 1657243967
DataNode.instance.id.xferPort == 43475
DataNode.instance.lastDiskErrorCheck == 118046769
DataNode.instance.storage.namespaceID == 1657243967
DataNode.instance.volumeChecker.lastAllVolumesCheck == 117146154 || DataNode.instance.volumeChecker.lastAllVolumesCheck == 118046762
DataNode.instance.xserver.balanceThrottler.curPeriodStart == 118046155
DataNode.instance.xserver.estimateBlockSize == 102400
NameNode.instance.namesystem.lazyPersistFileScrubberTS == 118044891
NameNode.instance.namesystem.leaseManager.lastHolderUpdateTime == 118044199
NameNode.instance.namesystem.startTime == 1731381939291L
blockManagerInstance.blockReportLeaseManager.nextId == 3734955285369570802L || blockManagerInstance.blockReportLeaseManager.nextId == 3734955285369570805L
blockManagerInstance.bmSafeMode.startTime == 0 || blockManagerInstance.bmSafeMode.startTime == 118044853
blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 0 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 147456 || blockManagerInstance.heartbeatManager.stats.blockPoolUsed == 8197602
blockManagerInstance.heartbeatManager.stats.capacityRemaining == 0 || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 280452214784L || blockManagerInstance.heartbeatManager.stats.capacityRemaining == 280504369152L
blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 0 || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 101180203008L || blockManagerInstance.heartbeatManager.stats.capacityUsedNonDfs == 101224204830L
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 0 || blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 3 || blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount == 8
blockManagerInstance.invalidateBlocks.startupTime == 118044202
blockManagerInstance.lastRedundancyCycleTS == -1 || blockManagerInstance.lastRedundancyCycleTS == 118047852
DataNode.instance.data.cacheManager.revocationMs != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.blockReportSplitThreshold != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.outliersReportIntervalMs != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.readaheadLength != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.dnConf.socketWriteTimeout != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.httpServer.HTTP_MAX_THREADS != blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
DataNode.instance.storageLocationChecker.delegateChecker.minMsBetweenChecks != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.volumeChecker.delegateChecker.diskCheckTimeout != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.volumeChecker.lastAllVolumesCheck > DataNode.instance.xserver.estimateBlockSize
DataNode.instance.xserver.balanceThrottler.bytesPerPeriod != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.xserver.estimateBlockSize < blockManagerInstance.bmSafeMode.startTime
DataNode.instance.xserver.estimateBlockSize != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
DataNode.instance.xserver.estimateBlockSize != blockManagerInstance.lastRedundancyCycleTS
NameNode.instance.namesystem.DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.dir.maxDirItems != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.editLogRollerThreshold != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
NameNode.instance.namesystem.leaseManager.hardLimit != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.blockReportLeaseManager.leaseExpiryMs != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.blockReportLeaseManager.maxPending != blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.blockReportThread.MAX_LOCK_HOLD_MS != blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.heartbeatManager.stats.capacityRemaining % blockManagerInstance.bmSafeMode.STEP_AWAITING_REPORTED_BLOCKS.SEQUENCE == 0
blockManagerInstance.datanodeManager.heartbeatExpireInterval != blockManagerInstance.heartbeatManager.stats.blockPoolUsed
blockManagerInstance.heartbeatManager.stats.blockPoolUsed != blockManagerInstance.storageInfoDefragmentInterval
blockManagerInstance.heartbeatManager.stats.blockPoolUsed % daikon.Quant.size(NameNode.instance.namesystem.topMetrics.rollingWindowManagers_FOR_ENCLOSING_USE)-1 == 0
blockManagerInstance.heartbeatManager.stats.nodesInService <= blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount != blockManagerInstance.neededReconstruction.LEVEL
blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount != blockManagerInstance.storagePolicySuite.defaultPolicyID
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 653424575 * blockManagerInstance.heartbeatManager.stats.nodesInService - 178954609 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) - 1.18044891964615E14 == 0
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 653424575 * blockManagerInstance.heartbeatManager.stats.nodesInService - 178954609 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 - 1.18045070919224E14 == 0
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 653424575 * blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount - 178954609 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) - 1.18044891964615E14 == 0
NameNode.instance.namesystem.fsLock.writeLockHeldTimeStampNanos - 653424575 * blockManagerInstance.heartbeatManager.stats.nodesInServiceXceiverCount - 178954609 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE)-1 - 1.18045070919224E14 == 0
blockManagerInstance.blockReportLeaseManager.nextId - 3 * blockManagerInstance.replQueueCallsSinceReset - 3 * daikon.Quant.size(NameNode.instance.namesystem.leaseManager.leasesById_FOR_ENCLOSING_USE) - 3.7349552853695708E18 == 0
